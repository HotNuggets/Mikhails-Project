"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function makeException(ErrorType, message, options) {
  if (options.globals) {
    ErrorType = options.globals[ErrorType.name];
  }

  return new ErrorType("".concat(options.context ? options.context : "Value", " ").concat(message, "."));
}

function toNumber(value, options) {
  if (typeof value === "bigint") {
    throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
  }

  if (!options.globals) {
    return Number(value);
  }

  return options.globals.Number(value);
} // Round x to the nearest integer, choosing the even integer if it lies halfway between two.


function evenRound(x) {
  // There are four cases for numbers with fractional part being .5:
  //
  // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example
  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0
  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2
  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0
  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2
  // (where n is a non-negative integer)
  //
  // Branch here for cases 1 and 4
  if (x > 0 && x % 1 === +0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
    return censorNegativeZero(Math.floor(x));
  }

  return censorNegativeZero(Math.round(x));
}

function integerPart(n) {
  return censorNegativeZero(Math.trunc(n));
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

function modulo(x, y) {
  // https://tc39.github.io/ecma262/#eqn-modulo
  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos
  var signMightNotMatch = x % y;

  if (sign(y) !== sign(signMightNotMatch)) {
    return signMightNotMatch + y;
  }

  return signMightNotMatch;
}

function censorNegativeZero(x) {
  return x === 0 ? 0 : x;
}

function createIntegerConversion(bitLength, _ref) {
  var unsigned = _ref.unsigned;
  var lowerBound, upperBound;

  if (unsigned) {
    lowerBound = 0;
    upperBound = Math.pow(2, bitLength) - 1;
  } else {
    lowerBound = -Math.pow(2, bitLength - 1);
    upperBound = Math.pow(2, bitLength - 1) - 1;
  }

  var twoToTheBitLength = Math.pow(2, bitLength);
  var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);
  return function (value) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var x = toNumber(value, options);
    x = censorNegativeZero(x);

    if (options.enforceRange) {
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite number", options);
      }

      x = integerPart(x);

      if (x < lowerBound || x > upperBound) {
        throw makeException(TypeError, "is outside the accepted range of ".concat(lowerBound, " to ").concat(upperBound, ", inclusive"), options);
      }

      return x;
    }

    if (!Number.isNaN(x) && options.clamp) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      x = evenRound(x);
      return x;
    }

    if (!Number.isFinite(x) || x === 0) {
      return 0;
    }

    x = integerPart(x); // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if
    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.

    if (x >= lowerBound && x <= upperBound) {
      return x;
    } // These will not work great for bitLength of 64, but oh well. See the README for more details.


    x = modulo(x, twoToTheBitLength);

    if (!unsigned && x >= twoToOneLessThanTheBitLength) {
      return x - twoToTheBitLength;
    }

    return x;
  };
}

function createLongLongConversion(bitLength, _ref2) {
  var unsigned = _ref2.unsigned;
  var upperBound = Number.MAX_SAFE_INTEGER;
  var lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
  var asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
  return function (value) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var x = toNumber(value, options);
    x = censorNegativeZero(x);

    if (options.enforceRange) {
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite number", options);
      }

      x = integerPart(x);

      if (x < lowerBound || x > upperBound) {
        throw makeException(TypeError, "is outside the accepted range of ".concat(lowerBound, " to ").concat(upperBound, ", inclusive"), options);
      }

      return x;
    }

    if (!Number.isNaN(x) && options.clamp) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      x = evenRound(x);
      return x;
    }

    if (!Number.isFinite(x) || x === 0) {
      return 0;
    }

    var xBigInt = BigInt(integerPart(x));
    xBigInt = asBigIntN(bitLength, xBigInt);
    return Number(xBigInt);
  };
}

exports.any = function (value) {
  return value;
};

exports.undefined = function () {
  return undefined;
};

exports["boolean"] = function (value) {
  return Boolean(value);
};

exports["byte"] = createIntegerConversion(8, {
  unsigned: false
});
exports.octet = createIntegerConversion(8, {
  unsigned: true
});
exports["short"] = createIntegerConversion(16, {
  unsigned: false
});
exports["unsigned short"] = createIntegerConversion(16, {
  unsigned: true
});
exports["long"] = createIntegerConversion(32, {
  unsigned: false
});
exports["unsigned long"] = createIntegerConversion(32, {
  unsigned: true
});
exports["long long"] = createLongLongConversion(64, {
  unsigned: false
});
exports["unsigned long long"] = createLongLongConversion(64, {
  unsigned: true
});

exports["double"] = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var x = toNumber(value, options);

  if (!Number.isFinite(x)) {
    throw makeException(TypeError, "is not a finite floating-point value", options);
  }

  return x;
};

exports["unrestricted double"] = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var x = toNumber(value, options);
  return x;
};

exports["float"] = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var x = toNumber(value, options);

  if (!Number.isFinite(x)) {
    throw makeException(TypeError, "is not a finite floating-point value", options);
  }

  if (Object.is(x, -0)) {
    return x;
  }

  var y = Math.fround(x);

  if (!Number.isFinite(y)) {
    throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
  }

  return y;
};

exports["unrestricted float"] = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var x = toNumber(value, options);

  if (isNaN(x)) {
    return x;
  }

  if (Object.is(x, -0)) {
    return x;
  }

  return Math.fround(x);
};

exports.DOMString = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (options.treatNullAsEmptyString && value === null) {
    return "";
  }

  if (_typeof(value) === "symbol") {
    throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
  }

  var StringCtor = options.globals ? options.globals.String : String;
  return StringCtor(value);
};

exports.ByteString = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var x = exports.DOMString(value, options);
  var c;

  for (var i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
    if (c > 255) {
      throw makeException(TypeError, "is not a valid ByteString", options);
    }
  }

  return x;
};

exports.USVString = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var S = exports.DOMString(value, options);
  var n = S.length;
  var U = [];

  for (var i = 0; i < n; ++i) {
    var c = S.charCodeAt(i);

    if (c < 0xD800 || c > 0xDFFF) {
      U.push(String.fromCodePoint(c));
    } else if (0xDC00 <= c && c <= 0xDFFF) {
      U.push(String.fromCodePoint(0xFFFD));
    } else if (i === n - 1) {
      U.push(String.fromCodePoint(0xFFFD));
    } else {
      var d = S.charCodeAt(i + 1);

      if (0xDC00 <= d && d <= 0xDFFF) {
        var a = c & 0x3FF;
        var b = d & 0x3FF;
        U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
        ++i;
      } else {
        U.push(String.fromCodePoint(0xFFFD));
      }
    }
  }

  return U.join("");
};

exports.object = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (value === null || _typeof(value) !== "object" && typeof value !== "function") {
    throw makeException(TypeError, "is not an object", options);
  }

  return value;
};

var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;

function isNonSharedArrayBuffer(value) {
  try {
    // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.
    // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)
    abByteLengthGetter.call(value);
    return true;
  } catch (_unused) {
    return false;
  }
}

function isSharedArrayBuffer(value) {
  try {
    sabByteLengthGetter.call(value);
    return true;
  } catch (_unused2) {
    return false;
  }
}

function isArrayBufferDetached(value) {
  try {
    // eslint-disable-next-line no-new
    new Uint8Array(value);
    return false;
  } catch (_unused3) {
    return true;
  }
}

exports.ArrayBuffer = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isNonSharedArrayBuffer(value)) {
    if (options.allowShared && !isSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
    }

    throw makeException(TypeError, "is not an ArrayBuffer", options);
  }

  if (isArrayBufferDetached(value)) {
    throw makeException(TypeError, "is a detached ArrayBuffer", options);
  }

  return value;
};

var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;

exports.DataView = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    dvByteLengthGetter.call(value);
  } catch (e) {
    throw makeException(TypeError, "is not a DataView", options);
  }

  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
    throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
  }

  if (isArrayBufferDetached(value.buffer)) {
    throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
  }

  return value;
}; // Returns the unforgeable `TypedArray` constructor name or `undefined`,
// if the `this` value isn't a valid `TypedArray` object.
//
// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag


var typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
[Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array].forEach(function (func) {
  var name = func.name;
  var article = /^[AEIOU]/.test(name) ? "an" : "a";

  exports[name] = function (value) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
      throw makeException(TypeError, "is not ".concat(article, " ").concat(name, " object"), options);
    }

    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }

    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
    }

    return value;
  };
}); // Common definitions

exports.ArrayBufferView = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!ArrayBuffer.isView(value)) {
    throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
  }

  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
    throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
  }

  if (isArrayBufferDetached(value.buffer)) {
    throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
  }

  return value;
};

exports.BufferSource = function (value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (ArrayBuffer.isView(value)) {
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }

    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
    }

    return value;
  }

  if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
    throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
  }

  if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
    throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
  }

  if (isArrayBufferDetached(value)) {
    throw makeException(TypeError, "is a detached ArrayBuffer", options);
  }

  return value;
};

exports.DOMTimeStamp = exports["unsigned long long"];