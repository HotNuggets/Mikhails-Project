"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.decorateDecryptionResult = exports.noop = exports.fileIsAccessible = exports.maybeAddIdToDocuments = exports.once = exports.randomBytes = exports.squashError = exports.promiseWithResolvers = exports.isHostMatch = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = exports.DOCUMENT_DB_CHECK = exports.request = exports.get = exports.checkParentDomainMatch = exports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.maxWireVersion = exports.uuidV4 = exports.makeCounter = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.hostMatchesWildcards = exports.isUint8Array = exports.ByteUtils = void 0;
var crypto = require("crypto");
var fs_1 = require("fs");
var http = require("http");
var timers_1 = require("timers");
var url = require("url");
var url_1 = require("url");
var util_1 = require("util");
var bson_1 = require("./bson");
var constants_1 = require("./cmap/wire_protocol/constants");
var constants_2 = require("./constants");
var error_1 = require("./error");
var read_concern_1 = require("./read_concern");
var read_preference_1 = require("./read_preference");
var common_1 = require("./sdam/common");
var write_concern_1 = require("./write_concern");
exports.ByteUtils = {
    toLocalBufferType: function (buffer) {
        return Buffer.isBuffer(buffer)
            ? buffer
            : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    },
    equals: function (seqA, seqB) {
        return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
    },
    compare: function (seqA, seqB) {
        return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
    },
    toBase64: function (uint8array) {
        return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');
    }
};
/**
 * Returns true if value is a Uint8Array or a Buffer
 * @param value - any value that may be a Uint8Array
 */
function isUint8Array(value) {
    return (value != null &&
        typeof value === 'object' &&
        Symbol.toStringTag in value &&
        value[Symbol.toStringTag] === 'Uint8Array');
}
exports.isUint8Array = isUint8Array;
/**
 * Determines if a connection's address matches a user provided list
 * of domain wildcards.
 */
function hostMatchesWildcards(host, wildcards) {
    for (var _i = 0, wildcards_1 = wildcards; _i < wildcards_1.length; _i++) {
        var wildcard = wildcards_1[_i];
        if (host === wildcard ||
            (wildcard.startsWith('*.') && (host === null || host === void 0 ? void 0 : host.endsWith(wildcard.substring(2, wildcard.length)))) ||
            (wildcard.startsWith('*/') && (host === null || host === void 0 ? void 0 : host.endsWith(wildcard.substring(2, wildcard.length))))) {
            return true;
        }
    }
    return false;
}
exports.hostMatchesWildcards = hostMatchesWildcards;
/**
 * Ensure Hint field is in a shape we expect:
 * - object of index names mapping to 1 or -1
 * - just an index name
 * @internal
 */
function normalizeHintField(hint) {
    var finalHint = undefined;
    if (typeof hint === 'string') {
        finalHint = hint;
    }
    else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function (param) {
            finalHint[param] = 1;
        });
    }
    else if (hint != null && typeof hint === 'object') {
        finalHint = {};
        for (var name in hint) {
            finalHint[name] = hint[name];
        }
    }
    return finalHint;
}
exports.normalizeHintField = normalizeHintField;
var TO_STRING = function (object) { return Object.prototype.toString.call(object); };
/**
 * Checks if arg is an Object:
 * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`
 * @internal
 */
function isObject(arg) {
    return '[object Object]' === TO_STRING(arg);
}
exports.isObject = isObject;
/** @internal */
function mergeOptions(target, source) {
    return __assign(__assign({}, target), source);
}
exports.mergeOptions = mergeOptions;
/** @internal */
function filterOptions(options, names) {
    var filterOptions = {};
    for (var name in options) {
        if (names.includes(name)) {
            filterOptions[name] = options[name];
        }
    }
    // Filtered options
    return filterOptions;
}
exports.filterOptions = filterOptions;
/**
 * Applies retryWrites: true to a command if retryWrites is set on the command's database.
 * @internal
 *
 * @param target - The target command to which we will apply retryWrites.
 * @param db - The database from which we can inherit a retryWrites value.
 */
function applyRetryableWrites(target, db) {
    var _a;
    if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {
        target.retryWrites = true;
    }
    return target;
}
exports.applyRetryableWrites = applyRetryableWrites;
/**
 * Applies a write concern to a command based on well defined inheritance rules, optionally
 * detecting support for the write concern in the first place.
 * @internal
 *
 * @param target - the target command we will be applying the write concern to
 * @param sources - sources where we can inherit default write concerns from
 * @param options - optional settings passed into a command for write concern overrides
 */
/**
 * Checks if a given value is a Promise
 *
 * @typeParam T - The resolution type of the possible promise
 * @param value - An object that could be a promise
 * @returns true if the provided value is a Promise
 */
function isPromiseLike(value) {
    return (value != null &&
        typeof value === 'object' &&
        'then' in value &&
        typeof value.then === 'function');
}
exports.isPromiseLike = isPromiseLike;
/**
 * Applies collation to a given command.
 * @internal
 *
 * @param command - the command on which to apply collation
 * @param target - target of command
 * @param options - options containing collation settings
 */
function decorateWithCollation(command, target, options) {
    var capabilities = getTopology(target).capabilities;
    if (options.collation && typeof options.collation === 'object') {
        if (capabilities && capabilities.commandsTakeCollation) {
            command.collation = options.collation;
        }
        else {
            throw new error_1.MongoCompatibilityError("Current topology does not support collation");
        }
    }
}
exports.decorateWithCollation = decorateWithCollation;
/**
 * Applies a read concern to a given command.
 * @internal
 *
 * @param command - the command on which to apply the read concern
 * @param coll - the parent collection of the operation calling this method
 */
function decorateWithReadConcern(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
        return;
    }
    var readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern: readConcern });
    }
}
exports.decorateWithReadConcern = decorateWithReadConcern;
/**
 * Applies an explain to a given command.
 * @internal
 *
 * @param command - the command on which to apply the explain
 * @param options - the options containing the explain verbosity
 */
function decorateWithExplain(command, explain) {
    var verbosity = explain.verbosity, maxTimeMS = explain.maxTimeMS;
    var baseCommand = { explain: command, verbosity: verbosity };
    if (typeof maxTimeMS === 'number') {
        baseCommand.maxTimeMS = maxTimeMS;
    }
    return baseCommand;
}
exports.decorateWithExplain = decorateWithExplain;
/**
 * A helper function to get the topology from a given provider. Throws
 * if the topology cannot be found.
 * @throws MongoNotConnectedError
 * @internal
 */
function getTopology(provider) {
    // MongoClient or ClientSession or AbstractCursor
    if ('topology' in provider && provider.topology) {
        return provider.topology;
    }
    else if ('client' in provider && provider.client.topology) {
        return provider.client.topology;
    }
    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');
}
exports.getTopology = getTopology;
/** @internal */
function ns(ns) {
    return MongoDBNamespace.fromString(ns);
}
exports.ns = ns;
/** @public */
var MongoDBNamespace = /** @class */ (function () {
    /**
     * Create a namespace object
     *
     * @param db - database name
     * @param collection - collection name
     */
    function MongoDBNamespace(db, collection) {
        this.db = db;
        this.collection = collection;
        this.collection = collection === '' ? undefined : collection;
    }
    MongoDBNamespace.prototype.toString = function () {
        return this.collection ? this.db + "." + this.collection : this.db;
    };
    MongoDBNamespace.prototype.withCollection = function (collection) {
        return new MongoDBCollectionNamespace(this.db, collection);
    };
    MongoDBNamespace.fromString = function (namespace) {
        if (typeof namespace !== 'string' || namespace === '') {
            // TODO(NODE-3483): Replace with MongoNamespaceError
            throw new error_1.MongoRuntimeError("Cannot parse namespace from \"" + namespace + "\"");
        }
        var _a = namespace.split('.'), db = _a[0], collectionParts = _a.slice(1);
        var collection = collectionParts.join('.');
        return new MongoDBNamespace(db, collection === '' ? undefined : collection);
    };
    return MongoDBNamespace;
}());
exports.MongoDBNamespace = MongoDBNamespace;
/**
 * @public
 *
 * A class representing a collection's namespace.  This class enforces (through Typescript) that
 * the `collection` portion of the namespace is defined and should only be
 * used in scenarios where this can be guaranteed.
 */
var MongoDBCollectionNamespace = /** @class */ (function (_super) {
    __extends(MongoDBCollectionNamespace, _super);
    function MongoDBCollectionNamespace(db, override, collection) {
        return _super.call(this, db, collection) || this;
    }
    MongoDBCollectionNamespace.prototype.fromString = function (namespace) {
        return _super.prototype.fromString.call(this, namespace);
    };
    return MongoDBCollectionNamespace;
}(MongoDBNamespace));
exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
/** @internal */
function makeCounter(seed) {
    var count, newCount;
    if (seed === void 0) { seed = 0; }
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                count = seed;
                _a.label = 1;
            case 1:
                if (!true) return [3 /*break*/, 3];
                newCount = count;
                count += 1;
                return [4 /*yield*/, newCount];
            case 2:
                _a.sent();
                return [3 /*break*/, 1];
            case 3: return [2 /*return*/];
        }
    });
}
exports.makeCounter = makeCounter;
/**
 * Synchronously Generate a UUIDv4
 * @internal
 */
function uuidV4() {
    var result = crypto.randomBytes(16);
    result[6] = (result[6] & 0x0f) | 0x40;
    result[8] = (result[8] & 0x3f) | 0x80;
    return result;
}
exports.uuidV4 = uuidV4;
/**
 * A helper function for determining `maxWireVersion` between legacy and new topology instances
 * @internal
 */
function maxWireVersion(topologyOrServer) {
    var _a;
    if (topologyOrServer) {
        if (topologyOrServer.loadBalanced || ((_a = topologyOrServer.serverApi) === null || _a === void 0 ? void 0 : _a.version)) {
            // Since we do not have a monitor in the load balanced mode,
            // we assume the load-balanced server is always pointed at the latest mongodb version.
            // There is a risk that for on-prem deployments
            // that don't upgrade immediately that this could alert to the
            // application that a feature is available that is actually not.
            // We also return the max supported wire version for serverAPI.
            return constants_1.MAX_SUPPORTED_WIRE_VERSION;
        }
        if (topologyOrServer.hello) {
            return topologyOrServer.hello.maxWireVersion;
        }
        if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {
            var lastHello = topologyOrServer.lastHello();
            if (lastHello) {
                return lastHello.maxWireVersion;
            }
        }
        if (topologyOrServer.description &&
            'maxWireVersion' in topologyOrServer.description &&
            topologyOrServer.description.maxWireVersion != null) {
            return topologyOrServer.description.maxWireVersion;
        }
    }
    return 0;
}
exports.maxWireVersion = maxWireVersion;
/** @internal */
function arrayStrictEqual(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
    }
    return arr.length === arr2.length && arr.every(function (elt, idx) { return elt === arr2[idx]; });
}
exports.arrayStrictEqual = arrayStrictEqual;
/** @internal */
function errorStrictEqual(lhs, rhs) {
    if (lhs === rhs) {
        return true;
    }
    if (!lhs || !rhs) {
        return lhs === rhs;
    }
    if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {
        return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
    }
    if (lhs.message !== rhs.message) {
        return false;
    }
    return true;
}
exports.errorStrictEqual = errorStrictEqual;
/** @internal */
function makeStateMachine(stateTable) {
    return function stateTransition(target, newState) {
        var legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
            throw new error_1.MongoRuntimeError("illegal state transition from [" + target.s.state + "] => [" + newState + "], allowed: [" + legalStates + "]");
        }
        target.emit('stateChanged', target.s.state, newState);
        target.s.state = newState;
    };
}
exports.makeStateMachine = makeStateMachine;
/** @internal */
function now() {
    var hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);
}
exports.now = now;
/** @internal */
function calculateDurationInMs(started) {
    if (typeof started !== 'number') {
        return -1;
    }
    var elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
}
exports.calculateDurationInMs = calculateDurationInMs;
/** @internal */
function hasAtomicOperators(doc) {
    if (Array.isArray(doc)) {
        for (var _i = 0, doc_1 = doc; _i < doc_1.length; _i++) {
            var document = doc_1[_i];
            if (hasAtomicOperators(document)) {
                return true;
            }
        }
        return false;
    }
    var keys = Object.keys(doc);
    return keys.length > 0 && keys[0][0] === '$';
}
exports.hasAtomicOperators = hasAtomicOperators;
/**
 * Merge inherited properties from parent into options, prioritizing values from options,
 * then values from parent.
 * @internal
 */
function resolveOptions(parent, options) {
    var _a, _b, _c;
    var result = Object.assign({}, options, bson_1.resolveBSONOptions(options, parent));
    // Users cannot pass a readConcern/writeConcern to operations in a transaction
    var session = options === null || options === void 0 ? void 0 : options.session;
    if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {
        var readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;
        if (readConcern) {
            result.readConcern = readConcern;
        }
        var writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;
        if (writeConcern) {
            result.writeConcern = writeConcern;
        }
    }
    var readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;
    if (readPreference) {
        result.readPreference = readPreference;
    }
    return result;
}
exports.resolveOptions = resolveOptions;
function isSuperset(set, subset) {
    set = Array.isArray(set) ? new Set(set) : set;
    subset = Array.isArray(subset) ? new Set(subset) : subset;
    for (var _i = 0, subset_1 = subset; _i < subset_1.length; _i++) {
        var elem = subset_1[_i];
        if (!set.has(elem)) {
            return false;
        }
    }
    return true;
}
exports.isSuperset = isSuperset;
/**
 * Checks if the document is a Hello request
 * @internal
 */
function isHello(doc) {
    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
}
exports.isHello = isHello;
/** Returns the items that are uniquely in setA */
function setDifference(setA, setB) {
    var difference = new Set(setA);
    for (var _i = 0, setB_1 = setB; _i < setB_1.length; _i++) {
        var elem = setB_1[_i];
        difference["delete"](elem);
    }
    return difference;
}
exports.setDifference = setDifference;
var HAS_OWN = function (object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
};
function isRecord(value, requiredKeys) {
    if (requiredKeys === void 0) { requiredKeys = undefined; }
    if (!isObject(value)) {
        return false;
    }
    var ctor = value.constructor;
    if (ctor && ctor.prototype) {
        if (!isObject(ctor.prototype)) {
            return false;
        }
        // Check to see if some method exists from the Object exists
        if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {
            return false;
        }
    }
    if (requiredKeys) {
        var keys = Object.keys(value);
        return isSuperset(keys, requiredKeys);
    }
    return true;
}
exports.isRecord = isRecord;
/**
 * Make a deep copy of an object
 *
 * NOTE: This is not meant to be the perfect implementation of a deep copy,
 * but instead something that is good enough for the purposes of
 * command monitoring.
 */
function deepCopy(value) {
    if (value == null) {
        return value;
    }
    else if (Array.isArray(value)) {
        return value.map(function (item) { return deepCopy(item); });
    }
    else if (isRecord(value)) {
        var res = {};
        for (var key in value) {
            res[key] = deepCopy(value[key]);
        }
        return res;
    }
    var ctor = value.constructor;
    if (ctor) {
        switch (ctor.name.toLowerCase()) {
            case 'date':
                return new ctor(Number(value));
            case 'map':
                return new Map(value);
            case 'set':
                return new Set(value);
            case 'buffer':
                return Buffer.from(value);
        }
    }
    return value;
}
exports.deepCopy = deepCopy;
/**
 * A sequential list of items in a circularly linked list
 * @remarks
 * The head node is special, it is always defined and has a value of null.
 * It is never "included" in the list, in that, it is not returned by pop/shift or yielded by the iterator.
 * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.
 * New nodes are declared as object literals with keys always in the same order: next, prev, value.
 * @internal
 */
var List = /** @class */ (function () {
    function List() {
        this.count = 0;
        // this is carefully crafted:
        // declaring a complete and consistently key ordered
        // object is beneficial to the runtime optimizations
        this.head = {
            next: null,
            prev: null,
            value: null
        };
        this.head.next = this.head;
        this.head.prev = this.head;
    }
    Object.defineProperty(List.prototype, "length", {
        get: function () {
            return this.count;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(List.prototype, Symbol.toStringTag, {
        get: function () {
            return 'List';
        },
        enumerable: false,
        configurable: true
    });
    List.prototype.toArray = function () {
        return Array.from(this);
    };
    List.prototype.toString = function () {
        return "head <=> " + this.toArray().join(' <=> ') + " <=> head";
    };
    List.prototype[Symbol.iterator] = function () {
        var _i, _a, node;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _i = 0, _a = this.nodes();
                    _b.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                    node = _a[_i];
                    return [4 /*yield*/, node.value];
                case 2:
                    _b.sent();
                    _b.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    List.prototype.nodes = function () {
        var ptr, next;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ptr = this.head.next;
                    _a.label = 1;
                case 1:
                    if (!(ptr !== this.head)) return [3 /*break*/, 3];
                    next = ptr.next;
                    return [4 /*yield*/, ptr];
                case 2:
                    _a.sent();
                    ptr = next;
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    };
    /** Insert at end of list */
    List.prototype.push = function (value) {
        this.count += 1;
        var newNode = {
            next: this.head,
            prev: this.head.prev,
            value: value
        };
        this.head.prev.next = newNode;
        this.head.prev = newNode;
    };
    /** Inserts every item inside an iterable instead of the iterable itself */
    List.prototype.pushMany = function (iterable) {
        for (var _i = 0, iterable_1 = iterable; _i < iterable_1.length; _i++) {
            var value = iterable_1[_i];
            this.push(value);
        }
    };
    /** Insert at front of list */
    List.prototype.unshift = function (value) {
        this.count += 1;
        var newNode = {
            next: this.head.next,
            prev: this.head,
            value: value
        };
        this.head.next.prev = newNode;
        this.head.next = newNode;
    };
    List.prototype.remove = function (node) {
        if (node === this.head || this.length === 0) {
            return null;
        }
        this.count -= 1;
        var prevNode = node.prev;
        var nextNode = node.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        return node.value;
    };
    /** Removes the first node at the front of the list */
    List.prototype.shift = function () {
        return this.remove(this.head.next);
    };
    /** Removes the last node at the end of the list */
    List.prototype.pop = function () {
        return this.remove(this.head.prev);
    };
    /** Iterates through the list and removes nodes where filter returns true */
    List.prototype.prune = function (filter) {
        for (var _i = 0, _a = this.nodes(); _i < _a.length; _i++) {
            var node = _a[_i];
            if (filter(node.value)) {
                this.remove(node);
            }
        }
    };
    List.prototype.clear = function () {
        this.count = 0;
        this.head.next = this.head;
        this.head.prev = this.head;
    };
    /** Returns the first item in the list, does not remove */
    List.prototype.first = function () {
        // If the list is empty, value will be the head's null
        return this.head.next.value;
    };
    /** Returns the last item in the list, does not remove */
    List.prototype.last = function () {
        // If the list is empty, value will be the head's null
        return this.head.prev.value;
    };
    return List;
}());
exports.List = List;
/**
 * A pool of Buffers which allow you to read them as if they were one
 * @internal
 */
var BufferPool = /** @class */ (function () {
    function BufferPool() {
        this.buffers = new List();
        this.totalByteLength = 0;
    }
    Object.defineProperty(BufferPool.prototype, "length", {
        get: function () {
            return this.totalByteLength;
        },
        enumerable: false,
        configurable: true
    });
    /** Adds a buffer to the internal buffer pool list */
    BufferPool.prototype.append = function (buffer) {
        this.buffers.push(buffer);
        this.totalByteLength += buffer.length;
    };
    /**
     * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,
     * otherwise return null. Size can be negative, caller should error check.
     */
    BufferPool.prototype.getInt32 = function () {
        if (this.totalByteLength < 4) {
            return null;
        }
        var firstBuffer = this.buffers.first();
        if (firstBuffer != null && firstBuffer.byteLength >= 4) {
            return firstBuffer.readInt32LE(0);
        }
        // Unlikely case: an int32 is split across buffers.
        // Use read and put the returned buffer back on top
        var top4Bytes = this.read(4);
        var value = top4Bytes.readInt32LE(0);
        // Put it back.
        this.totalByteLength += 4;
        this.buffers.unshift(top4Bytes);
        return value;
    };
    /** Reads the requested number of bytes, optionally consuming them */
    BufferPool.prototype.read = function (size) {
        if (typeof size !== 'number' || size < 0) {
            throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
        }
        // oversized request returns empty buffer
        if (size > this.totalByteLength) {
            return Buffer.alloc(0);
        }
        // We know we have enough, we just don't know how it is spread across chunks
        // TODO(NODE-4732): alloc API should change based on raw option
        var result = Buffer.allocUnsafe(size);
        for (var bytesRead = 0; bytesRead < size;) {
            var buffer = this.buffers.shift();
            if (buffer == null) {
                break;
            }
            var bytesRemaining = size - bytesRead;
            var bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
            var bytes = buffer.subarray(0, bytesReadable);
            result.set(bytes, bytesRead);
            bytesRead += bytesReadable;
            this.totalByteLength -= bytesReadable;
            if (bytesReadable < buffer.byteLength) {
                this.buffers.unshift(buffer.subarray(bytesReadable));
            }
        }
        return result;
    };
    return BufferPool;
}());
exports.BufferPool = BufferPool;
/** @public */
var HostAddress = /** @class */ (function () {
    function HostAddress(hostString) {
        this.host = undefined;
        this.port = undefined;
        this.socketPath = undefined;
        this.isIPv6 = false;
        var escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts
        if (escapedHost.endsWith('.sock')) {
            // heuristically determine if we're working with a domain socket
            this.socketPath = decodeURIComponent(escapedHost);
            return;
        }
        var urlString = "iLoveJS://" + escapedHost;
        var url;
        try {
            url = new url_1.URL(urlString);
        }
        catch (urlError) {
            var runtimeError = new error_1.MongoRuntimeError("Unable to parse " + escapedHost + " with URL");
            runtimeError.cause = urlError;
            throw runtimeError;
        }
        var hostname = url.hostname;
        var port = url.port;
        var normalized = decodeURIComponent(hostname).toLowerCase();
        if (normalized.startsWith('[') && normalized.endsWith(']')) {
            this.isIPv6 = true;
            normalized = normalized.substring(1, hostname.length - 1);
        }
        this.host = normalized.toLowerCase();
        if (typeof port === 'number') {
            this.port = port;
        }
        else if (typeof port === 'string' && port !== '') {
            this.port = Number.parseInt(port, 10);
        }
        else {
            this.port = 27017;
        }
        if (this.port === 0) {
            throw new error_1.MongoParseError('Invalid port (zero) with hostname');
        }
        Object.freeze(this);
    }
    HostAddress.prototype[Symbol["for"]('nodejs.util.inspect.custom')] = function () {
        return this.inspect();
    };
    HostAddress.prototype.inspect = function () {
        return "new HostAddress('" + this.toString() + "')";
    };
    HostAddress.prototype.toString = function () {
        if (typeof this.host === 'string') {
            if (this.isIPv6) {
                return "[" + this.host + "]:" + this.port;
            }
            return this.host + ":" + this.port;
        }
        return "" + this.socketPath;
    };
    HostAddress.fromString = function (s) {
        return new HostAddress(s);
    };
    HostAddress.fromHostPort = function (host, port) {
        if (host.includes(':')) {
            host = "[" + host + "]"; // IPv6 address
        }
        return HostAddress.fromString(host + ":" + port);
    };
    HostAddress.fromSrvRecord = function (_a) {
        var name = _a.name, port = _a.port;
        return HostAddress.fromHostPort(name, port);
    };
    HostAddress.prototype.toHostPort = function () {
        var _a, _b;
        if (this.socketPath) {
            return { host: this.socketPath, port: 0 };
        }
        var host = (_a = this.host) !== null && _a !== void 0 ? _a : '';
        var port = (_b = this.port) !== null && _b !== void 0 ? _b : 0;
        return { host: host, port: port };
    };
    return HostAddress;
}());
exports.HostAddress = HostAddress;
exports.DEFAULT_PK_FACTORY = {
    // We prefer not to rely on ObjectId having a createPk method
    createPk: function () {
        return new bson_1.ObjectId();
    }
};
/**
 * When the driver used emitWarning the code will be equal to this.
 * @public
 *
 * @example
 * ```ts
 * process.on('warning', (warning) => {
 *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')
 * })
 * ```
 */
exports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';
/** @internal */
function emitWarning(message) {
    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
}
exports.emitWarning = emitWarning;
var emittedWarnings = new Set();
/**
 * Will emit a warning once for the duration of the application.
 * Uses the message to identify if it has already been emitted
 * so using string interpolation can cause multiple emits
 * @internal
 */
function emitWarningOnce(message) {
    if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
    }
}
exports.emitWarningOnce = emitWarningOnce;
/**
 * Takes a JS object and joins the values into a string separated by ', '
 */
function enumToString(en) {
    return Object.values(en).join(', ');
}
exports.enumToString = enumToString;
/**
 * Determine if a server supports retryable writes.
 *
 * @internal
 */
function supportsRetryableWrites(server) {
    if (!server) {
        return false;
    }
    if (server.loadBalanced) {
        // Loadbalanced topologies will always support retry writes
        return true;
    }
    if (server.description.logicalSessionTimeoutMinutes != null) {
        // that supports sessions
        if (server.description.type !== common_1.ServerType.Standalone) {
            // and that is not a standalone
            return true;
        }
    }
    return false;
}
exports.supportsRetryableWrites = supportsRetryableWrites;
/**
 * Fisherâ€“Yates Shuffle
 *
 * Reference: https://bost.ocks.org/mike/shuffle/
 * @param sequence - items to be shuffled
 * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.
 */
function shuffle(sequence, limit) {
    if (limit === void 0) { limit = 0; }
    var items = Array.from(sequence); // shallow copy in order to never shuffle the input
    if (limit > items.length) {
        throw new error_1.MongoRuntimeError('Limit must be less than the number of items');
    }
    var remainingItemsToShuffle = items.length;
    var lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
    while (remainingItemsToShuffle > lowerBound) {
        // Pick a remaining element
        var randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
        remainingItemsToShuffle -= 1;
        // And swap it with the current element
        var swapHold = items[remainingItemsToShuffle];
        items[remainingItemsToShuffle] = items[randomIndex];
        items[randomIndex] = swapHold;
    }
    return limit % items.length === 0 ? items : items.slice(lowerBound);
}
exports.shuffle = shuffle;
// TODO(NODE-4936): read concern eligibility for commands should be codified in command construction
// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern
function commandSupportsReadConcern(command) {
    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
        return true;
    }
    return false;
}
exports.commandSupportsReadConcern = commandSupportsReadConcern;
/**
 * Compare objectIds. `null` is always less
 * - `+1 = oid1 is greater than oid2`
 * - `-1 = oid1 is less than oid2`
 * - `+0 = oid1 is equal oid2`
 */
function compareObjectId(oid1, oid2) {
    if (oid1 == null && oid2 == null) {
        return 0;
    }
    if (oid1 == null) {
        return -1;
    }
    if (oid2 == null) {
        return 1;
    }
    return exports.ByteUtils.compare(oid1.id, oid2.id);
}
exports.compareObjectId = compareObjectId;
function parseInteger(value) {
    if (typeof value === 'number')
        return Math.trunc(value);
    var parsedValue = Number.parseInt(String(value), 10);
    return Number.isNaN(parsedValue) ? null : parsedValue;
}
exports.parseInteger = parseInteger;
function parseUnsignedInteger(value) {
    var parsedInt = parseInteger(value);
    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
}
exports.parseUnsignedInteger = parseUnsignedInteger;
/**
 * This function throws a MongoAPIError in the event that either of the following is true:
 * * If the provided address domain does not match the provided parent domain
 * * If the parent domain contains less than three `.` separated parts and the provided address does not contain at least one more domain level than its parent
 *
 * If a DNS server were to become compromised SRV records would still need to
 * advertise addresses that are under the same domain as the srvHost.
 *
 * @param address - The address to check against a domain
 * @param srvHost - The domain to check the provided address against
 * @returns void
 */
function checkParentDomainMatch(address, srvHost) {
    // Remove trailing dot if exists on either the resolved address or the srv hostname
    var normalizedAddress = address.endsWith('.') ? address.slice(0, address.length - 1) : address;
    var normalizedSrvHost = srvHost.endsWith('.') ? srvHost.slice(0, srvHost.length - 1) : srvHost;
    var allCharacterBeforeFirstDot = /^.*?\./;
    var srvIsLessThanThreeParts = normalizedSrvHost.split('.').length < 3;
    // Remove all characters before first dot
    // Add leading dot back to string so
    //   an srvHostDomain = '.trusted.site'
    //   will not satisfy an addressDomain that endsWith '.fake-trusted.site'
    var addressDomain = "." + normalizedAddress.replace(allCharacterBeforeFirstDot, '');
    var srvHostDomain = srvIsLessThanThreeParts
        ? normalizedSrvHost
        : "." + normalizedSrvHost.replace(allCharacterBeforeFirstDot, '');
    if (!srvHostDomain.startsWith('.')) {
        srvHostDomain = '.' + srvHostDomain;
    }
    if (srvIsLessThanThreeParts &&
        normalizedAddress.split('.').length <= normalizedSrvHost.split('.').length) {
        throw new error_1.MongoAPIError('Server record does not have at least one more domain level than parent URI');
    }
    if (!addressDomain.endsWith(srvHostDomain)) {
        throw new error_1.MongoAPIError('Server record does not share hostname with parent URI');
    }
}
exports.checkParentDomainMatch = checkParentDomainMatch;
/**
 * Perform a get request that returns status and body.
 * @internal
 */
function get(url, options) {
    if (options === void 0) { options = {}; }
    return new Promise(function (resolve, reject) {
        /* eslint-disable prefer-const */
        var timeoutId;
        var request = http
            .get(url, options, function (response) {
            response.setEncoding('utf8');
            var body = '';
            response.on('data', function (chunk) { return (body += chunk); });
            response.on('end', function () {
                timers_1.clearTimeout(timeoutId);
                resolve({ status: response.statusCode, body: body });
            });
        })
            .on('error', function (error) {
            timers_1.clearTimeout(timeoutId);
            reject(error);
        })
            .end();
        timeoutId = timers_1.setTimeout(function () {
            request.destroy(new error_1.MongoNetworkTimeoutError("request timed out after 10 seconds"));
        }, 10000);
    });
}
exports.get = get;
function request(uri, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, Promise, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                        var requestOptions = __assign(__assign({ method: 'GET', timeout: 10000, json: true }, url.parse(uri)), options);
                        var req = http.request(requestOptions, function (res) {
                            res.setEncoding('utf8');
                            var data = '';
                            res.on('data', function (d) {
                                data += d;
                            });
                            res.once('end', function () {
                                if (options.json === false) {
                                    resolve(data);
                                    return;
                                }
                                try {
                                    var parsed = JSON.parse(data);
                                    resolve(parsed);
                                }
                                catch (_a) {
                                    // TODO(NODE-3483)
                                    reject(new error_1.MongoRuntimeError("Invalid JSON response: \"" + data + "\""));
                                }
                            });
                        });
                        req.once('timeout', function () {
                            return req.destroy(new error_1.MongoNetworkTimeoutError("Network request to " + uri + " timed out after " + options.timeout + " ms"));
                        });
                        req.once('error', function (error) { return reject(error); });
                        req.end();
                    })];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.request = request;
/** @internal */
exports.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
/** @internal */
exports.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
/** @internal */
exports.DOCUMENT_DB_MSG = 'You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb';
/** @internal */
exports.COSMOS_DB_MSG = 'You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb';
/** @internal */
function isHostMatch(match, host) {
    return host && match.test(host.toLowerCase()) ? true : false;
}
exports.isHostMatch = isHostMatch;
function promiseWithResolvers() {
    var resolve;
    var reject;
    var promise = new Promise(function withResolversExecutor(promiseResolve, promiseReject) {
        resolve = promiseResolve;
        reject = promiseReject;
    });
    return { promise: promise, resolve: resolve, reject: reject };
}
exports.promiseWithResolvers = promiseWithResolvers;
/**
 * A noop function intended for use in preventing unhandled rejections.
 *
 * @example
 * ```js
 * const promise = myAsyncTask();
 * // eslint-disable-next-line github/no-then
 * promise.then(undefined, squashError);
 * ```
 */
function squashError(_error) {
    return;
}
exports.squashError = squashError;
exports.randomBytes = util_1.promisify(crypto.randomBytes);
/**
 * Replicates the events.once helper.
 *
 * Removes unused signal logic and It **only** supports 0 or 1 argument events.
 *
 * @param ee - An event emitter that may emit `ev`
 * @param name - An event name to wait for
 */
function once(ee, name) {
    return __awaiter(this, void 0, Promise, function () {
        var _a, promise, resolve, reject, onEvent, onError, res, error_2;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = promiseWithResolvers(), promise = _a.promise, resolve = _a.resolve, reject = _a.reject;
                    onEvent = function (data) { return resolve(data); };
                    onError = function (error) { return reject(error); };
                    ee.once(name, onEvent).once('error', onError);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, promise];
                case 2:
                    res = _b.sent();
                    ee.off('error', onError);
                    return [2 /*return*/, res];
                case 3:
                    error_2 = _b.sent();
                    ee.off(name, onEvent);
                    throw error_2;
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.once = once;
function maybeAddIdToDocuments(coll, docOrDocs, options) {
    var _a;
    var forceServerObjectId = typeof options.forceServerObjectId === 'boolean'
        ? options.forceServerObjectId
        : (_a = coll.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId;
    // no need to modify the docs if server sets the ObjectId
    if (forceServerObjectId === true) {
        return docOrDocs;
    }
    var transform = function (doc) {
        if (doc._id == null) {
            doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
    };
    return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);
}
exports.maybeAddIdToDocuments = maybeAddIdToDocuments;
function fileIsAccessible(fileName, mode) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fs_1.promises.access(fileName, mode)];
                case 1:
                    _b.sent();
                    return [2 /*return*/, true];
                case 2:
                    _a = _b.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.fileIsAccessible = fileIsAccessible;
function noop() {
    return;
}
exports.noop = noop;
/**
 * Recurse through the (identically-shaped) `decrypted` and `original`
 * objects and attach a `decryptedKeys` property on each sub-object that
 * contained encrypted fields. Because we only call this on BSON responses,
 * we do not need to worry about circular references.
 *
 * @internal
 */
function decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall) {
    if (isTopLevelDecorateCall === void 0) { isTopLevelDecorateCall = true; }
    if (isTopLevelDecorateCall) {
        // The original value could have been either a JS object or a BSON buffer
        if (Buffer.isBuffer(original)) {
            original = bson_1.deserialize(original);
        }
        if (Buffer.isBuffer(decrypted)) {
            throw new error_1.MongoRuntimeError('Expected result of decryption to be deserialized BSON object');
        }
    }
    if (!decrypted || typeof decrypted !== 'object')
        return;
    for (var _i = 0, _a = Object.keys(decrypted); _i < _a.length; _i++) {
        var k = _a[_i];
        var originalValue = original[k];
        // An object was decrypted by libmongocrypt if and only if it was
        // a BSON Binary object with subtype 6.
        if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {
            if (!decrypted[constants_2.kDecoratedKeys]) {
                Object.defineProperty(decrypted, constants_2.kDecoratedKeys, {
                    value: [],
                    configurable: true,
                    enumerable: false,
                    writable: false
                });
            }
            // this is defined in the preceding if-statement
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            decrypted[constants_2.kDecoratedKeys].push(k);
            // Do not recurse into this decrypted value. It could be a sub-document/array,
            // in which case there is no original value associated with its subfields.
            continue;
        }
        decorateDecryptionResult(decrypted[k], originalValue, false);
    }
}
exports.decorateDecryptionResult = decorateDecryptionResult;
