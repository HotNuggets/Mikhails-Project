"use strict";
var _a;
exports.__esModule = true;
exports.isTransactionCommand = exports.Transaction = exports.TxnState = void 0;
var error_1 = require("./error");
var read_concern_1 = require("./read_concern");
var read_preference_1 = require("./read_preference");
var write_concern_1 = require("./write_concern");
/** @internal */
exports.TxnState = Object.freeze({
    NO_TRANSACTION: 'NO_TRANSACTION',
    STARTING_TRANSACTION: 'STARTING_TRANSACTION',
    TRANSACTION_IN_PROGRESS: 'TRANSACTION_IN_PROGRESS',
    TRANSACTION_COMMITTED: 'TRANSACTION_COMMITTED',
    TRANSACTION_COMMITTED_EMPTY: 'TRANSACTION_COMMITTED_EMPTY',
    TRANSACTION_ABORTED: 'TRANSACTION_ABORTED'
});
var stateMachine = (_a = {},
    _a[exports.TxnState.NO_TRANSACTION] = [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
    _a[exports.TxnState.STARTING_TRANSACTION] = [
        exports.TxnState.TRANSACTION_IN_PROGRESS,
        exports.TxnState.TRANSACTION_COMMITTED,
        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports.TxnState.TRANSACTION_ABORTED
    ],
    _a[exports.TxnState.TRANSACTION_IN_PROGRESS] = [
        exports.TxnState.TRANSACTION_IN_PROGRESS,
        exports.TxnState.TRANSACTION_COMMITTED,
        exports.TxnState.TRANSACTION_ABORTED
    ],
    _a[exports.TxnState.TRANSACTION_COMMITTED] = [
        exports.TxnState.TRANSACTION_COMMITTED,
        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports.TxnState.STARTING_TRANSACTION,
        exports.TxnState.NO_TRANSACTION
    ],
    _a[exports.TxnState.TRANSACTION_ABORTED] = [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
    _a[exports.TxnState.TRANSACTION_COMMITTED_EMPTY] = [
        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports.TxnState.NO_TRANSACTION
    ],
    _a);
var ACTIVE_STATES = new Set([
    exports.TxnState.STARTING_TRANSACTION,
    exports.TxnState.TRANSACTION_IN_PROGRESS
]);
var COMMITTED_STATES = new Set([
    exports.TxnState.TRANSACTION_COMMITTED,
    exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
    exports.TxnState.TRANSACTION_ABORTED
]);
/**
 * @public
 * A class maintaining state related to a server transaction. Internal Only
 */
var Transaction = /** @class */ (function () {
    /** Create a transaction @internal */
    function Transaction(options) {
        options = options !== null && options !== void 0 ? options : {};
        this.state = exports.TxnState.NO_TRANSACTION;
        this.options = {};
        var writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (writeConcern) {
            if (writeConcern.w === 0) {
                throw new error_1.MongoTransactionError('Transactions do not support unacknowledged write concern');
            }
            this.options.writeConcern = writeConcern;
        }
        if (options.readConcern) {
            this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        }
        if (options.readPreference) {
            this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
        }
        if (options.maxCommitTimeMS) {
            this.options.maxTimeMS = options.maxCommitTimeMS;
        }
        // TODO: This isn't technically necessary
        this._pinnedServer = undefined;
        this._recoveryToken = undefined;
    }
    Object.defineProperty(Transaction.prototype, "server", {
        /** @internal */
        get: function () {
            return this._pinnedServer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "recoveryToken", {
        get: function () {
            return this._recoveryToken;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "isPinned", {
        get: function () {
            return !!this.server;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "isStarting", {
        /** @returns Whether the transaction has started */
        get: function () {
            return this.state === exports.TxnState.STARTING_TRANSACTION;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "isActive", {
        /**
         * @returns Whether this session is presently in a transaction
         */
        get: function () {
            return ACTIVE_STATES.has(this.state);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "isCommitted", {
        get: function () {
            return COMMITTED_STATES.has(this.state);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Transition the transaction in the state machine
     * @internal
     * @param nextState - The new state to transition to
     */
    Transaction.prototype.transition = function (nextState) {
        var nextStates = stateMachine[this.state];
        if (nextStates && nextStates.includes(nextState)) {
            this.state = nextState;
            if (this.state === exports.TxnState.NO_TRANSACTION ||
                this.state === exports.TxnState.STARTING_TRANSACTION ||
                this.state === exports.TxnState.TRANSACTION_ABORTED) {
                this.unpinServer();
            }
            return;
        }
        throw new error_1.MongoRuntimeError("Attempted illegal state transition from [" + this.state + "] to [" + nextState + "]");
    };
    /** @internal */
    Transaction.prototype.pinServer = function (server) {
        if (this.isActive) {
            this._pinnedServer = server;
        }
    };
    /** @internal */
    Transaction.prototype.unpinServer = function () {
        this._pinnedServer = undefined;
    };
    return Transaction;
}());
exports.Transaction = Transaction;
function isTransactionCommand(command) {
    return !!(command.commitTransaction || command.abortTransaction);
}
exports.isTransactionCommand = isTransactionCommand;
