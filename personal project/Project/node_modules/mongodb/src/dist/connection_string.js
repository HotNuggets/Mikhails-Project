"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.FEATURE_FLAGS = exports.DEFAULT_OPTIONS = exports.OPTIONS = exports.parseOptions = exports.resolveSRVRecord = void 0;
var dns = require("dns");
var mongodb_connection_string_url_1 = require("mongodb-connection-string-url");
var url_1 = require("url");
var mongo_credentials_1 = require("./cmap/auth/mongo_credentials");
var providers_1 = require("./cmap/auth/providers");
var client_metadata_1 = require("./cmap/handshake/client_metadata");
var compression_1 = require("./cmap/wire_protocol/compression");
var encrypter_1 = require("./encrypter");
var error_1 = require("./error");
var mongo_client_1 = require("./mongo_client");
var mongo_logger_1 = require("./mongo_logger");
var read_concern_1 = require("./read_concern");
var read_preference_1 = require("./read_preference");
var monitor_1 = require("./sdam/monitor");
var utils_1 = require("./utils");
var write_concern_1 = require("./write_concern");
var VALID_TXT_RECORDS = ['authSource', 'replicaSet', 'loadBalanced'];
var LB_SINGLE_HOST_ERROR = 'loadBalanced option only supported with a single host in the URI';
var LB_REPLICA_SET_ERROR = 'loadBalanced option not supported with a replicaSet option';
var LB_DIRECT_CONNECTION_ERROR = 'loadBalanced option not supported when directConnection is provided';
/**
 * Lookup a `mongodb+srv` connection string, combine the parts and reparse it as a normal
 * connection string.
 *
 * @param uri - The connection string to parse
 * @param options - Optional user provided connection string options
 */
function resolveSRVRecord(options) {
    var _a, _b, _c;
    return __awaiter(this, void 0, Promise, function () {
        var lookupAddress, txtResolutionPromise, addresses, _i, addresses_1, name, hostAddresses, record, error_2, txtRecordOptions, txtRecordOptionKeys, source, replicaSet, loadBalanced;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (typeof options.srvHost !== 'string') {
                        throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
                    }
                    lookupAddress = options.srvHost;
                    txtResolutionPromise = dns.promises.resolveTxt(lookupAddress);
                    txtResolutionPromise.then(undefined, utils_1.squashError); // rejections will be handled later
                    return [4 /*yield*/, dns.promises.resolveSrv("_" + options.srvServiceName + "._tcp." + lookupAddress)];
                case 1:
                    addresses = _d.sent();
                    if (addresses.length === 0) {
                        throw new error_1.MongoAPIError('No addresses found at host');
                    }
                    for (_i = 0, addresses_1 = addresses; _i < addresses_1.length; _i++) {
                        name = addresses_1[_i].name;
                        utils_1.checkParentDomainMatch(name, lookupAddress);
                    }
                    hostAddresses = addresses.map(function (r) { var _a; return utils_1.HostAddress.fromString(r.name + ":" + ((_a = r.port) !== null && _a !== void 0 ? _a : 27017)); });
                    validateLoadBalancedOptions(hostAddresses, options, true);
                    _d.label = 2;
                case 2:
                    _d.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, txtResolutionPromise];
                case 3:
                    record = _d.sent();
                    return [3 /*break*/, 5];
                case 4:
                    error_2 = _d.sent();
                    if (error_2.code !== 'ENODATA' && error_2.code !== 'ENOTFOUND') {
                        throw error_2;
                    }
                    return [2 /*return*/, hostAddresses];
                case 5:
                    if (record.length > 1) {
                        throw new error_1.MongoParseError('Multiple text records not allowed');
                    }
                    txtRecordOptions = new url_1.URLSearchParams(record[0].join(''));
                    txtRecordOptionKeys = __spreadArrays(txtRecordOptions.keys());
                    if (txtRecordOptionKeys.some(function (key) { return !VALID_TXT_RECORDS.includes(key); })) {
                        throw new error_1.MongoParseError("Text record may only set any of: " + VALID_TXT_RECORDS.join(', '));
                    }
                    if (VALID_TXT_RECORDS.some(function (option) { return txtRecordOptions.get(option) === ''; })) {
                        throw new error_1.MongoParseError('Cannot have empty URI params in DNS TXT Record');
                    }
                    source = (_a = txtRecordOptions.get('authSource')) !== null && _a !== void 0 ? _a : undefined;
                    replicaSet = (_b = txtRecordOptions.get('replicaSet')) !== null && _b !== void 0 ? _b : undefined;
                    loadBalanced = (_c = txtRecordOptions.get('loadBalanced')) !== null && _c !== void 0 ? _c : undefined;
                    if (!options.userSpecifiedAuthSource &&
                        source &&
                        options.credentials &&
                        !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
                        options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source: source });
                    }
                    if (!options.userSpecifiedReplicaSet && replicaSet) {
                        options.replicaSet = replicaSet;
                    }
                    if (loadBalanced === 'true') {
                        options.loadBalanced = true;
                    }
                    if (options.replicaSet && options.srvMaxHosts > 0) {
                        throw new error_1.MongoParseError('Cannot combine replicaSet option with srvMaxHosts');
                    }
                    validateLoadBalancedOptions(hostAddresses, options, true);
                    return [2 /*return*/, hostAddresses];
            }
        });
    });
}
exports.resolveSRVRecord = resolveSRVRecord;
/**
 * Checks if TLS options are valid
 *
 * @param allOptions - All options provided by user or included in default options map
 * @throws MongoAPIError if TLS options are invalid
 */
function checkTLSOptions(allOptions) {
    if (!allOptions)
        return;
    var check = function (a, b) {
        if (allOptions.has(a) && allOptions.has(b)) {
            throw new error_1.MongoAPIError("The '" + a + "' option cannot be used with the '" + b + "' option");
        }
    };
    check('tlsInsecure', 'tlsAllowInvalidCertificates');
    check('tlsInsecure', 'tlsAllowInvalidHostnames');
    check('tlsInsecure', 'tlsDisableCertificateRevocationCheck');
    check('tlsInsecure', 'tlsDisableOCSPEndpointCheck');
    check('tlsAllowInvalidCertificates', 'tlsDisableCertificateRevocationCheck');
    check('tlsAllowInvalidCertificates', 'tlsDisableOCSPEndpointCheck');
    check('tlsDisableCertificateRevocationCheck', 'tlsDisableOCSPEndpointCheck');
}
function getBoolean(name, value) {
    if (typeof value === 'boolean')
        return value;
    switch (value) {
        case 'true':
            return true;
        case 'false':
            return false;
        default:
            throw new error_1.MongoParseError(name + " must be either \"true\" or \"false\"");
    }
}
function getIntFromOptions(name, value) {
    var parsedInt = utils_1.parseInteger(value);
    if (parsedInt != null) {
        return parsedInt;
    }
    throw new error_1.MongoParseError("Expected " + name + " to be stringified int value, got: " + value);
}
function getUIntFromOptions(name, value) {
    var parsedValue = getIntFromOptions(name, value);
    if (parsedValue < 0) {
        throw new error_1.MongoParseError(name + " can only be a positive int value, got: " + value);
    }
    return parsedValue;
}
function entriesFromString(value) {
    var keyValuePairs, _i, keyValuePairs_1, keyValue, _a, key, value_1;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (value === '') {
                    return [2 /*return*/];
                }
                keyValuePairs = value.split(',');
                _i = 0, keyValuePairs_1 = keyValuePairs;
                _b.label = 1;
            case 1:
                if (!(_i < keyValuePairs_1.length)) return [3 /*break*/, 4];
                keyValue = keyValuePairs_1[_i];
                _a = keyValue.split(/:(.*)/), key = _a[0], value_1 = _a[1];
                if (value_1 == null) {
                    throw new error_1.MongoParseError('Cannot have undefined values in key value pairs');
                }
                return [4 /*yield*/, [key, value_1]];
            case 2:
                _b.sent();
                _b.label = 3;
            case 3:
                _i++;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/];
        }
    });
}
var CaseInsensitiveMap = /** @class */ (function (_super) {
    __extends(CaseInsensitiveMap, _super);
    function CaseInsensitiveMap(entries) {
        if (entries === void 0) { entries = []; }
        return _super.call(this, entries.map(function (_a) {
            var k = _a[0], v = _a[1];
            return [k.toLowerCase(), v];
        })) || this;
    }
    CaseInsensitiveMap.prototype.has = function (k) {
        return _super.prototype.has.call(this, k.toLowerCase());
    };
    CaseInsensitiveMap.prototype.get = function (k) {
        return _super.prototype.get.call(this, k.toLowerCase());
    };
    CaseInsensitiveMap.prototype.set = function (k, v) {
        return _super.prototype.set.call(this, k.toLowerCase(), v);
    };
    CaseInsensitiveMap.prototype["delete"] = function (k) {
        return _super.prototype["delete"].call(this, k.toLowerCase());
    };
    return CaseInsensitiveMap;
}(Map));
function parseOptions(uri, mongoClient, options) {
    var _a, _b;
    if (mongoClient === void 0) { mongoClient = undefined; }
    if (options === void 0) { options = {}; }
    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
        options = mongoClient;
        mongoClient = undefined;
    }
    // validate BSONOptions
    if (options.useBigInt64 && typeof options.promoteLongs === 'boolean' && !options.promoteLongs) {
        throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
    }
    if (options.useBigInt64 && typeof options.promoteValues === 'boolean' && !options.promoteValues) {
        throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
    }
    var url = new mongodb_connection_string_url_1["default"](uri);
    var hosts = url.hosts, isSRV = url.isSRV;
    var mongoOptions = Object.create(null);
    // Feature flags
    for (var _i = 0, _c = Object.getOwnPropertySymbols(options); _i < _c.length; _i++) {
        var flag = _c[_i];
        if (exports.FEATURE_FLAGS.has(flag)) {
            mongoOptions[flag] = options[flag];
        }
    }
    mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
    var urlOptions = new CaseInsensitiveMap();
    if (url.pathname !== '/' && url.pathname !== '') {
        var dbName = decodeURIComponent(url.pathname[0] === '/' ? url.pathname.slice(1) : url.pathname);
        if (dbName) {
            urlOptions.set('dbName', [dbName]);
        }
    }
    if (url.username !== '') {
        var auth = {
            username: decodeURIComponent(url.username)
        };
        if (typeof url.password === 'string') {
            auth.password = decodeURIComponent(url.password);
        }
        urlOptions.set('auth', [auth]);
    }
    for (var _d = 0, _e = url.searchParams.keys(); _d < _e.length; _d++) {
        var key = _e[_d];
        var values = url.searchParams.getAll(key);
        var isReadPreferenceTags = /readPreferenceTags/i.test(key);
        if (!isReadPreferenceTags && values.length > 1) {
            throw new error_1.MongoInvalidArgumentError("URI option \"" + key + "\" cannot appear more than once in the connection string");
        }
        if (!isReadPreferenceTags && values.includes('')) {
            throw new error_1.MongoAPIError("URI option \"" + key + "\" cannot be specified with no value");
        }
        if (!urlOptions.has(key)) {
            urlOptions.set(key, values);
        }
    }
    var objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(function (_a) {
        var v = _a[1];
        return v != null;
    }));
    // Validate options that can only be provided by one of uri or object
    if (urlOptions.has('serverApi')) {
        throw new error_1.MongoParseError('URI cannot contain `serverApi`, it can only be passed to the client');
    }
    var uriMechanismProperties = urlOptions.get('authMechanismProperties');
    if (uriMechanismProperties) {
        for (var _f = 0, uriMechanismProperties_1 = uriMechanismProperties; _f < uriMechanismProperties_1.length; _f++) {
            var property = uriMechanismProperties_1[_f];
            if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
                throw new error_1.MongoParseError('Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.');
            }
        }
    }
    if (objectOptions.has('loadBalanced')) {
        throw new error_1.MongoParseError('loadBalanced is only a valid option in the URI');
    }
    // All option collection
    var allProvidedOptions = new CaseInsensitiveMap();
    var allProvidedKeys = new Set(__spreadArrays(urlOptions.keys(), objectOptions.keys()));
    for (var _g = 0, allProvidedKeys_1 = allProvidedKeys; _g < allProvidedKeys_1.length; _g++) {
        var key = allProvidedKeys_1[_g];
        var values = [];
        var objectOptionValue = objectOptions.get(key);
        if (objectOptionValue != null) {
            values.push(objectOptionValue);
        }
        var urlValues = (_a = urlOptions.get(key)) !== null && _a !== void 0 ? _a : [];
        values.push.apply(values, urlValues);
        allProvidedOptions.set(key, values);
    }
    if (allProvidedOptions.has('tls') || allProvidedOptions.has('ssl')) {
        var tlsAndSslOpts = (allProvidedOptions.get('tls') || [])
            .concat(allProvidedOptions.get('ssl') || [])
            .map(getBoolean.bind(null, 'tls/ssl'));
        if (new Set(tlsAndSslOpts).size !== 1) {
            throw new error_1.MongoParseError('All values of tls/ssl must be the same.');
        }
    }
    checkTLSOptions(allProvidedOptions);
    var unsupportedOptions = utils_1.setDifference(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map(function (s) { return s.toLowerCase(); }));
    if (unsupportedOptions.size !== 0) {
        var optionWord = unsupportedOptions.size > 1 ? 'options' : 'option';
        var isOrAre = unsupportedOptions.size > 1 ? 'are' : 'is';
        throw new error_1.MongoParseError(optionWord + " " + Array.from(unsupportedOptions).join(', ') + " " + isOrAre + " not supported");
    }
    // Option parsing and setting
    for (var _h = 0, _j = Object.entries(exports.OPTIONS); _h < _j.length; _h++) {
        var _k = _j[_h], key = _k[0], descriptor = _k[1];
        var values = allProvidedOptions.get(key);
        if (!values || values.length === 0) {
            if (exports.DEFAULT_OPTIONS.has(key)) {
                setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
            }
        }
        else {
            var deprecated = descriptor.deprecated;
            if (deprecated) {
                var deprecatedMsg = typeof deprecated === 'string' ? ": " + deprecated : '';
                utils_1.emitWarning(key + " is a deprecated option" + deprecatedMsg);
            }
            setOption(mongoOptions, key, descriptor, values);
        }
    }
    if (mongoOptions.credentials) {
        var isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
        var isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
        var isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
        var isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
        if ((isGssapi || isX509) &&
            allProvidedOptions.has('authSource') &&
            mongoOptions.credentials.source !== '$external') {
            // If authSource was explicitly given and its incorrect, we error
            throw new error_1.MongoParseError("authMechanism " + mongoOptions.credentials.mechanism + " requires an authSource of '$external'");
        }
        if (!(isGssapi || isX509 || isAws || isOidc) &&
            mongoOptions.dbName &&
            !allProvidedOptions.has('authSource')) {
            // inherit the dbName unless GSSAPI or X509, then silently ignore dbName
            // and there was no specific authSource given
            mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
                source: mongoOptions.dbName
            });
        }
        if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
            throw new error_1.MongoMissingCredentialsError("When using " + mongoOptions.credentials.mechanism + " password must be set when a username is specified");
        }
        mongoOptions.credentials.validate();
        // Check if the only auth related option provided was authSource, if so we can remove credentials
        if (mongoOptions.credentials.password === '' &&
            mongoOptions.credentials.username === '' &&
            mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT &&
            Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
            delete mongoOptions.credentials;
        }
    }
    if (!mongoOptions.dbName) {
        // dbName default is applied here because of the credential validation above
        mongoOptions.dbName = 'test';
    }
    validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
    if (mongoClient && mongoOptions.autoEncryption) {
        encrypter_1.Encrypter.checkForMongoCrypt();
        mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
        mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
    }
    // Potential SRV Overrides and SRV connection string validations
    mongoOptions.userSpecifiedAuthSource =
        objectOptions.has('authSource') || urlOptions.has('authSource');
    mongoOptions.userSpecifiedReplicaSet =
        objectOptions.has('replicaSet') || urlOptions.has('replicaSet');
    if (isSRV) {
        // SRV Record is resolved upon connecting
        mongoOptions.srvHost = hosts[0];
        if (mongoOptions.directConnection) {
            throw new error_1.MongoAPIError('SRV URI does not support directConnection');
        }
        if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === 'string') {
            throw new error_1.MongoParseError('Cannot use srvMaxHosts option with replicaSet');
        }
        // SRV turns on TLS by default, but users can override and turn it off
        var noUserSpecifiedTLS = !objectOptions.has('tls') && !urlOptions.has('tls');
        var noUserSpecifiedSSL = !objectOptions.has('ssl') && !urlOptions.has('ssl');
        if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
            mongoOptions.tls = true;
        }
    }
    else {
        var userSpecifiedSrvOptions = urlOptions.has('srvMaxHosts') ||
            objectOptions.has('srvMaxHosts') ||
            urlOptions.has('srvServiceName') ||
            objectOptions.has('srvServiceName');
        if (userSpecifiedSrvOptions) {
            throw new error_1.MongoParseError('Cannot use srvMaxHosts or srvServiceName with a non-srv connection string');
        }
    }
    if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
        throw new error_1.MongoParseError('directConnection option requires exactly one host');
    }
    if (!mongoOptions.proxyHost &&
        (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
        throw new error_1.MongoParseError('Must specify proxyHost if other proxy options are passed');
    }
    if ((mongoOptions.proxyUsername && !mongoOptions.proxyPassword) ||
        (!mongoOptions.proxyUsername && mongoOptions.proxyPassword)) {
        throw new error_1.MongoParseError('Can only specify both of proxy username/password or neither');
    }
    var proxyOptions = ['proxyHost', 'proxyPort', 'proxyUsername', 'proxyPassword'].map(function (key) { var _a; return (_a = urlOptions.get(key)) !== null && _a !== void 0 ? _a : []; });
    if (proxyOptions.some(function (options) { return options.length > 1; })) {
        throw new error_1.MongoParseError('Proxy options cannot be specified multiple times in the connection string');
    }
    var loggerFeatureFlag = Symbol["for"]('@@mdb.enableMongoLogger');
    mongoOptions[loggerFeatureFlag] = (_b = mongoOptions[loggerFeatureFlag]) !== null && _b !== void 0 ? _b : false;
    var loggerEnvOptions = {};
    var loggerClientOptions = {};
    if (mongoOptions[loggerFeatureFlag]) {
        loggerEnvOptions = __assign({ MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND, MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY, MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION, MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION, MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT, MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL, MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH, MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH }, mongoOptions[Symbol["for"]('@@mdb.internalLoggerConfig')]);
        loggerClientOptions = {
            mongodbLogPath: mongoOptions.mongodbLogPath,
            mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
            mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
        };
    }
    mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions(loggerEnvOptions, loggerClientOptions);
    mongoOptions.metadata = client_metadata_1.makeClientMetadata(mongoOptions);
    mongoOptions.extendedMetadata = client_metadata_1.addContainerMetadata(mongoOptions.metadata).then(undefined, utils_1.squashError); // rejections will be handled later
    return mongoOptions;
}
exports.parseOptions = parseOptions;
/**
 * #### Throws if LB mode is true:
 * - hosts contains more than one host
 * - there is a replicaSet name set
 * - directConnection is set
 * - if srvMaxHosts is used when an srv connection string is passed in
 *
 * @throws MongoParseError
 */
function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
    if (mongoOptions.loadBalanced) {
        if (hosts.length > 1) {
            throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
        }
        if (mongoOptions.replicaSet) {
            throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
        }
        if (mongoOptions.directConnection) {
            throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
        }
        if (isSrv && mongoOptions.srvMaxHosts > 0) {
            throw new error_1.MongoParseError('Cannot limit srv hosts with loadBalanced enabled');
        }
    }
    return;
}
function setOption(mongoOptions, key, descriptor, values) {
    var target = descriptor.target, type = descriptor.type, transform = descriptor.transform;
    var name = target !== null && target !== void 0 ? target : key;
    switch (type) {
        case 'boolean':
            mongoOptions[name] = getBoolean(name, values[0]);
            break;
        case 'int':
            mongoOptions[name] = getIntFromOptions(name, values[0]);
            break;
        case 'uint':
            mongoOptions[name] = getUIntFromOptions(name, values[0]);
            break;
        case 'string':
            if (values[0] == null) {
                break;
            }
            mongoOptions[name] = String(values[0]);
            break;
        case 'record':
            if (!utils_1.isRecord(values[0])) {
                throw new error_1.MongoParseError(name + " must be an object");
            }
            mongoOptions[name] = values[0];
            break;
        case 'any':
            mongoOptions[name] = values[0];
            break;
        default: {
            if (!transform) {
                throw new error_1.MongoParseError('Descriptors missing a type must define a transform');
            }
            var transformValue = transform({ name: name, options: mongoOptions, values: values });
            mongoOptions[name] = transformValue;
            break;
        }
    }
}
exports.OPTIONS = {
    appName: {
        type: 'string'
    },
    auth: {
        target: 'credentials',
        transform: function (_a) {
            var name = _a.name, options = _a.options, value = _a.values[0];
            if (!utils_1.isRecord(value, ['username', 'password'])) {
                throw new error_1.MongoParseError(name + " must be an object with 'username' and 'password' properties");
            }
            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
                username: value.username,
                password: value.password
            });
        }
    },
    authMechanism: {
        target: 'credentials',
        transform: function (_a) {
            var _b, _c;
            var options = _a.options, value = _a.values[0];
            var mechanisms = Object.values(providers_1.AuthMechanism);
            var mechanism = mechanisms.filter(function (m) { return m.match(RegExp(String.raw(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\b", "\b"], ["\\b", "\\b"])), value), 'i')); })[0];
            if (!mechanism) {
                throw new error_1.MongoParseError("authMechanism one of " + mechanisms + ", got " + value);
            }
            var source = (_b = options.credentials) === null || _b === void 0 ? void 0 : _b.source;
            if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN ||
                providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
                // some mechanisms have '$external' as the Auth Source
                source = '$external';
            }
            var password = (_c = options.credentials) === null || _c === void 0 ? void 0 : _c.password;
            if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === '') {
                password = undefined;
            }
            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
                mechanism: mechanism,
                source: source,
                password: password
            });
        }
    },
    // Note that if the authMechanismProperties contain a TOKEN_RESOURCE that has a
    // comma in it, it MUST be supplied as a MongoClient option instead of in the
    // connection string.
    authMechanismProperties: {
        target: 'credentials',
        transform: function (_a) {
            var options = _a.options, values = _a.values;
            // We can have a combination of options passed in the URI and options passed
            // as an object to the MongoClient. So we must transform the string options
            // as well as merge them together with a potentially provided object.
            var mechanismProperties = Object.create(null);
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var optionValue = values_1[_i];
                if (typeof optionValue === 'string') {
                    for (var _b = 0, _c = entriesFromString(optionValue); _b < _c.length; _b++) {
                        var _d = _c[_b], key = _d[0], value = _d[1];
                        try {
                            mechanismProperties[key] = getBoolean(key, value);
                        }
                        catch (_e) {
                            mechanismProperties[key] = value;
                        }
                    }
                }
                else {
                    if (!utils_1.isRecord(optionValue)) {
                        throw new error_1.MongoParseError('AuthMechanismProperties must be an object');
                    }
                    mechanismProperties = __assign({}, optionValue);
                }
            }
            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
                mechanismProperties: mechanismProperties
            });
        }
    },
    authSource: {
        target: 'credentials',
        transform: function (_a) {
            var options = _a.options, value = _a.values[0];
            var source = String(value);
            return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source: source });
        }
    },
    autoEncryption: {
        type: 'record'
    },
    autoSelectFamily: {
        type: 'boolean',
        "default": true
    },
    autoSelectFamilyAttemptTimeout: {
        type: 'uint'
    },
    bsonRegExp: {
        type: 'boolean'
    },
    serverApi: {
        target: 'serverApi',
        transform: function (_a) {
            var version = _a.values[0];
            var serverApiToValidate = typeof version === 'string' ? { version: version } : version;
            var versionToValidate = serverApiToValidate && serverApiToValidate.version;
            if (!versionToValidate) {
                throw new error_1.MongoParseError("Invalid `serverApi` property; must specify a version from the following enum: [\"" + Object.values(mongo_client_1.ServerApiVersion).join('", "') + "\"]");
            }
            if (!Object.values(mongo_client_1.ServerApiVersion).some(function (v) { return v === versionToValidate; })) {
                throw new error_1.MongoParseError("Invalid server API version=" + versionToValidate + "; must be in the following enum: [\"" + Object.values(mongo_client_1.ServerApiVersion).join('", "') + "\"]");
            }
            return serverApiToValidate;
        }
    },
    checkKeys: {
        type: 'boolean'
    },
    compressors: {
        "default": 'none',
        target: 'compressors',
        transform: function (_a) {
            var values = _a.values;
            var compressionList = new Set();
            for (var _i = 0, _b = values; _i < _b.length; _i++) {
                var compVal = _b[_i];
                var compValArray = typeof compVal === 'string' ? compVal.split(',') : compVal;
                if (!Array.isArray(compValArray)) {
                    throw new error_1.MongoInvalidArgumentError('compressors must be an array or a comma-delimited list of strings');
                }
                for (var _c = 0, compValArray_1 = compValArray; _c < compValArray_1.length; _c++) {
                    var c = compValArray_1[_c];
                    if (Object.keys(compression_1.Compressor).includes(String(c))) {
                        compressionList.add(String(c));
                    }
                    else {
                        throw new error_1.MongoInvalidArgumentError(c + " is not a valid compression mechanism. Must be one of: " + Object.keys(compression_1.Compressor) + ".");
                    }
                }
            }
            return __spreadArrays(compressionList);
        }
    },
    connectTimeoutMS: {
        "default": 30000,
        type: 'uint'
    },
    dbName: {
        type: 'string'
    },
    directConnection: {
        "default": false,
        type: 'boolean'
    },
    driverInfo: {
        "default": {},
        type: 'record'
    },
    enableUtf8Validation: { type: 'boolean', "default": true },
    family: {
        transform: function (_a) {
            var name = _a.name, value = _a.values[0];
            var transformValue = getIntFromOptions(name, value);
            if (transformValue === 4 || transformValue === 6) {
                return transformValue;
            }
            throw new error_1.MongoParseError("Option 'family' must be 4 or 6 got " + transformValue + ".");
        }
    },
    fieldsAsRaw: {
        type: 'record'
    },
    forceServerObjectId: {
        "default": false,
        type: 'boolean'
    },
    fsync: {
        deprecated: 'Please use journal instead',
        target: 'writeConcern',
        transform: function (_a) {
            var name = _a.name, options = _a.options, value = _a.values[0];
            var wc = write_concern_1.WriteConcern.fromOptions({
                writeConcern: __assign(__assign({}, options.writeConcern), { fsync: getBoolean(name, value) })
            });
            if (!wc)
                throw new error_1.MongoParseError("Unable to make a writeConcern from fsync=" + value);
            return wc;
        }
    },
    heartbeatFrequencyMS: {
        "default": 10000,
        type: 'uint'
    },
    ignoreUndefined: {
        type: 'boolean'
    },
    j: {
        deprecated: 'Please use journal instead',
        target: 'writeConcern',
        transform: function (_a) {
            var name = _a.name, options = _a.options, value = _a.values[0];
            var wc = write_concern_1.WriteConcern.fromOptions({
                writeConcern: __assign(__assign({}, options.writeConcern), { journal: getBoolean(name, value) })
            });
            if (!wc)
                throw new error_1.MongoParseError("Unable to make a writeConcern from journal=" + value);
            return wc;
        }
    },
    journal: {
        target: 'writeConcern',
        transform: function (_a) {
            var name = _a.name, options = _a.options, value = _a.values[0];
            var wc = write_concern_1.WriteConcern.fromOptions({
                writeConcern: __assign(__assign({}, options.writeConcern), { journal: getBoolean(name, value) })
            });
            if (!wc)
                throw new error_1.MongoParseError("Unable to make a writeConcern from journal=" + value);
            return wc;
        }
    },
    loadBalanced: {
        "default": false,
        type: 'boolean'
    },
    localThresholdMS: {
        "default": 15,
        type: 'uint'
    },
    maxConnecting: {
        "default": 2,
        transform: function (_a) {
            var name = _a.name, value = _a.values[0];
            var maxConnecting = getUIntFromOptions(name, value);
            if (maxConnecting === 0) {
                throw new error_1.MongoInvalidArgumentError('maxConnecting must be > 0 if specified');
            }
            return maxConnecting;
        }
    },
    maxIdleTimeMS: {
        "default": 0,
        type: 'uint'
    },
    maxPoolSize: {
        "default": 100,
        type: 'uint'
    },
    maxStalenessSeconds: {
        target: 'readPreference',
        transform: function (_a) {
            var name = _a.name, options = _a.options, value = _a.values[0];
            var maxStalenessSeconds = getUIntFromOptions(name, value);
            if (options.readPreference) {
                return read_preference_1.ReadPreference.fromOptions({
                    readPreference: __assign(__assign({}, options.readPreference), { maxStalenessSeconds: maxStalenessSeconds })
                });
            }
            else {
                return new read_preference_1.ReadPreference('secondary', undefined, { maxStalenessSeconds: maxStalenessSeconds });
            }
        }
    },
    minInternalBufferSize: {
        type: 'uint'
    },
    minPoolSize: {
        "default": 0,
        type: 'uint'
    },
    minHeartbeatFrequencyMS: {
        "default": 500,
        type: 'uint'
    },
    monitorCommands: {
        "default": false,
        type: 'boolean'
    },
    name: {
        target: 'driverInfo',
        transform: function (_a) {
            var value = _a.values[0], options = _a.options;
            return __assign(__assign({}, options.driverInfo), { name: String(value) });
        }
    },
    noDelay: {
        "default": true,
        type: 'boolean'
    },
    pkFactory: {
        "default": utils_1.DEFAULT_PK_FACTORY,
        transform: function (_a) {
            var value = _a.values[0];
            if (utils_1.isRecord(value, ['createPk']) && typeof value.createPk === 'function') {
                return value;
            }
            throw new error_1.MongoParseError("Option pkFactory must be an object with a createPk function, got " + value);
        }
    },
    promoteBuffers: {
        type: 'boolean'
    },
    promoteLongs: {
        type: 'boolean'
    },
    promoteValues: {
        type: 'boolean'
    },
    useBigInt64: {
        type: 'boolean'
    },
    proxyHost: {
        type: 'string'
    },
    proxyPassword: {
        type: 'string'
    },
    proxyPort: {
        type: 'uint'
    },
    proxyUsername: {
        type: 'string'
    },
    raw: {
        "default": false,
        type: 'boolean'
    },
    readConcern: {
        transform: function (_a) {
            var value = _a.values[0], options = _a.options;
            if (value instanceof read_concern_1.ReadConcern || utils_1.isRecord(value, ['level'])) {
                return read_concern_1.ReadConcern.fromOptions(__assign(__assign({}, options.readConcern), value));
            }
            throw new error_1.MongoParseError("ReadConcern must be an object, got " + JSON.stringify(value));
        }
    },
    readConcernLevel: {
        target: 'readConcern',
        transform: function (_a) {
            var level = _a.values[0], options = _a.options;
            return read_concern_1.ReadConcern.fromOptions(__assign(__assign({}, options.readConcern), { level: level }));
        }
    },
    readPreference: {
        "default": read_preference_1.ReadPreference.primary,
        transform: function (_a) {
            var _b, _c, _d;
            var value = _a.values[0], options = _a.options;
            if (value instanceof read_preference_1.ReadPreference) {
                return read_preference_1.ReadPreference.fromOptions(__assign({ readPreference: __assign(__assign({}, options.readPreference), value) }, value));
            }
            if (utils_1.isRecord(value, ['mode'])) {
                var rp = read_preference_1.ReadPreference.fromOptions(__assign({ readPreference: __assign(__assign({}, options.readPreference), value) }, value));
                if (rp)
                    return rp;
                else
                    throw new error_1.MongoParseError("Cannot make read preference from " + JSON.stringify(value));
            }
            if (typeof value === 'string') {
                var rpOpts = {
                    hedge: (_b = options.readPreference) === null || _b === void 0 ? void 0 : _b.hedge,
                    maxStalenessSeconds: (_c = options.readPreference) === null || _c === void 0 ? void 0 : _c.maxStalenessSeconds
                };
                return new read_preference_1.ReadPreference(value, (_d = options.readPreference) === null || _d === void 0 ? void 0 : _d.tags, rpOpts);
            }
            throw new error_1.MongoParseError("Unknown ReadPreference value: " + value);
        }
    },
    readPreferenceTags: {
        target: 'readPreference',
        transform: function (_a) {
            var values = _a.values, options = _a.options;
            var tags = Array.isArray(values[0])
                ? values[0]
                : values;
            var readPreferenceTags = [];
            for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
                var tag = tags_1[_i];
                var readPreferenceTag = Object.create(null);
                if (typeof tag === 'string') {
                    for (var _b = 0, _c = entriesFromString(tag); _b < _c.length; _b++) {
                        var _d = _c[_b], k = _d[0], v = _d[1];
                        readPreferenceTag[k] = v;
                    }
                }
                if (utils_1.isRecord(tag)) {
                    for (var _e = 0, _f = Object.entries(tag); _e < _f.length; _e++) {
                        var _g = _f[_e], k = _g[0], v = _g[1];
                        readPreferenceTag[k] = v;
                    }
                }
                readPreferenceTags.push(readPreferenceTag);
            }
            return read_preference_1.ReadPreference.fromOptions({
                readPreference: options.readPreference,
                readPreferenceTags: readPreferenceTags
            });
        }
    },
    replicaSet: {
        type: 'string'
    },
    retryReads: {
        "default": true,
        type: 'boolean'
    },
    retryWrites: {
        "default": true,
        type: 'boolean'
    },
    serializeFunctions: {
        type: 'boolean'
    },
    serverMonitoringMode: {
        "default": 'auto',
        transform: function (_a) {
            var value = _a.values[0];
            if (!Object.values(monitor_1.ServerMonitoringMode).includes(value)) {
                throw new error_1.MongoParseError('serverMonitoringMode must be one of `auto`, `poll`, or `stream`');
            }
            return value;
        }
    },
    serverSelectionTimeoutMS: {
        "default": 30000,
        type: 'uint'
    },
    servername: {
        type: 'string'
    },
    socketTimeoutMS: {
        "default": 0,
        type: 'uint'
    },
    srvMaxHosts: {
        type: 'uint',
        "default": 0
    },
    srvServiceName: {
        type: 'string',
        "default": 'mongodb'
    },
    ssl: {
        target: 'tls',
        type: 'boolean'
    },
    timeoutMS: {
        type: 'uint'
    },
    tls: {
        type: 'boolean'
    },
    tlsAllowInvalidCertificates: {
        target: 'rejectUnauthorized',
        transform: function (_a) {
            var name = _a.name, value = _a.values[0];
            // allowInvalidCertificates is the inverse of rejectUnauthorized
            return !getBoolean(name, value);
        }
    },
    tlsAllowInvalidHostnames: {
        target: 'checkServerIdentity',
        transform: function (_a) {
            var name = _a.name, value = _a.values[0];
            // tlsAllowInvalidHostnames means setting the checkServerIdentity function to a noop
            return getBoolean(name, value) ? function () { return undefined; } : undefined;
        }
    },
    tlsCAFile: {
        type: 'string'
    },
    tlsCRLFile: {
        type: 'string'
    },
    tlsCertificateKeyFile: {
        type: 'string'
    },
    tlsCertificateKeyFilePassword: {
        target: 'passphrase',
        type: 'any'
    },
    tlsInsecure: {
        transform: function (_a) {
            var name = _a.name, options = _a.options, value = _a.values[0];
            var tlsInsecure = getBoolean(name, value);
            if (tlsInsecure) {
                options.checkServerIdentity = function () { return undefined; };
                options.rejectUnauthorized = false;
            }
            else {
                options.checkServerIdentity = options.tlsAllowInvalidHostnames
                    ? function () { return undefined; }
                    : undefined;
                options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
            }
            return tlsInsecure;
        }
    },
    w: {
        target: 'writeConcern',
        transform: function (_a) {
            var value = _a.values[0], options = _a.options;
            return write_concern_1.WriteConcern.fromOptions({ writeConcern: __assign(__assign({}, options.writeConcern), { w: value }) });
        }
    },
    waitQueueTimeoutMS: {
        "default": 0,
        type: 'uint'
    },
    writeConcern: {
        target: 'writeConcern',
        transform: function (_a) {
            var value = _a.values[0], options = _a.options;
            if (utils_1.isRecord(value) || value instanceof write_concern_1.WriteConcern) {
                return write_concern_1.WriteConcern.fromOptions({
                    writeConcern: __assign(__assign({}, options.writeConcern), value)
                });
            }
            else if (value === 'majority' || typeof value === 'number') {
                return write_concern_1.WriteConcern.fromOptions({
                    writeConcern: __assign(__assign({}, options.writeConcern), { w: value })
                });
            }
            throw new error_1.MongoParseError("Invalid WriteConcern cannot parse: " + JSON.stringify(value));
        }
    },
    wtimeout: {
        deprecated: 'Please use wtimeoutMS instead',
        target: 'writeConcern',
        transform: function (_a) {
            var value = _a.values[0], options = _a.options;
            var wc = write_concern_1.WriteConcern.fromOptions({
                writeConcern: __assign(__assign({}, options.writeConcern), { wtimeout: getUIntFromOptions('wtimeout', value) })
            });
            if (wc)
                return wc;
            throw new error_1.MongoParseError("Cannot make WriteConcern from wtimeout");
        }
    },
    wtimeoutMS: {
        target: 'writeConcern',
        transform: function (_a) {
            var value = _a.values[0], options = _a.options;
            var wc = write_concern_1.WriteConcern.fromOptions({
                writeConcern: __assign(__assign({}, options.writeConcern), { wtimeoutMS: getUIntFromOptions('wtimeoutMS', value) })
            });
            if (wc)
                return wc;
            throw new error_1.MongoParseError("Cannot make WriteConcern from wtimeout");
        }
    },
    zlibCompressionLevel: {
        "default": 0,
        type: 'int'
    },
    // Custom types for modifying core behavior
    connectionType: { type: 'any' },
    srvPoller: { type: 'any' },
    // Accepted Node.js Options
    allowPartialTrustChain: { type: 'any' },
    minDHSize: { type: 'any' },
    pskCallback: { type: 'any' },
    secureContext: { type: 'any' },
    enableTrace: { type: 'any' },
    requestCert: { type: 'any' },
    rejectUnauthorized: { type: 'any' },
    checkServerIdentity: { type: 'any' },
    ALPNProtocols: { type: 'any' },
    SNICallback: { type: 'any' },
    session: { type: 'any' },
    requestOCSP: { type: 'any' },
    localAddress: { type: 'any' },
    localPort: { type: 'any' },
    hints: { type: 'any' },
    lookup: { type: 'any' },
    ca: { type: 'any' },
    cert: { type: 'any' },
    ciphers: { type: 'any' },
    crl: { type: 'any' },
    ecdhCurve: { type: 'any' },
    key: { type: 'any' },
    passphrase: { type: 'any' },
    pfx: { type: 'any' },
    secureProtocol: { type: 'any' },
    index: { type: 'any' },
    // Legacy options from v3 era
    useNewUrlParser: {
        type: 'boolean',
        deprecated: 'useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version'
    },
    useUnifiedTopology: {
        type: 'boolean',
        deprecated: 'useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version'
    },
    // MongoLogger
    /**
     * @internal
     * TODO: NODE-5671 - remove internal flag
     */
    mongodbLogPath: {
        transform: function (_a) {
            var value = _a.values[0];
            if (!((typeof value === 'string' && ['stderr', 'stdout'].includes(value)) ||
                (value &&
                    typeof value === 'object' &&
                    'write' in value &&
                    typeof value.write === 'function'))) {
                throw new error_1.MongoAPIError("Option 'mongodbLogPath' must be of type 'stderr' | 'stdout' | MongoDBLogWritable");
            }
            return value;
        }
    },
    /**
     * @internal
     * TODO: NODE-5671 - remove internal flag
     */
    mongodbLogComponentSeverities: {
        transform: function (_a) {
            var value = _a.values[0];
            if (typeof value !== 'object' || !value) {
                throw new error_1.MongoAPIError("Option 'mongodbLogComponentSeverities' must be a non-null object");
            }
            var _loop_1 = function (k, v) {
                if (typeof v !== 'string' || typeof k !== 'string') {
                    throw new error_1.MongoAPIError("User input for option 'mongodbLogComponentSeverities' object cannot include a non-string key or value");
                }
                if (!Object.values(mongo_logger_1.MongoLoggableComponent).some(function (val) { return val === k; }) && k !== 'default') {
                    throw new error_1.MongoAPIError("User input for option 'mongodbLogComponentSeverities' contains invalid key: " + k);
                }
                if (!Object.values(mongo_logger_1.SeverityLevel).some(function (val) { return val === v; })) {
                    throw new error_1.MongoAPIError("Option 'mongodbLogComponentSeverities' does not support " + v + " as a value for " + k);
                }
            };
            for (var _i = 0, _b = Object.entries(value); _i < _b.length; _i++) {
                var _c = _b[_i], k = _c[0], v = _c[1];
                _loop_1(k, v);
            }
            return value;
        }
    },
    /**
     * @internal
     * TODO: NODE-5671 - remove internal flag
     */
    mongodbLogMaxDocumentLength: { type: 'uint' }
};
exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS)
    .filter(function (_a) {
    var descriptor = _a[1];
    return descriptor["default"] != null;
})
    .map(function (_a) {
    var k = _a[0], d = _a[1];
    return [k, d["default"]];
}));
/**
 * Set of permitted feature flags
 * @internal
 */
exports.FEATURE_FLAGS = new Set([
    Symbol["for"]('@@mdb.skipPingOnConnect'),
    Symbol["for"]('@@mdb.enableMongoLogger'),
    Symbol["for"]('@@mdb.internalLoggerConfig')
]);
var templateObject_1;
