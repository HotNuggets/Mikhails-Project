'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Mixed = require('../../schema/mixed');

var applyBuiltinPlugins = require('../schema/applyBuiltinPlugins');

var clone = require('../clone');

var defineKey = require('../document/compile').defineKey;

var get = require('../get');

var utils = require('../../utils');

var mergeDiscriminatorSchema = require('../../helpers/discriminator/mergeDiscriminatorSchema');

var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
  toJSON: true,
  toObject: true,
  _id: true,
  id: true,
  virtuals: true,
  methods: true
};
/*!
 * ignore
 */

module.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {
  if (!(schema && schema.instanceOfSchema)) {
    throw new Error('You must pass a valid discriminator Schema');
  }

  mergeHooks = mergeHooks == null ? true : mergeHooks;

  if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
    throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
  }

  if (applyPlugins) {
    var applyPluginsToDiscriminators = get(model.base, 'options.applyPluginsToDiscriminators', false) || !mergeHooks; // Even if `applyPluginsToDiscriminators` isn't set, we should still apply
    // global plugins to schemas embedded in the discriminator schema (gh-7370)

    model.base._applyPlugins(schema, {
      skipTopLevel: !applyPluginsToDiscriminators
    });
  } else if (!mergeHooks) {
    applyBuiltinPlugins(schema);
  }

  var key = model.schema.options.discriminatorKey;
  var existingPath = model.schema.path(key);

  if (existingPath != null) {
    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {
      existingPath.options.select = true;
    }

    existingPath.options.$skipDiscriminatorCheck = true;
  } else {
    var baseSchemaAddition = {};
    baseSchemaAddition[key] = {
      "default": void 0,
      select: true,
      $skipDiscriminatorCheck: true
    };
    baseSchemaAddition[key][model.schema.options.typeKey] = String;
    model.schema.add(baseSchemaAddition);
    defineKey({
      prop: key,
      prototype: model.prototype,
      options: model.schema.options
    });
  }

  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
    throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
  }

  var value = name;

  if (typeof tiedValue === 'string' && tiedValue.length || tiedValue != null) {
    value = tiedValue;
  }

  function merge(schema, baseSchema) {
    // Retain original schema before merging base schema
    schema._baseSchema = baseSchema;

    if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
      schema.remove('_id');
    } // Find conflicting paths: if something is a path in the base schema
    // and a nested path in the child schema, overwrite the base schema path.
    // See gh-6076


    var baseSchemaPaths = Object.keys(baseSchema.paths);
    var conflictingPaths = [];

    for (var _i = 0, _baseSchemaPaths = baseSchemaPaths; _i < _baseSchemaPaths.length; _i++) {
      var path = _baseSchemaPaths[_i];

      if (schema.nested[path]) {
        conflictingPaths.push(path);
        continue;
      }

      if (path.indexOf('.') === -1) {
        continue;
      }

      var sp = path.split('.').slice(0, -1);
      var cur = '';
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = sp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var piece = _step.value;
          cur += (cur.length ? '.' : '') + piece;

          if (schema.paths[cur] instanceof Mixed || schema.singleNestedPaths[cur] instanceof Mixed) {
            conflictingPaths.push(path);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // Shallow clone `obj` so we can add additional properties without modifying original
    // schema. `Schema.prototype.clone()` copies `obj` by reference, no cloning.


    schema.obj = _objectSpread({}, schema.obj);
    mergeDiscriminatorSchema(schema, baseSchema); // Clean up conflicting paths _after_ merging re: gh-6076

    for (var _i2 = 0, _conflictingPaths = conflictingPaths; _i2 < _conflictingPaths.length; _i2++) {
      var conflictingPath = _conflictingPaths[_i2];
      delete schema.paths[conflictingPath];
    } // Rebuild schema models because schemas may have been merged re: #7884


    schema.childSchemas.forEach(function (obj) {
      obj.model.prototype.$__setSchema(obj.schema);
    });
    var obj = {};
    obj[key] = {
      "default": value,
      select: true,
      set: function set(newName) {
        if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
          return value;
        }

        throw new Error('Can\'t set discriminator key "' + key + '"');
      },
      $skipDiscriminatorCheck: true
    };
    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;
    schema.add(obj);
    schema.discriminatorMapping = {
      key: key,
      value: value,
      isRoot: false
    };

    if (baseSchema.options.collection) {
      schema.options.collection = baseSchema.options.collection;
    }

    var toJSON = schema.options.toJSON;
    var toObject = schema.options.toObject;
    var _id = schema.options._id;
    var id = schema.options.id;
    var keys = Object.keys(schema.options);
    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;
    var userProvidedOptions = schema._userProvidedOptions;

    for (var _i3 = 0, _keys = keys; _i3 < _keys.length; _i3++) {
      var _key = _keys[_i3];

      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`
        // set above. We don't allow customizing discriminator key, always
        // overwrite. See gh-9238
        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {
          throw new Error('Can\'t customize discriminator option ' + _key + ' (can only modify ' + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') + ')');
        }
      }
    }

    schema.options = clone(baseSchema.options);

    for (var _i4 = 0, _Object$keys = Object.keys(userProvidedOptions); _i4 < _Object$keys.length; _i4++) {
      var _key2 = _Object$keys[_i4];
      schema.options[_key2] = userProvidedOptions[_key2];
    }

    if (toJSON) schema.options.toJSON = toJSON;
    if (toObject) schema.options.toObject = toObject;

    if (typeof _id !== 'undefined') {
      schema.options._id = _id;
    }

    schema.options.id = id;

    if (mergeHooks) {
      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);
    }

    if (applyPlugins) {
      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);
    }

    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);
    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema
  } // merges base schema into new discriminator schema and sets new type field.


  merge(schema, model.schema);

  if (!model.discriminators) {
    model.discriminators = {};
  }

  if (!model.schema.discriminatorMapping) {
    model.schema.discriminatorMapping = {
      key: key,
      value: null,
      isRoot: true
    };
  }

  if (!model.schema.discriminators) {
    model.schema.discriminators = {};
  }

  model.schema.discriminators[name] = schema;

  if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {
    throw new Error('Discriminator with name "' + name + '" already exists');
  }

  return schema;
};