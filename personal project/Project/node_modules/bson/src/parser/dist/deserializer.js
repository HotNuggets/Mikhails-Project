"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.internalDeserialize = void 0;
var binary_1 = require("../binary");
var code_1 = require("../code");
var constants = require("../constants");
var db_ref_1 = require("../db_ref");
var decimal128_1 = require("../decimal128");
var double_1 = require("../double");
var error_1 = require("../error");
var int_32_1 = require("../int_32");
var long_1 = require("../long");
var max_key_1 = require("../max_key");
var min_key_1 = require("../min_key");
var objectid_1 = require("../objectid");
var regexp_1 = require("../regexp");
var symbol_1 = require("../symbol");
var timestamp_1 = require("../timestamp");
var byte_utils_1 = require("../utils/byte_utils");
var number_utils_1 = require("../utils/number_utils");
// Internal long versions
var JS_INT_MAX_LONG = long_1.Long.fromNumber(constants.JS_INT_MAX);
var JS_INT_MIN_LONG = long_1.Long.fromNumber(constants.JS_INT_MIN);
function internalDeserialize(buffer, options, isArray) {
    options = options == null ? {} : options;
    var index = options && options.index ? options.index : 0;
    // Read the document size
    var size = number_utils_1.NumberUtils.getInt32LE(buffer, index);
    if (size < 5) {
        throw new error_1.BSONError("bson size must be >= 5, is " + size);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
        throw new error_1.BSONError("buffer length " + buffer.length + " must be >= bson size " + size);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
        throw new error_1.BSONError("buffer length " + buffer.length + " must === bson size " + size);
    }
    if (size + index > buffer.byteLength) {
        throw new error_1.BSONError("(bson size " + size + " + options.index " + index + " must be <= buffer length " + buffer.byteLength + ")");
    }
    // Illegal end value
    if (buffer[index + size - 1] !== 0) {
        throw new error_1.BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    // Start deserialization
    return deserializeObject(buffer, index, options, isArray);
}
exports.internalDeserialize = internalDeserialize;
var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
function deserializeObject(buffer, index, options, isArray) {
    var _a, _b, _c, _d;
    if (isArray === void 0) { isArray = false; }
    var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
    // Return raw bson buffer instead of parsing it
    var raw = options['raw'] == null ? false : options['raw'];
    // Return BSONRegExp objects instead of native regular expressions
    var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;
    // Controls the promotion of values vs wrapper classes
    var promoteBuffers = (_a = options.promoteBuffers) !== null && _a !== void 0 ? _a : false;
    var promoteLongs = (_b = options.promoteLongs) !== null && _b !== void 0 ? _b : true;
    var promoteValues = (_c = options.promoteValues) !== null && _c !== void 0 ? _c : true;
    var useBigInt64 = (_d = options.useBigInt64) !== null && _d !== void 0 ? _d : false;
    if (useBigInt64 && !promoteValues) {
        throw new error_1.BSONError('Must either request bigint or Long for int64 deserialization');
    }
    if (useBigInt64 && !promoteLongs) {
        throw new error_1.BSONError('Must either request bigint or Long for int64 deserialization');
    }
    // Ensures default validation option if none given
    var validation = options.validation == null ? { utf8: true } : options.validation;
    // Shows if global utf-8 validation is enabled or disabled
    var globalUTFValidation = true;
    // Reflects utf-8 validation setting regardless of global or specific key validation
    var validationSetting;
    // Set of keys either to enable or disable validation on
    var utf8KeysSet;
    // Check for boolean uniformity and empty validation option
    var utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === 'boolean') {
        validationSetting = utf8ValidatedKeys;
    }
    else {
        globalUTFValidation = false;
        var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {
            return utf8ValidatedKeys[key];
        });
        if (utf8ValidationValues.length === 0) {
            throw new error_1.BSONError('UTF-8 validation setting cannot be empty');
        }
        if (typeof utf8ValidationValues[0] !== 'boolean') {
            throw new error_1.BSONError('Invalid UTF-8 validation option, must specify boolean values');
        }
        validationSetting = utf8ValidationValues[0];
        // Ensures boolean uniformity in utf-8 validation (all true or all false)
        if (!utf8ValidationValues.every(function (item) { return item === validationSetting; })) {
            throw new error_1.BSONError('Invalid UTF-8 validation option - keys must be all true or all false');
        }
    }
    // Add keys to set that will either be validated or not based on validationSetting
    if (!globalUTFValidation) {
        utf8KeysSet = new Set();
        for (var _i = 0, _e = Object.keys(utf8ValidatedKeys); _i < _e.length; _i++) {
            var key = _e[_i];
            utf8KeysSet.add(key);
        }
    }
    // Set the start index
    var startIndex = index;
    // Validate that we have at least 4 bytes of buffer
    if (buffer.length < 5)
        throw new error_1.BSONError('corrupt bson message < 5 bytes long');
    // Read the document size
    var size = number_utils_1.NumberUtils.getInt32LE(buffer, index);
    index += 4;
    // Ensure buffer is valid size
    if (size < 5 || size > buffer.length)
        throw new error_1.BSONError('corrupt bson message');
    // Create holding object
    var object = isArray ? [] : {};
    // Used for arrays to skip having to perform utf8 decoding
    var arrayIndex = 0;
    var done = false;
    var isPossibleDBRef = isArray ? false : null;
    // While we have more left data left keep parsing
    while (!done) {
        // Read the type
        var elementType = buffer[index++];
        // If we get a zero it's the last byte, exit
        if (elementType === 0)
            break;
        // Get the start search index
        var i = index;
        // Locate the end of the c string
        while (buffer[i] !== 0x00 && i < buffer.length) {
            i++;
        }
        // If are at the end of the buffer there is a problem with the document
        if (i >= buffer.byteLength)
            throw new error_1.BSONError('Bad BSON Document: illegal CString');
        // Represents the key
        var name = isArray ? arrayIndex++ : byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
        // shouldValidateKey is true if the key should be validated, false otherwise
        var shouldValidateKey = true;
        if (globalUTFValidation || (utf8KeysSet === null || utf8KeysSet === void 0 ? void 0 : utf8KeysSet.has(name))) {
            shouldValidateKey = validationSetting;
        }
        else {
            shouldValidateKey = !validationSetting;
        }
        if (isPossibleDBRef !== false && name[0] === '$') {
            isPossibleDBRef = allowedDBRefKeys.test(name);
        }
        var value = void 0;
        index = i + 1;
        if (elementType === constants.BSON_DATA_STRING) {
            var stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            value = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            index = index + stringSize;
        }
        else if (elementType === constants.BSON_DATA_OID) {
            var oid = byte_utils_1.ByteUtils.allocateUnsafe(12);
            for (var i_1 = 0; i_1 < 12; i_1++)
                oid[i_1] = buffer[index + i_1];
            value = new objectid_1.ObjectId(oid);
            index = index + 12;
        }
        else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {
            value = new int_32_1.Int32(number_utils_1.NumberUtils.getInt32LE(buffer, index));
            index += 4;
        }
        else if (elementType === constants.BSON_DATA_INT) {
            value = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
        }
        else if (elementType === constants.BSON_DATA_NUMBER) {
            value = number_utils_1.NumberUtils.getFloat64LE(buffer, index);
            index += 8;
            if (promoteValues === false)
                value = new double_1.Double(value);
        }
        else if (elementType === constants.BSON_DATA_DATE) {
            var lowBits = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            var highBits = number_utils_1.NumberUtils.getInt32LE(buffer, index + 4);
            index += 8;
            value = new Date(new long_1.Long(lowBits, highBits).toNumber());
        }
        else if (elementType === constants.BSON_DATA_BOOLEAN) {
            if (buffer[index] !== 0 && buffer[index] !== 1)
                throw new error_1.BSONError('illegal boolean type value');
            value = buffer[index++] === 1;
        }
        else if (elementType === constants.BSON_DATA_OBJECT) {
            var _index = index;
            var objectSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            if (objectSize <= 0 || objectSize > buffer.length - index)
                throw new error_1.BSONError('bad embedded document length in bson');
            // We have a raw value
            if (raw) {
                value = buffer.slice(index, index + objectSize);
            }
            else {
                var objectOptions = options;
                if (!globalUTFValidation) {
                    objectOptions = __assign(__assign({}, options), { validation: { utf8: shouldValidateKey } });
                }
                value = deserializeObject(buffer, _index, objectOptions, false);
            }
            index = index + objectSize;
        }
        else if (elementType === constants.BSON_DATA_ARRAY) {
            var _index = index;
            var objectSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            var arrayOptions = options;
            // Stop index
            var stopIndex = index + objectSize;
            // All elements of array to be returned as raw bson
            if (fieldsAsRaw && fieldsAsRaw[name]) {
                arrayOptions = __assign(__assign({}, options), { raw: true });
            }
            if (!globalUTFValidation) {
                arrayOptions = __assign(__assign({}, arrayOptions), { validation: { utf8: shouldValidateKey } });
            }
            value = deserializeObject(buffer, _index, arrayOptions, true);
            index = index + objectSize;
            if (buffer[index - 1] !== 0)
                throw new error_1.BSONError('invalid array terminator byte');
            if (index !== stopIndex)
                throw new error_1.BSONError('corrupted array bson');
        }
        else if (elementType === constants.BSON_DATA_UNDEFINED) {
            value = undefined;
        }
        else if (elementType === constants.BSON_DATA_NULL) {
            value = null;
        }
        else if (elementType === constants.BSON_DATA_LONG) {
            if (useBigInt64) {
                value = number_utils_1.NumberUtils.getBigInt64LE(buffer, index);
                index += 8;
            }
            else {
                // Unpack the low and high bits
                var lowBits = number_utils_1.NumberUtils.getInt32LE(buffer, index);
                var highBits = number_utils_1.NumberUtils.getInt32LE(buffer, index + 4);
                index += 8;
                var long = new long_1.Long(lowBits, highBits);
                // Promote the long if possible
                if (promoteLongs && promoteValues === true) {
                    value =
                        long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)
                            ? long.toNumber()
                            : long;
                }
                else {
                    value = long;
                }
            }
        }
        else if (elementType === constants.BSON_DATA_DECIMAL128) {
            // Buffer to contain the decimal bytes
            var bytes = byte_utils_1.ByteUtils.allocateUnsafe(16);
            // Copy the next 16 bytes into the bytes buffer
            for (var i_2 = 0; i_2 < 16; i_2++)
                bytes[i_2] = buffer[index + i_2];
            // Update index
            index = index + 16;
            // Assign the new Decimal128 value
            value = new decimal128_1.Decimal128(bytes);
        }
        else if (elementType === constants.BSON_DATA_BINARY) {
            var binarySize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            var totalBinarySize = binarySize;
            var subType = buffer[index++];
            // Did we have a negative binary size, throw
            if (binarySize < 0)
                throw new error_1.BSONError('Negative binary type element size found');
            // Is the length longer than the document
            if (binarySize > buffer.byteLength)
                throw new error_1.BSONError('Binary type size larger than document size');
            // Decode as raw Buffer object if options specifies it
            if (buffer['slice'] != null) {
                // If we have subtype 2 skip the 4 bytes for the size
                if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
                    binarySize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
                    index += 4;
                    if (binarySize < 0)
                        throw new error_1.BSONError('Negative binary type element size found for subtype 0x02');
                    if (binarySize > totalBinarySize - 4)
                        throw new error_1.BSONError('Binary type with subtype 0x02 contains too long binary size');
                    if (binarySize < totalBinarySize - 4)
                        throw new error_1.BSONError('Binary type with subtype 0x02 contains too short binary size');
                }
                if (promoteBuffers && promoteValues) {
                    value = byte_utils_1.ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));
                }
                else {
                    value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType);
                    if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW && binary_1.UUID.isValid(value)) {
                        value = value.toUUID();
                    }
                }
            }
            else {
                // If we have subtype 2 skip the 4 bytes for the size
                if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
                    binarySize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
                    index += 4;
                    if (binarySize < 0)
                        throw new error_1.BSONError('Negative binary type element size found for subtype 0x02');
                    if (binarySize > totalBinarySize - 4)
                        throw new error_1.BSONError('Binary type with subtype 0x02 contains too long binary size');
                    if (binarySize < totalBinarySize - 4)
                        throw new error_1.BSONError('Binary type with subtype 0x02 contains too short binary size');
                }
                if (promoteBuffers && promoteValues) {
                    value = byte_utils_1.ByteUtils.allocateUnsafe(binarySize);
                    // Copy the data
                    for (i = 0; i < binarySize; i++) {
                        value[i] = buffer[index + i];
                    }
                }
                else {
                    value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType);
                    if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW && binary_1.UUID.isValid(value)) {
                        value = value.toUUID();
                    }
                }
            }
            // Update the index
            index = index + binarySize;
        }
        else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            var source = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            // Create the regexp
            index = i + 1;
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            var regExpOptions = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            index = i + 1;
            // For each option add the corresponding one for javascript
            var optionsArray = new Array(regExpOptions.length);
            // Parse options
            for (i = 0; i < regExpOptions.length; i++) {
                switch (regExpOptions[i]) {
                    case 'm':
                        optionsArray[i] = 'm';
                        break;
                    case 's':
                        optionsArray[i] = 'g';
                        break;
                    case 'i':
                        optionsArray[i] = 'i';
                        break;
                }
            }
            value = new RegExp(source, optionsArray.join(''));
        }
        else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            var source = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            index = i + 1;
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            var regExpOptions = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            index = i + 1;
            // Set the object
            value = new regexp_1.BSONRegExp(source, regExpOptions);
        }
        else if (elementType === constants.BSON_DATA_SYMBOL) {
            var stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            var symbol = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            value = promoteValues ? symbol : new symbol_1.BSONSymbol(symbol);
            index = index + stringSize;
        }
        else if (elementType === constants.BSON_DATA_TIMESTAMP) {
            value = new timestamp_1.Timestamp({
                i: number_utils_1.NumberUtils.getUint32LE(buffer, index),
                t: number_utils_1.NumberUtils.getUint32LE(buffer, index + 4)
            });
            index += 8;
        }
        else if (elementType === constants.BSON_DATA_MIN_KEY) {
            value = new min_key_1.MinKey();
        }
        else if (elementType === constants.BSON_DATA_MAX_KEY) {
            value = new max_key_1.MaxKey();
        }
        else if (elementType === constants.BSON_DATA_CODE) {
            var stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            var functionString = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            value = new code_1.Code(functionString);
            // Update parse index position
            index = index + stringSize;
        }
        else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {
            var totalSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            // Element cannot be shorter than totalSize + stringSize + documentSize + terminator
            if (totalSize < 4 + 4 + 4 + 1) {
                throw new error_1.BSONError('code_w_scope total size shorter minimum expected length');
            }
            // Get the code string size
            var stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            // Check if we have a valid string
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            // Javascript function
            var functionString = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            // Update parse index position
            index = index + stringSize;
            // Parse the element
            var _index = index;
            // Decode the size of the object document
            var objectSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            // Decode the scope object
            var scopeObject = deserializeObject(buffer, _index, options, false);
            // Adjust the index
            index = index + objectSize;
            // Check if field length is too short
            if (totalSize < 4 + 4 + objectSize + stringSize) {
                throw new error_1.BSONError('code_w_scope total size is too short, truncating scope');
            }
            // Check if totalSize field is too long
            if (totalSize > 4 + 4 + objectSize + stringSize) {
                throw new error_1.BSONError('code_w_scope total size is too long, clips outer document');
            }
            value = new code_1.Code(functionString, scopeObject);
        }
        else if (elementType === constants.BSON_DATA_DBPOINTER) {
            // Get the code string size
            var stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            // Check if we have a valid string
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0)
                throw new error_1.BSONError('bad string length in bson');
            // Namespace
            var namespace = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            // Update parse index position
            index = index + stringSize;
            // Read the oid
            var oidBuffer = byte_utils_1.ByteUtils.allocateUnsafe(12);
            for (var i_3 = 0; i_3 < 12; i_3++)
                oidBuffer[i_3] = buffer[index + i_3];
            var oid = new objectid_1.ObjectId(oidBuffer);
            // Update the index
            index = index + 12;
            // Upgrade to DBRef type
            value = new db_ref_1.DBRef(namespace, oid);
        }
        else {
            throw new error_1.BSONError("Detected unknown BSON type " + elementType.toString(16) + " for fieldname \"" + name + "\"");
        }
        if (name === '__proto__') {
            Object.defineProperty(object, name, {
                value: value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
        else {
            object[name] = value;
        }
    }
    // Check if the deserialization was against a valid array/object
    if (size !== index - startIndex) {
        if (isArray)
            throw new error_1.BSONError('corrupt array bson');
        throw new error_1.BSONError('corrupt object bson');
    }
    // if we did not find "$ref", "$id", "$db", or found an extraneous $key, don't make a DBRef
    if (!isPossibleDBRef)
        return object;
    if (db_ref_1.isDBRefLike(object)) {
        var copy = Object.assign({}, object);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new db_ref_1.DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
}
