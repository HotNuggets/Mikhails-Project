"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.executeOperation = void 0;
var error_1 = require("../error");
var read_preference_1 = require("../read_preference");
var server_selection_1 = require("../sdam/server_selection");
var utils_1 = require("../utils");
var operation_1 = require("./operation");
var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';
/**
 * Executes the given operation with provided arguments.
 * @internal
 *
 * @remarks
 * Allows for a single point of entry to provide features such as implicit sessions, which
 * are required by the Driver Sessions specification in the event that a ClientSession is
 * not provided.
 *
 * The expectation is that this function:
 * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}
 * - Creates a session if none is provided and cleans up the session it creates
 * - Tries an operation and retries under certain conditions, see {@link tryOperation}
 *
 * @typeParam T - The operation's type
 * @typeParam TResult - The type of the operation's result, calculated from T
 *
 * @param client - The MongoClient to execute this operation with
 * @param operation - The operation to execute
 */
function executeOperation(client, operation) {
    var _a;
    return __awaiter(this, void 0, Promise, function () {
        var topology, session, owner, readPreference, inTransaction, hasReadAspect;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(operation instanceof operation_1.AbstractOperation)) {
                        // TODO(NODE-3483): Extend MongoRuntimeError
                        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');
                    }
                    return [4 /*yield*/, autoConnect(client)];
                case 1:
                    topology = _b.sent();
                    session = operation.session;
                    if (session == null) {
                        owner = Symbol();
                        session = client.startSession({ owner: owner, explicit: false });
                    }
                    else if (session.hasEnded) {
                        throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');
                    }
                    else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
                        throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');
                    }
                    else if (session.client !== client) {
                        throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');
                    }
                    if (session.explicit && (session === null || session === void 0 ? void 0 : session.timeoutMS) != null && operation.options.timeoutMS != null) {
                        throw new error_1.MongoInvalidArgumentError('Do not specify timeoutMS on operation if already specified on an explicit session');
                    }
                    readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
                    inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());
                    hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
                    if (inTransaction &&
                        !readPreference.equals(read_preference_1.ReadPreference.primary) &&
                        (hasReadAspect || operation.commandName === 'runCommand')) {
                        throw new error_1.MongoTransactionError("Read preference in a transaction must be primary, not: " + readPreference.mode);
                    }
                    if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {
                        session.unpin();
                    }
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, , 4, 7]);
                    return [4 /*yield*/, tryOperation(operation, {
                            topology: topology,
                            session: session,
                            readPreference: readPreference
                        })];
                case 3: return [2 /*return*/, _b.sent()];
                case 4:
                    if (!((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner)) return [3 /*break*/, 6];
                    return [4 /*yield*/, session.endSession()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    });
}
exports.executeOperation = executeOperation;
/**
 * Connects a client if it has not yet been connected
 * @internal
 */
function autoConnect(client) {
    return __awaiter(this, void 0, Promise, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(client.topology == null)) return [3 /*break*/, 4];
                    if (client.s.hasBeenClosed) {
                        throw new error_1.MongoNotConnectedError('Client must be connected before running operations');
                    }
                    client.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')] = true;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, client.connect()];
                case 2:
                    _a.sent();
                    if (client.topology == null) {
                        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');
                    }
                    return [2 /*return*/, client.topology];
                case 3:
                    delete client.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')];
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/, client.topology];
            }
        });
    });
}
/**
 * Executes an operation and retries as appropriate
 * @internal
 *
 * @remarks
 * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable
 * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification
 *
 * This function:
 * - performs initial server selection
 * - attempts to execute an operation
 * - retries the operation if it meets the criteria for a retryable read or a retryable write
 *
 * @typeParam T - The operation's type
 * @typeParam TResult - The type of the operation's result, calculated from T
 *
 * @param operation - The operation to execute
 * */
function tryOperation(operation, _a) {
    var _b, _c;
    var topology = _a.topology, session = _a.session, readPreference = _a.readPreference;
    return __awaiter(this, void 0, Promise, function () {
        var selector, server, hasReadAspect, hasWriteAspect, inTransaction, willRetryRead, willRetryWrite, willRetry, maxTries, previousOperationError, previousServer, tries, operationError_1;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
                        // GetMore and KillCursor operations must always select the same server, but run through
                        // server selection to potentially force monitor checks if the server is
                        // in an unknown state.
                        selector = server_selection_1.sameServerSelector((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);
                    }
                    else if (operation.trySecondaryWrite) {
                        // If operation should try to write to secondary use the custom server selector
                        // otherwise provide the read preference.
                        selector = server_selection_1.secondaryWritableServerSelector(topology.commonWireVersion, readPreference);
                    }
                    else {
                        selector = readPreference;
                    }
                    return [4 /*yield*/, topology.selectServer(selector, {
                            session: session,
                            operationName: operation.commandName
                        })];
                case 1:
                    server = _d.sent();
                    hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
                    hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
                    inTransaction = (_c = session === null || session === void 0 ? void 0 : session.inTransaction()) !== null && _c !== void 0 ? _c : false;
                    willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
                    willRetryWrite = topology.s.options.retryWrites &&
                        !inTransaction &&
                        utils_1.supportsRetryableWrites(server) &&
                        operation.canRetryWrite;
                    willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) &&
                        session != null &&
                        ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));
                    if (hasWriteAspect && willRetryWrite && session != null) {
                        operation.options.willRetryWrite = true;
                        session.incrementTransactionNumber();
                    }
                    maxTries = willRetry ? 2 : 1;
                    tries = 0;
                    _d.label = 2;
                case 2:
                    if (!(tries < maxTries)) return [3 /*break*/, 8];
                    if (!previousOperationError) return [3 /*break*/, 4];
                    if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
                        throw new error_1.MongoServerError({
                            message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
                            errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
                            originalError: previousOperationError
                        });
                    }
                    if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {
                        throw previousOperationError;
                    }
                    if (hasWriteAspect && !error_1.isRetryableWriteError(previousOperationError))
                        throw previousOperationError;
                    if (hasReadAspect && !error_1.isRetryableReadError(previousOperationError))
                        throw previousOperationError;
                    if (previousOperationError instanceof error_1.MongoNetworkError &&
                        operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) &&
                        session != null &&
                        session.isPinned &&
                        !session.inTransaction()) {
                        session.unpin({ force: true, forceClear: true });
                    }
                    return [4 /*yield*/, topology.selectServer(selector, {
                            session: session,
                            operationName: operation.commandName,
                            previousServer: previousServer
                        })];
                case 3:
                    server = _d.sent();
                    if (hasWriteAspect && !utils_1.supportsRetryableWrites(server)) {
                        throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');
                    }
                    _d.label = 4;
                case 4:
                    _d.trys.push([4, 6, , 7]);
                    // If tries > 0 and we are command batching we need to reset the batch.
                    if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {
                        operation.resetBatch();
                    }
                    return [4 /*yield*/, operation.execute(server, session)];
                case 5: return [2 /*return*/, _d.sent()];
                case 6:
                    operationError_1 = _d.sent();
                    if (!(operationError_1 instanceof error_1.MongoError))
                        throw operationError_1;
                    if (previousOperationError != null &&
                        operationError_1.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
                        throw previousOperationError;
                    }
                    previousServer = server.description;
                    previousOperationError = operationError_1;
                    return [3 /*break*/, 7];
                case 7:
                    tries++;
                    return [3 /*break*/, 2];
                case 8: throw (previousOperationError !== null && previousOperationError !== void 0 ? previousOperationError : new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.'));
            }
        });
    });
}
