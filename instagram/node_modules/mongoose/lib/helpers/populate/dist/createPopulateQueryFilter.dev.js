'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SkipPopulateValue = require('./skipPopulateValue');

var parentPaths = require('../path/parentPaths');

var _require = require('../query/trusted'),
    trusted = _require.trusted;

var hasDollarKeys = require('../query/hasDollarKeys');

module.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
  var match = _formatMatch(_match);

  if (_foreignField.size === 1) {
    var foreignField = Array.from(_foreignField)[0];
    var foreignSchemaType = model.schema.path(foreignField);

    if (foreignField !== '_id' || !match['_id']) {
      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
      match[foreignField] = trusted({
        $in: ids
      });
    } else if (foreignField === '_id' && match['_id']) {
      var userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : {
        $eq: match[foreignField]
      };
      match[foreignField] = _objectSpread({}, trusted({
        $in: ids
      }), {}, userSpecifiedMatch);
    }

    var _parentPaths = parentPaths(foreignField);

    for (var i = 0; i < _parentPaths.length - 1; ++i) {
      var cur = _parentPaths[i];

      if (match[cur] != null && match[cur].$elemMatch != null) {
        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({
          $in: ids
        });
        delete match[foreignField];
        break;
      }
    }
  } else {
    var $or = [];

    if (Array.isArray(match.$or)) {
      match.$and = [{
        $or: match.$or
      }, {
        $or: $or
      }];
      delete match.$or;
    } else {
      match.$or = $or;
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _foreignField[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _foreignField2 = _step.value;

        if (_foreignField2 !== '_id' || !match['_id']) {
          var _foreignSchemaType = model.schema.path(_foreignField2);

          ids = _filterInvalidIds(ids, _foreignSchemaType, skipInvalidIds);
          $or.push(_defineProperty({}, _foreignField2, {
            $in: ids
          }));
        } else if (_foreignField2 === '_id' && match['_id']) {
          var _userSpecifiedMatch = hasDollarKeys(match[_foreignField2]) ? match[_foreignField2] : {
            $eq: match[_foreignField2]
          };

          match[_foreignField2] = _objectSpread({}, trusted({
            $in: ids
          }), {}, _userSpecifiedMatch);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return match;
};
/**
 * Optionally filter out invalid ids that don't conform to foreign field's schema
 * to avoid cast errors (gh-7706)
 * @param {Array} ids
 * @param {SchemaType} foreignSchemaType
 * @param {Boolean} [skipInvalidIds]
 * @api private
 */


function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
  ids = ids.filter(function (v) {
    return !(v instanceof SkipPopulateValue);
  });

  if (!skipInvalidIds) {
    return ids;
  }

  return ids.filter(function (id) {
    try {
      foreignSchemaType.cast(id);
      return true;
    } catch (err) {
      return false;
    }
  });
}
/**
 * Format `mod.match` given that it may be an array that we need to $or if
 * the client has multiple docs with match functions
 * @param {Array|Any} match
 * @api private
 */


function _formatMatch(match) {
  if (Array.isArray(match)) {
    if (match.length > 1) {
      return {
        $or: [].concat(match.map(function (m) {
          return Object.assign({}, m);
        }))
      };
    }

    return Object.assign({}, match[0]);
  }

  return Object.assign({}, match);
}