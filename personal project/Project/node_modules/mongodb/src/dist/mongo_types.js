"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var _a;
exports.__esModule = true;
exports.CancellationToken = exports.TypedEventEmitter = void 0;
var events_1 = require("events");
var mongo_logger_1 = require("./mongo_logger");
/**
 * Typescript type safe event emitter
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging
var TypedEventEmitter = /** @class */ (function (_super) {
    __extends(TypedEventEmitter, _super);
    function TypedEventEmitter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @internal */
    TypedEventEmitter.prototype.emitAndLog = function (event) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.emit.apply(this, __spreadArrays([event], args));
        if (this.component)
            (_a = this.mongoLogger) === null || _a === void 0 ? void 0 : _a.debug(this.component, args[0]);
    };
    /** @internal */
    TypedEventEmitter.prototype.emitAndLogHeartbeat = function (event, topologyId, serverConnectionId) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        this.emit.apply(this, __spreadArrays([event], args));
        if (this.component) {
            var loggableHeartbeatEvent = __assign({ topologyId: topologyId, serverConnectionId: serverConnectionId !== null && serverConnectionId !== void 0 ? serverConnectionId : null }, args[0]);
            (_a = this.mongoLogger) === null || _a === void 0 ? void 0 : _a.debug(this.component, loggableHeartbeatEvent);
        }
    };
    /** @internal */
    TypedEventEmitter.prototype.emitAndLogCommand = function (monitorCommands, event, databaseName, connectionEstablished) {
        var _a;
        var args = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            args[_i - 4] = arguments[_i];
        }
        if (monitorCommands) {
            this.emit.apply(this, __spreadArrays([event], args));
        }
        if (connectionEstablished) {
            var loggableCommandEvent = __assign({ databaseName: databaseName }, args[0]);
            (_a = this.mongoLogger) === null || _a === void 0 ? void 0 : _a.debug(mongo_logger_1.MongoLoggableComponent.COMMAND, loggableCommandEvent);
        }
    };
    return TypedEventEmitter;
}(events_1.EventEmitter));
exports.TypedEventEmitter = TypedEventEmitter;
/** @public */
var CancellationToken = /** @class */ (function (_super) {
    __extends(CancellationToken, _super);
    function CancellationToken() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CancellationToken;
}(TypedEventEmitter));
exports.CancellationToken = CancellationToken;
"" + T[0];
T;
__spreadArrays([string | number], infer, [R]) ? "" + T[0] + D + Join("\n      : string;\n\n/** @public */\nexport type PropertyType<Type, Property extends string> = string extends Property\n  ? unknown\n  : Property extends keyof Type\n    ? Type[Property]\n    : Property extends ", $, { number: number }(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n      ? Type extends ReadonlyArray<infer ArrayType>\n        ? ArrayType\n        : unknown\n      : Property extends "], ["\n      ? Type extends ReadonlyArray<infer ArrayType>\n        ? ArrayType\n        : unknown\n      : Property extends "]))), $, { infer: infer, Key: Key }.$, { infer: infer, Rest: Rest }(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n        ? Key extends "], ["\n        ? Key extends "]))), $, { number: number }(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n          ? Type extends ReadonlyArray<infer ArrayType>\n            ? PropertyType<ArrayType, Rest>\n            : unknown\n          : Key extends keyof Type\n            ? Type[Key] extends Map<string, infer MapType>\n              ? MapType\n              : PropertyType<Type[Key], Rest>\n            : unknown\n        : unknown;\n\n/**\n * @public\n * returns tuple of strings (keys to be joined on '.') that represent every path into a schema\n * https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/\n *\n * @remarks\n * Through testing we determined that a depth of 8 is safe for the typescript compiler\n * and provides reasonable compilation times. This number is otherwise not special and\n * should be changed if issues are found with this level of checking. Beyond this\n * depth any helpers that make use of NestedPaths should devolve to not asserting any\n * type safety on the input.\n */\nexport type NestedPaths<Type, Depth extends number[]> = Depth['length'] extends 8\n  ? []\n  : Type extends\n        | string\n        | number\n        | bigint\n        | boolean\n        | Date\n        | RegExp\n        | Buffer\n        | Uint8Array\n        | ((...args: any[]) => any)\n        | { _bsontype: string }\n    ? []\n    : Type extends ReadonlyArray<infer ArrayType>\n      ? [] | [number, ...NestedPaths<ArrayType, [...Depth, 1]>]\n      : Type extends Map<string, any>\n        ? [string]\n        : Type extends object\n          ? {\n              [Key in Extract<keyof Type, string>]: Type[Key] extends Type // type of value extends the parent\n                ? [Key]\n                : // for a recursive union type, the child will never extend the parent type.\n                  // but the parent will still extend the child\n                  Type extends Type[Key]\n                  ? [Key]\n                  : Type[Key] extends ReadonlyArray<infer ArrayType> // handling recursive types with arrays\n                    ? Type extends ArrayType // is the type of the parent the same as the type of the array?\n                      ? [Key] // yes, it's a recursive array type\n                      : // for unions, the child type extends the parent\n                        ArrayType extends Type\n                        ? [Key] // we have a recursive array union\n                        : // child is an array, but it's not a recursive array\n                          [Key, ...NestedPaths<Type[Key], [...Depth, 1]>]\n                    : // child is not structured the same as the parent\n                      [Key, ...NestedPaths<Type[Key], [...Depth, 1]>] | [Key];\n            }[Extract<keyof Type, string>]\n          : [];\n\n/**\n * @public\n * returns keys (strings) for every path into a schema with a value of type\n * https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/\n */\nexport type NestedPathsOfType<TSchema, Type> = KeysOfAType<\n  {\n    [Property in Join<NestedPaths<TSchema, []>, '.'>]: PropertyType<TSchema, Property>;\n  },\n  Type\n>;\n\n/**\n * @public\n * @experimental\n */\nexport type StrictFilter<TSchema> =\n  | Partial<TSchema>\n  | ({\n      [Property in Join<NestedPaths<WithId<TSchema>, []>, '.'>]?: Condition<\n        PropertyType<WithId<TSchema>, Property>\n      >;\n    } & RootFilterOperators<WithId<TSchema>>);\n\n/**\n * @public\n * @experimental\n */\nexport type StrictUpdateFilter<TSchema> = {\n  $currentDate?: OnlyFieldsOfType<\n    TSchema,\n    Date | Timestamp,\n    true | { $type: 'date' | 'timestamp' }\n  >;\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $min?: StrictMatchKeysAndValues<TSchema>;\n  $max?: StrictMatchKeysAndValues<TSchema>;\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $rename?: Record<string, string>;\n  $set?: StrictMatchKeysAndValues<TSchema>;\n  $setOnInsert?: StrictMatchKeysAndValues<TSchema>;\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\n  $addToSet?: SetFields<TSchema>;\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\n  $pull?: PullOperator<TSchema>;\n  $push?: PushOperator<TSchema>;\n  $pullAll?: PullAllOperator<TSchema>;\n  $bit?: OnlyFieldsOfType<\n    TSchema,\n    NumericType | undefined,\n    { and: IntegerType } | { or: IntegerType } | { xor: IntegerType }\n  >;\n} & Document;\n\n/**\n * @public\n * @experimental\n */\nexport type StrictMatchKeysAndValues<TSchema> = Readonly<\n  {\n    [Property in Join<NestedPaths<TSchema, []>, '.'>]?: PropertyType<TSchema, Property>;\n  } & {\n    [Property in "], ["\n          ? Type extends ReadonlyArray<infer ArrayType>\n            ? PropertyType<ArrayType, Rest>\n            : unknown\n          : Key extends keyof Type\n            ? Type[Key] extends Map<string, infer MapType>\n              ? MapType\n              : PropertyType<Type[Key], Rest>\n            : unknown\n        : unknown;\n\n/**\n * @public\n * returns tuple of strings (keys to be joined on '.') that represent every path into a schema\n * https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/\n *\n * @remarks\n * Through testing we determined that a depth of 8 is safe for the typescript compiler\n * and provides reasonable compilation times. This number is otherwise not special and\n * should be changed if issues are found with this level of checking. Beyond this\n * depth any helpers that make use of NestedPaths should devolve to not asserting any\n * type safety on the input.\n */\nexport type NestedPaths<Type, Depth extends number[]> = Depth['length'] extends 8\n  ? []\n  : Type extends\n        | string\n        | number\n        | bigint\n        | boolean\n        | Date\n        | RegExp\n        | Buffer\n        | Uint8Array\n        | ((...args: any[]) => any)\n        | { _bsontype: string }\n    ? []\n    : Type extends ReadonlyArray<infer ArrayType>\n      ? [] | [number, ...NestedPaths<ArrayType, [...Depth, 1]>]\n      : Type extends Map<string, any>\n        ? [string]\n        : Type extends object\n          ? {\n              [Key in Extract<keyof Type, string>]: Type[Key] extends Type // type of value extends the parent\n                ? [Key]\n                : // for a recursive union type, the child will never extend the parent type.\n                  // but the parent will still extend the child\n                  Type extends Type[Key]\n                  ? [Key]\n                  : Type[Key] extends ReadonlyArray<infer ArrayType> // handling recursive types with arrays\n                    ? Type extends ArrayType // is the type of the parent the same as the type of the array?\n                      ? [Key] // yes, it's a recursive array type\n                      : // for unions, the child type extends the parent\n                        ArrayType extends Type\n                        ? [Key] // we have a recursive array union\n                        : // child is an array, but it's not a recursive array\n                          [Key, ...NestedPaths<Type[Key], [...Depth, 1]>]\n                    : // child is not structured the same as the parent\n                      [Key, ...NestedPaths<Type[Key], [...Depth, 1]>] | [Key];\n            }[Extract<keyof Type, string>]\n          : [];\n\n/**\n * @public\n * returns keys (strings) for every path into a schema with a value of type\n * https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/\n */\nexport type NestedPathsOfType<TSchema, Type> = KeysOfAType<\n  {\n    [Property in Join<NestedPaths<TSchema, []>, '.'>]: PropertyType<TSchema, Property>;\n  },\n  Type\n>;\n\n/**\n * @public\n * @experimental\n */\nexport type StrictFilter<TSchema> =\n  | Partial<TSchema>\n  | ({\n      [Property in Join<NestedPaths<WithId<TSchema>, []>, '.'>]?: Condition<\n        PropertyType<WithId<TSchema>, Property>\n      >;\n    } & RootFilterOperators<WithId<TSchema>>);\n\n/**\n * @public\n * @experimental\n */\nexport type StrictUpdateFilter<TSchema> = {\n  $currentDate?: OnlyFieldsOfType<\n    TSchema,\n    Date | Timestamp,\n    true | { $type: 'date' | 'timestamp' }\n  >;\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $min?: StrictMatchKeysAndValues<TSchema>;\n  $max?: StrictMatchKeysAndValues<TSchema>;\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $rename?: Record<string, string>;\n  $set?: StrictMatchKeysAndValues<TSchema>;\n  $setOnInsert?: StrictMatchKeysAndValues<TSchema>;\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\n  $addToSet?: SetFields<TSchema>;\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\n  $pull?: PullOperator<TSchema>;\n  $push?: PushOperator<TSchema>;\n  $pullAll?: PullAllOperator<TSchema>;\n  $bit?: OnlyFieldsOfType<\n    TSchema,\n    NumericType | undefined,\n    { and: IntegerType } | { or: IntegerType } | { xor: IntegerType }\n  >;\n} & Document;\n\n/**\n * @public\n * @experimental\n */\nexport type StrictMatchKeysAndValues<TSchema> = Readonly<\n  {\n    [Property in Join<NestedPaths<TSchema, []>, '.'>]?: PropertyType<TSchema, Property>;\n  } & {\n    [Property in "]))), $, (_a = {}, _a[] =  > , _a).$$, {}(templateObject_4 || (templateObject_4 = __makeTemplateObject(["[", "]"], ["[", "]"])), string) | '', "]?: ArrayElement<\n      PropertyType<TSchema, Property extends ", $, { infer: infer, Key: Key }.$$, { string: string }(templateObject_5 || (templateObject_5 = __makeTemplateObject([" ? Key : never>\n    >;\n  } & {\n    [Property in "], [" ? Key : never>\n    >;\n  } & {\n    [Property in "]))), $, {} < string, any > [] > , $$, {}
    | "[" + string + "]"
    | '', $, { string: string }(templateObject_6 || (templateObject_6 = __makeTemplateObject(["]?: any; // Could be further narrowed\n  } & Document\n>;\n"], ["]?: any; // Could be further narrowed\n  } & Document\n>;\n"])))) : ;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6;
