"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
exports.__esModule = true;
exports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = void 0;
var timers_1 = require("timers");
var bson_1 = require("../bson");
var connect_1 = require("../cmap/connect");
var client_metadata_1 = require("../cmap/handshake/client_metadata");
var constants_1 = require("../constants");
var error_1 = require("../error");
var mongo_logger_1 = require("../mongo_logger");
var mongo_types_1 = require("../mongo_types");
var utils_1 = require("../utils");
var common_1 = require("./common");
var events_1 = require("./events");
var server_1 = require("./server");
/** @internal */
var kServer = Symbol('server');
/** @internal */
var kMonitorId = Symbol('monitorId');
/** @internal */
var kCancellationToken = Symbol('cancellationToken');
var STATE_IDLE = 'idle';
var STATE_MONITORING = 'monitoring';
var stateTransition = utils_1.makeStateMachine((_a = {},
    _a[common_1.STATE_CLOSING] = [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
    _a[common_1.STATE_CLOSED] = [common_1.STATE_CLOSED, STATE_MONITORING],
    _a[STATE_IDLE] = [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
    _a[STATE_MONITORING] = [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING],
    _a));
var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
function isInCloseState(monitor) {
    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
}
/** @public */
exports.ServerMonitoringMode = Object.freeze({
    auto: 'auto',
    poll: 'poll',
    stream: 'stream'
});
/** @internal */
var Monitor = /** @class */ (function (_super) {
    __extends(Monitor, _super);
    function Monitor(server, options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this) || this;
        _this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;
        _this[kServer] = server;
        _this.connection = null;
        _this[kCancellationToken] = new mongo_types_1.CancellationToken();
        _this[kCancellationToken].setMaxListeners(Infinity);
        _this[kMonitorId] = undefined;
        _this.s = {
            state: common_1.STATE_CLOSED
        };
        _this.address = server.description.address;
        _this.options = Object.freeze({
            connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,
            heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,
            minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500,
            serverMonitoringMode: options.serverMonitoringMode
        });
        _this.isRunningInFaasEnv = client_metadata_1.getFAASEnv() != null;
        _this.mongoLogger = (_d = _this[kServer].topology.client) === null || _d === void 0 ? void 0 : _d.mongoLogger;
        _this.rttSampler = new RTTSampler(10);
        var cancellationToken = _this[kCancellationToken];
        // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration
        var connectOptions = __assign(__assign({ id: '<monitor>', generation: server.pool.generation, cancellationToken: cancellationToken, hostAddress: server.description.hostAddress }, options), { 
            // force BSON serialization options
            raw: false, useBigInt64: false, promoteLongs: true, promoteValues: true, promoteBuffers: true });
        // ensure no authentication is used for monitoring
        delete connectOptions.credentials;
        if (connectOptions.autoEncrypter) {
            delete connectOptions.autoEncrypter;
        }
        _this.connectOptions = Object.freeze(connectOptions);
        return _this;
    }
    Monitor.prototype.connect = function () {
        if (this.s.state !== common_1.STATE_CLOSED) {
            return;
        }
        // start
        var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = new MonitorInterval(monitorServer(this), {
            heartbeatFrequencyMS: heartbeatFrequencyMS,
            minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,
            immediate: true
        });
    };
    Monitor.prototype.requestCheck = function () {
        var _a;
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
            return;
        }
        (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();
    };
    Monitor.prototype.reset = function () {
        var topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
            return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        // restart monitor
        stateTransition(this, STATE_IDLE);
        // restart monitoring
        var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = new MonitorInterval(monitorServer(this), {
            heartbeatFrequencyMS: heartbeatFrequencyMS,
            minHeartbeatFrequencyMS: minHeartbeatFrequencyMS
        });
    };
    Monitor.prototype.close = function () {
        if (isInCloseState(this)) {
            return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        // close monitor
        this.emit('close');
        stateTransition(this, common_1.STATE_CLOSED);
    };
    Object.defineProperty(Monitor.prototype, "roundTripTime", {
        get: function () {
            return this.rttSampler.average();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Monitor.prototype, "minRoundTripTime", {
        get: function () {
            return this.rttSampler.min();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Monitor.prototype, "latestRtt", {
        get: function () {
            return this.rttSampler.last;
        },
        enumerable: false,
        configurable: true
    });
    Monitor.prototype.addRttSample = function (rtt) {
        this.rttSampler.addSample(rtt);
    };
    Monitor.prototype.clearRttSamples = function () {
        this.rttSampler.clear();
    };
    return Monitor;
}(mongo_types_1.TypedEventEmitter));
exports.Monitor = Monitor;
function resetMonitorState(monitor) {
    var _a, _b, _c;
    (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();
    monitor[kMonitorId] = undefined;
    (_b = monitor.rttPinger) === null || _b === void 0 ? void 0 : _b.close();
    monitor.rttPinger = undefined;
    monitor[kCancellationToken].emit('cancel');
    (_c = monitor.connection) === null || _c === void 0 ? void 0 : _c.destroy();
    monitor.connection = null;
    monitor.clearRttSamples();
}
function useStreamingProtocol(monitor, topologyVersion) {
    // If we have no topology version we always poll no matter
    // what the user provided, since the server does not support
    // the streaming protocol.
    if (topologyVersion == null)
        return false;
    var serverMonitoringMode = monitor.options.serverMonitoringMode;
    if (serverMonitoringMode === exports.ServerMonitoringMode.poll)
        return false;
    if (serverMonitoringMode === exports.ServerMonitoringMode.stream)
        return true;
    // If we are in auto mode, we need to figure out if we're in a FaaS
    // environment or not and choose the appropriate mode.
    if (monitor.isRunningInFaasEnv)
        return false;
    return true;
}
function checkServer(monitor, callback) {
    var _a;
    var _this = this;
    var start;
    var awaited;
    var topologyVersion = monitor[kServer].description.topologyVersion;
    var isAwaitable = useStreamingProtocol(monitor, topologyVersion);
    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
    function onHeartbeatFailed(err) {
        var _a;
        (_a = monitor.connection) === null || _a === void 0 ? void 0 : _a.destroy();
        monitor.connection = null;
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, utils_1.calculateDurationInMs(start), err, awaited));
        var error = !(err instanceof error_1.MongoError)
            ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err })
            : err;
        error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
        if (error instanceof error_1.MongoNetworkTimeoutError) {
            error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
        }
        monitor.emit('resetServer', error);
        callback(err);
    }
    function onHeartbeatSucceeded(hello) {
        var _a, _b;
        if (!('isWritablePrimary' in hello)) {
            // Provide hello-style response document.
            hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
        }
        // NOTE: here we use the latestRtt as this measurement corresponds with the value
        // obtained for this successful heartbeat, if there is no latestRtt, then we calculate the
        // duration
        var duration = isAwaitable && monitor.rttPinger
            ? ((_a = monitor.rttPinger.latestRtt) !== null && _a !== void 0 ? _a : utils_1.calculateDurationInMs(start))
            : utils_1.calculateDurationInMs(start);
        monitor.addRttSample(duration);
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
        if (isAwaitable) {
            // If we are using the streaming protocol then we immediately issue another 'started'
            // event, otherwise the "check" is complete and return to the main monitor loop
            monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
            // We have not actually sent an outgoing handshake, but when we get the next response we
            // want the duration to reflect the time since we last heard from the server
            start = utils_1.now();
        }
        else {
            (_b = monitor.rttPinger) === null || _b === void 0 ? void 0 : _b.close();
            monitor.rttPinger = undefined;
            callback(undefined, hello);
        }
    }
    var connection = monitor.connection;
    if (connection && !connection.closed) {
        var serverApi = connection.serverApi, helloOk = connection.helloOk;
        var connectTimeoutMS = monitor.options.connectTimeoutMS;
        var maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        var cmd = __assign((_a = {}, _a[(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND] = 1, _a), (isAwaitable && topologyVersion
            ? { maxAwaitTimeMS: maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }
            : {}));
        var options = isAwaitable
            ? {
                socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
                exhaustAllowed: true
            }
            : { socketTimeoutMS: connectTimeoutMS };
        if (isAwaitable && monitor.rttPinger == null) {
            monitor.rttPinger = new RTTPinger(monitor);
        }
        // Record new start time before sending handshake
        start = utils_1.now();
        if (isAwaitable) {
            awaited = true;
            return connection.exhaustCommand(utils_1.ns('admin.$cmd'), cmd, options, function (error, hello) {
                if (error)
                    return onHeartbeatFailed(error);
                return onHeartbeatSucceeded(hello);
            });
        }
        awaited = false;
        connection
            .command(utils_1.ns('admin.$cmd'), cmd, options)
            .then(onHeartbeatSucceeded, onHeartbeatFailed);
        return;
    }
    // connecting does an implicit `hello`
    (function () { return __awaiter(_this, void 0, void 0, function () {
        var socket, connection, error_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, connect_1.makeSocket(monitor.connectOptions)];
                case 1:
                    socket = _a.sent();
                    connection = connect_1.makeConnection(monitor.connectOptions, socket);
                    // The start time is after socket creation but before the handshake
                    start = utils_1.now();
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, connect_1.performInitialHandshake(connection, monitor.connectOptions)];
                case 3:
                    _a.sent();
                    return [2 /*return*/, connection];
                case 4:
                    error_2 = _a.sent();
                    connection.destroy();
                    throw error_2;
                case 5: return [2 /*return*/];
            }
        });
    }); })().then(function (connection) {
        var _a, _b;
        if (isInCloseState(monitor)) {
            connection.destroy();
            return;
        }
        var duration = utils_1.calculateDurationInMs(start);
        monitor.addRttSample(duration);
        monitor.connection = connection;
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, (_a = connection.hello) === null || _a === void 0 ? void 0 : _a.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection.hello, useStreamingProtocol(monitor, (_b = connection.hello) === null || _b === void 0 ? void 0 : _b.topologyVersion)));
        callback(undefined, connection.hello);
    }, function (error) {
        monitor.connection = null;
        awaited = false;
        onHeartbeatFailed(error);
    });
}
function monitorServer(monitor) {
    return function (callback) {
        if (monitor.s.state === STATE_MONITORING) {
            process.nextTick(callback);
            return;
        }
        stateTransition(monitor, STATE_MONITORING);
        function done() {
            if (!isInCloseState(monitor)) {
                stateTransition(monitor, STATE_IDLE);
            }
            callback();
        }
        checkServer(monitor, function (err, hello) {
            if (err) {
                // otherwise an error occurred on initial discovery, also bail
                if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
                    return done();
                }
            }
            // if the check indicates streaming is supported, immediately reschedule monitoring
            if (useStreamingProtocol(monitor, hello === null || hello === void 0 ? void 0 : hello.topologyVersion)) {
                timers_1.setTimeout(function () {
                    var _a;
                    if (!isInCloseState(monitor)) {
                        (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();
                    }
                }, 0);
            }
            done();
        });
    };
}
function makeTopologyVersion(tv) {
    return {
        processId: tv.processId,
        // tests mock counter as just number, but in a real situation counter should always be a Long
        // TODO(NODE-2674): Preserve int64 sent from MongoDB
        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
    };
}
/** @internal */
var RTTPinger = /** @class */ (function () {
    function RTTPinger(monitor) {
        var _this = this;
        var _a;
        this.connection = undefined;
        this[kCancellationToken] = monitor[kCancellationToken];
        this.closed = false;
        this.monitor = monitor;
        this.latestRtt = (_a = monitor.latestRtt) !== null && _a !== void 0 ? _a : undefined;
        var heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;
        this[kMonitorId] = timers_1.setTimeout(function () { return _this.measureRoundTripTime(); }, heartbeatFrequencyMS);
    }
    Object.defineProperty(RTTPinger.prototype, "roundTripTime", {
        get: function () {
            return this.monitor.roundTripTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RTTPinger.prototype, "minRoundTripTime", {
        get: function () {
            return this.monitor.minRoundTripTime;
        },
        enumerable: false,
        configurable: true
    });
    RTTPinger.prototype.close = function () {
        var _a;
        this.closed = true;
        timers_1.clearTimeout(this[kMonitorId]);
        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.destroy();
        this.connection = undefined;
    };
    RTTPinger.prototype.measureAndReschedule = function (start, conn) {
        var _this = this;
        if (this.closed) {
            conn === null || conn === void 0 ? void 0 : conn.destroy();
            return;
        }
        if (this.connection == null) {
            this.connection = conn;
        }
        this.latestRtt = utils_1.calculateDurationInMs(start);
        this[kMonitorId] = timers_1.setTimeout(function () { return _this.measureRoundTripTime(); }, this.monitor.options.heartbeatFrequencyMS);
    };
    RTTPinger.prototype.measureRoundTripTime = function () {
        var _a;
        var _this = this;
        var _b;
        var start = utils_1.now();
        if (this.closed) {
            return;
        }
        var connection = this.connection;
        if (connection == null) {
            connect_1.connect(this.monitor.connectOptions).then(function (connection) {
                _this.measureAndReschedule(start, connection);
            }, function () {
                _this.connection = undefined;
            });
            return;
        }
        var commandName = ((_b = connection.serverApi) === null || _b === void 0 ? void 0 : _b.version) || connection.helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND;
        connection.command(utils_1.ns('admin.$cmd'), (_a = {}, _a[commandName] = 1, _a), undefined).then(function () { return _this.measureAndReschedule(start); }, function () {
            var _a;
            (_a = _this.connection) === null || _a === void 0 ? void 0 : _a.destroy();
            _this.connection = undefined;
            return;
        });
    };
    return RTTPinger;
}());
exports.RTTPinger = RTTPinger;
/**
 * @internal
 */
var MonitorInterval = /** @class */ (function () {
    function MonitorInterval(fn, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var _a, _b;
        this.isExpeditedCallToFnScheduled = false;
        this.stopped = false;
        this.isExecutionInProgress = false;
        this.hasExecutedOnce = false;
        this._executeAndReschedule = function () {
            if (_this.stopped)
                return;
            if (_this.timerId) {
                timers_1.clearTimeout(_this.timerId);
            }
            _this.isExpeditedCallToFnScheduled = false;
            _this.isExecutionInProgress = true;
            _this.fn(function () {
                _this.lastExecutionEnded = utils_1.now();
                _this.isExecutionInProgress = false;
                _this._reschedule(_this.heartbeatFrequencyMS);
            });
        };
        this.fn = fn;
        this.lastExecutionEnded = -Infinity;
        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 1000;
        this.minHeartbeatFrequencyMS = (_b = options.minHeartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 500;
        if (options.immediate) {
            this._executeAndReschedule();
        }
        else {
            this._reschedule(undefined);
        }
    }
    MonitorInterval.prototype.wake = function () {
        var currentTime = utils_1.now();
        var timeSinceLastCall = currentTime - this.lastExecutionEnded;
        // TODO(NODE-4674): Add error handling and logging to the monitor
        if (timeSinceLastCall < 0) {
            return this._executeAndReschedule();
        }
        if (this.isExecutionInProgress) {
            return;
        }
        // debounce multiple calls to wake within the `minInterval`
        if (this.isExpeditedCallToFnScheduled) {
            return;
        }
        // reschedule a call as soon as possible, ensuring the call never happens
        // faster than the `minInterval`
        if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
            this.isExpeditedCallToFnScheduled = true;
            this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
            return;
        }
        this._executeAndReschedule();
    };
    MonitorInterval.prototype.stop = function () {
        this.stopped = true;
        if (this.timerId) {
            timers_1.clearTimeout(this.timerId);
            this.timerId = undefined;
        }
        this.lastExecutionEnded = -Infinity;
        this.isExpeditedCallToFnScheduled = false;
    };
    MonitorInterval.prototype.toString = function () {
        return JSON.stringify(this);
    };
    MonitorInterval.prototype.toJSON = function () {
        var currentTime = utils_1.now();
        var timeSinceLastCall = currentTime - this.lastExecutionEnded;
        return {
            timerId: this.timerId != null ? 'set' : 'cleared',
            lastCallTime: this.lastExecutionEnded,
            isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
            stopped: this.stopped,
            heartbeatFrequencyMS: this.heartbeatFrequencyMS,
            minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
            currentTime: currentTime,
            timeSinceLastCall: timeSinceLastCall
        };
    };
    MonitorInterval.prototype._reschedule = function (ms) {
        if (this.stopped)
            return;
        if (this.timerId) {
            timers_1.clearTimeout(this.timerId);
        }
        this.timerId = timers_1.setTimeout(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
    };
    return MonitorInterval;
}());
exports.MonitorInterval = MonitorInterval;
/** @internal
 * This class implements the RTT sampling logic specified for [CSOT](https://github.com/mongodb/specifications/blob/bbb335e60cd7ea1e0f7cd9a9443cb95fc9d3b64d/source/client-side-operations-timeout/client-side-operations-timeout.md#drivers-use-minimum-rtt-to-short-circuit-operations)
 *
 * This is implemented as a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) keeping
 * the most recent `windowSize` samples
 * */
var RTTSampler = /** @class */ (function () {
    function RTTSampler(windowSize) {
        if (windowSize === void 0) { windowSize = 10; }
        this.rttSamples = new Float64Array(windowSize);
        this.length = 0;
        this.writeIndex = 0;
    }
    /**
     * Adds an rtt sample to the end of the circular buffer
     * When `windowSize` samples have been collected, `addSample` overwrites the least recently added
     * sample
     */
    RTTSampler.prototype.addSample = function (sample) {
        this.rttSamples[this.writeIndex++] = sample;
        if (this.length < this.rttSamples.length) {
            this.length++;
        }
        this.writeIndex %= this.rttSamples.length;
    };
    /**
     * When \< 2 samples have been collected, returns 0
     * Otherwise computes the minimum value samples contained in the buffer
     */
    RTTSampler.prototype.min = function () {
        if (this.length < 2)
            return 0;
        var min = this.rttSamples[0];
        for (var i = 1; i < this.length; i++) {
            if (this.rttSamples[i] < min)
                min = this.rttSamples[i];
        }
        return min;
    };
    /**
     * Returns mean of samples contained in the buffer
     */
    RTTSampler.prototype.average = function () {
        if (this.length === 0)
            return 0;
        var sum = 0;
        for (var i = 0; i < this.length; i++) {
            sum += this.rttSamples[i];
        }
        return sum / this.length;
    };
    Object.defineProperty(RTTSampler.prototype, "last", {
        /**
         * Returns most recently inserted element in the buffer
         * Returns null if the buffer is empty
         * */
        get: function () {
            if (this.length === 0)
                return null;
            return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clear the buffer
     * NOTE: this does not overwrite the data held in the internal array, just the pointers into
     * this array
     */
    RTTSampler.prototype.clear = function () {
        this.length = 0;
        this.writeIndex = 0;
    };
    return RTTSampler;
}());
exports.RTTSampler = RTTSampler;
