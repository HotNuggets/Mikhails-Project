"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.OpCompressedRequest = exports.OpMsgResponse = exports.OpMsgRequest = exports.DocumentSequence = exports.OpReply = exports.OpQueryRequest = void 0;
var BSON = require("../bson");
var error_1 = require("../error");
var compression_1 = require("./wire_protocol/compression");
var constants_1 = require("./wire_protocol/constants");
// Incrementing request id
var _requestId = 0;
// Query flags
var OPTS_TAILABLE_CURSOR = 2;
var OPTS_SECONDARY = 4;
var OPTS_OPLOG_REPLAY = 8;
var OPTS_NO_CURSOR_TIMEOUT = 16;
var OPTS_AWAIT_DATA = 32;
var OPTS_EXHAUST = 64;
var OPTS_PARTIAL = 128;
// Response flags
var CURSOR_NOT_FOUND = 1;
var QUERY_FAILURE = 2;
var SHARD_CONFIG_STALE = 4;
var AWAIT_CAPABLE = 8;
var encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;
/** @internal */
var OpQueryRequest = /** @class */ (function () {
    function OpQueryRequest(databaseName, query, options) {
        var _a;
        this.databaseName = databaseName;
        this.query = query;
        /** moreToCome is an OP_MSG only concept */
        this.moreToCome = false;
        // Basic options needed to be passed in
        // TODO(NODE-3483): Replace with MongoCommandError
        var ns = databaseName + ".$cmd";
        if (typeof databaseName !== 'string') {
            throw new error_1.MongoRuntimeError('Database name must be a string for a query');
        }
        // TODO(NODE-3483): Replace with MongoCommandError
        if (query == null)
            throw new error_1.MongoRuntimeError('A query document must be specified for query');
        // Validate that we are not passing 0x00 in the collection name
        if (ns.indexOf('\x00') !== -1) {
            // TODO(NODE-3483): Use MongoNamespace static method
            throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');
        }
        // Basic options
        this.ns = ns;
        // Additional options
        this.numberToSkip = options.numberToSkip || 0;
        this.numberToReturn = options.numberToReturn || 0;
        this.returnFieldSelector = options.returnFieldSelector || undefined;
        this.requestId = (_a = options.requestId) !== null && _a !== void 0 ? _a : OpQueryRequest.getRequestId();
        // special case for pre-3.2 find commands, delete ASAP
        this.pre32Limit = options.pre32Limit;
        // Serialization option
        this.serializeFunctions =
            typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
        this.ignoreUndefined =
            typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
        this.batchSize = this.numberToReturn;
        // Flags
        this.tailable = false;
        this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;
        this.oplogReplay = false;
        this.noCursorTimeout = false;
        this.awaitData = false;
        this.exhaust = false;
        this.partial = false;
    }
    /** Assign next request Id. */
    OpQueryRequest.prototype.incRequestId = function () {
        this.requestId = _requestId++;
    };
    /** Peek next request Id. */
    OpQueryRequest.prototype.nextRequestId = function () {
        return _requestId + 1;
    };
    /** Increment then return next request Id. */
    OpQueryRequest.getRequestId = function () {
        return ++_requestId;
    };
    // Uses a single allocated buffer for the process, avoiding multiple memory allocations
    OpQueryRequest.prototype.toBin = function () {
        var buffers = [];
        var projection = null;
        // Set up the flags
        var flags = 0;
        if (this.tailable) {
            flags |= OPTS_TAILABLE_CURSOR;
        }
        if (this.secondaryOk) {
            flags |= OPTS_SECONDARY;
        }
        if (this.oplogReplay) {
            flags |= OPTS_OPLOG_REPLAY;
        }
        if (this.noCursorTimeout) {
            flags |= OPTS_NO_CURSOR_TIMEOUT;
        }
        if (this.awaitData) {
            flags |= OPTS_AWAIT_DATA;
        }
        if (this.exhaust) {
            flags |= OPTS_EXHAUST;
        }
        if (this.partial) {
            flags |= OPTS_PARTIAL;
        }
        // If batchSize is different to this.numberToReturn
        if (this.batchSize !== this.numberToReturn)
            this.numberToReturn = this.batchSize;
        // Allocate write protocol header buffer
        var header = Buffer.alloc(4 * 4 + // Header
            4 + // Flags
            Buffer.byteLength(this.ns) +
            1 + // namespace
            4 + // numberToSkip
            4 // numberToReturn
        );
        // Add header to buffers
        buffers.push(header);
        // Serialize the query
        var query = BSON.serialize(this.query, {
            checkKeys: this.checkKeys,
            serializeFunctions: this.serializeFunctions,
            ignoreUndefined: this.ignoreUndefined
        });
        // Add query document
        buffers.push(query);
        if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
            // Serialize the projection document
            projection = BSON.serialize(this.returnFieldSelector, {
                checkKeys: this.checkKeys,
                serializeFunctions: this.serializeFunctions,
                ignoreUndefined: this.ignoreUndefined
            });
            // Add projection document
            buffers.push(projection);
        }
        // Total message size
        var totalLength = header.length + query.length + (projection ? projection.length : 0);
        // Set up the index
        var index = 4;
        // Write total document length
        header[3] = (totalLength >> 24) & 0xff;
        header[2] = (totalLength >> 16) & 0xff;
        header[1] = (totalLength >> 8) & 0xff;
        header[0] = totalLength & 0xff;
        // Write header information requestId
        header[index + 3] = (this.requestId >> 24) & 0xff;
        header[index + 2] = (this.requestId >> 16) & 0xff;
        header[index + 1] = (this.requestId >> 8) & 0xff;
        header[index] = this.requestId & 0xff;
        index = index + 4;
        // Write header information responseTo
        header[index + 3] = (0 >> 24) & 0xff;
        header[index + 2] = (0 >> 16) & 0xff;
        header[index + 1] = (0 >> 8) & 0xff;
        header[index] = 0 & 0xff;
        index = index + 4;
        // Write header information OP_QUERY
        header[index + 3] = (constants_1.OP_QUERY >> 24) & 0xff;
        header[index + 2] = (constants_1.OP_QUERY >> 16) & 0xff;
        header[index + 1] = (constants_1.OP_QUERY >> 8) & 0xff;
        header[index] = constants_1.OP_QUERY & 0xff;
        index = index + 4;
        // Write header information flags
        header[index + 3] = (flags >> 24) & 0xff;
        header[index + 2] = (flags >> 16) & 0xff;
        header[index + 1] = (flags >> 8) & 0xff;
        header[index] = flags & 0xff;
        index = index + 4;
        // Write collection name
        index = index + header.write(this.ns, index, 'utf8') + 1;
        header[index - 1] = 0;
        // Write header information flags numberToSkip
        header[index + 3] = (this.numberToSkip >> 24) & 0xff;
        header[index + 2] = (this.numberToSkip >> 16) & 0xff;
        header[index + 1] = (this.numberToSkip >> 8) & 0xff;
        header[index] = this.numberToSkip & 0xff;
        index = index + 4;
        // Write header information flags numberToReturn
        header[index + 3] = (this.numberToReturn >> 24) & 0xff;
        header[index + 2] = (this.numberToReturn >> 16) & 0xff;
        header[index + 1] = (this.numberToReturn >> 8) & 0xff;
        header[index] = this.numberToReturn & 0xff;
        index = index + 4;
        // Return the buffers
        return buffers;
    };
    return OpQueryRequest;
}());
exports.OpQueryRequest = OpQueryRequest;
/** @internal */
var OpReply = /** @class */ (function () {
    function OpReply(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
        /** moreToCome is an OP_MSG only concept */
        this.moreToCome = false;
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts !== null && opts !== void 0 ? opts : {
            useBigInt64: false,
            promoteLongs: true,
            promoteValues: true,
            promoteBuffers: false,
            bsonRegExp: false
        };
        // Read the message header
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        // Flag values
        this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;
        this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
        this.promoteValues =
            typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
        this.promoteBuffers =
            typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
    }
    OpReply.prototype.isParsed = function () {
        return this.parsed;
    };
    OpReply.prototype.parse = function () {
        // Don't parse again if not needed
        if (this.parsed)
            return this.sections[0];
        // Position within OP_REPLY at which documents start
        // (See https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#wire-op-reply)
        this.index = 20;
        // Read the message body
        this.responseFlags = this.data.readInt32LE(0);
        this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
        this.startingFrom = this.data.readInt32LE(12);
        this.numberReturned = this.data.readInt32LE(16);
        if (this.numberReturned < 0 || this.numberReturned > Math.pow(2, 32) - 1) {
            throw new RangeError("OP_REPLY numberReturned is an invalid array length " + this.numberReturned);
        }
        this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
        this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
        this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
        this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
        // Parse Body
        for (var i = 0; i < this.numberReturned; i++) {
            var bsonSize = this.data[this.index] |
                (this.data[this.index + 1] << 8) |
                (this.data[this.index + 2] << 16) |
                (this.data[this.index + 3] << 24);
            var section = this.data.subarray(this.index, this.index + bsonSize);
            this.sections.push(section);
            // Adjust the index
            this.index = this.index + bsonSize;
        }
        // Set parsed
        this.parsed = true;
        return this.sections[0];
    };
    return OpReply;
}());
exports.OpReply = OpReply;
// Msg Flags
var OPTS_CHECKSUM_PRESENT = 1;
var OPTS_MORE_TO_COME = 2;
var OPTS_EXHAUST_ALLOWED = 1 << 16;
/** @internal */
var DocumentSequence = /** @class */ (function () {
    /**
     * Create a new document sequence for the provided field.
     * @param field - The field it will replace.
     */
    function DocumentSequence(field, documents) {
        this.field = field;
        this.documents = [];
        this.chunks = [];
        this.serializedDocumentsLength = 0;
        // Document sequences starts with type 1 at the first byte.
        // Field strings must always be UTF-8.
        var buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);
        buffer[0] = 1;
        // Third part is the field name at offset 5 with trailing null byte.
        encodeUTF8Into(buffer, this.field + "\0", 5);
        this.chunks.push(buffer);
        this.header = buffer;
        if (documents) {
            for (var _i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
                var doc = documents_1[_i];
                this.push(doc, BSON.serialize(doc));
            }
        }
    }
    /**
     * Push a document to the document sequence. Will serialize the document
     * as well and return the current serialized length of all documents.
     * @param document - The document to add.
     * @param buffer - The serialized document in raw BSON.
     * @returns The new total document sequence length.
     */
    DocumentSequence.prototype.push = function (document, buffer) {
        var _a;
        this.serializedDocumentsLength += buffer.length;
        // Push the document.
        this.documents.push(document);
        // Push the document raw bson.
        this.chunks.push(buffer);
        // Write the new length.
        (_a = this.header) === null || _a === void 0 ? void 0 : _a.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);
        return this.serializedDocumentsLength + this.header.length;
    };
    /**
     * Get the fully serialized bytes for the document sequence section.
     * @returns The section bytes.
     */
    DocumentSequence.prototype.toBin = function () {
        return Buffer.concat(this.chunks);
    };
    return DocumentSequence;
}());
exports.DocumentSequence = DocumentSequence;
/** @internal */
var OpMsgRequest = /** @class */ (function () {
    function OpMsgRequest(databaseName, command, options) {
        var _a, _b;
        this.databaseName = databaseName;
        this.command = command;
        this.options = options;
        // Basic options needed to be passed in
        if (command == null)
            throw new error_1.MongoInvalidArgumentError('Query document must be specified for query');
        // Basic options
        this.command.$db = databaseName;
        // Ensure empty options
        this.options = options !== null && options !== void 0 ? options : {};
        // Additional options
        this.requestId = options.requestId ? options.requestId : OpMsgRequest.getRequestId();
        // Serialization option
        this.serializeFunctions =
            typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
        this.ignoreUndefined =
            typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
        this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        // flags
        this.checksumPresent = false;
        this.moreToCome = (_a = options.moreToCome) !== null && _a !== void 0 ? _a : ((_b = command.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0;
        this.exhaustAllowed =
            typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;
    }
    OpMsgRequest.prototype.toBin = function () {
        var buffers = [];
        var flags = 0;
        if (this.checksumPresent) {
            flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
            flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
            flags |= OPTS_EXHAUST_ALLOWED;
        }
        var header = Buffer.alloc(4 * 4 + // Header
            4 // Flags
        );
        buffers.push(header);
        var totalLength = header.length;
        var command = this.command;
        totalLength += this.makeSections(buffers, command);
        header.writeInt32LE(totalLength, 0); // messageLength
        header.writeInt32LE(this.requestId, 4); // requestID
        header.writeInt32LE(0, 8); // responseTo
        header.writeInt32LE(constants_1.OP_MSG, 12); // opCode
        header.writeUInt32LE(flags, 16); // flags
        return buffers;
    };
    /**
     * Add the sections to the OP_MSG request's buffers and returns the length.
     */
    OpMsgRequest.prototype.makeSections = function (buffers, document) {
        var sequencesBuffer = this.extractDocumentSequences(document);
        var payloadTypeBuffer = Buffer.allocUnsafe(1);
        payloadTypeBuffer[0] = 0;
        var documentBuffer = this.serializeBson(document);
        // First section, type 0
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        // Subsequent sections, type 1
        buffers.push(sequencesBuffer);
        return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
    };
    /**
     * Extracts the document sequences from the command document and returns
     * a buffer to be added as multiple sections after the initial type 0
     * section in the message.
     */
    OpMsgRequest.prototype.extractDocumentSequences = function (document) {
        // Pull out any field in the command document that's value is a document sequence.
        var chunks = [];
        for (var _i = 0, _a = Object.entries(document); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (value instanceof DocumentSequence) {
                chunks.push(value.toBin());
                // Why are we removing the field from the command? This is because it needs to be
                // removed in the OP_MSG request first section, and DocumentSequence is not a
                // BSON type and is specific to the MongoDB wire protocol so there's nothing
                // our BSON serializer can do about this. Since DocumentSequence is not exposed
                // in the public API and only used internally, we are never mutating an original
                // command provided by the user, just our own, and it's cheaper to delete from
                // our own command than copying it.
                delete document[key];
            }
        }
        if (chunks.length > 0) {
            return Buffer.concat(chunks);
        }
        // If we have no document sequences we return an empty buffer for nothing to add
        // to the payload.
        return Buffer.alloc(0);
    };
    OpMsgRequest.prototype.serializeBson = function (document) {
        return BSON.serialize(document, {
            checkKeys: this.checkKeys,
            serializeFunctions: this.serializeFunctions,
            ignoreUndefined: this.ignoreUndefined
        });
    };
    OpMsgRequest.getRequestId = function () {
        _requestId = (_requestId + 1) & 0x7fffffff;
        return _requestId;
    };
    return OpMsgRequest;
}());
exports.OpMsgRequest = OpMsgRequest;
/** @internal */
var OpMsgResponse = /** @class */ (function () {
    function OpMsgResponse(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts !== null && opts !== void 0 ? opts : {
            useBigInt64: false,
            promoteLongs: true,
            promoteValues: true,
            promoteBuffers: false,
            bsonRegExp: false
        };
        // Read the message header
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        // Read response flags
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;
        this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
        this.promoteValues =
            typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
        this.promoteBuffers =
            typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
    }
    OpMsgResponse.prototype.isParsed = function () {
        return this.parsed;
    };
    OpMsgResponse.prototype.parse = function () {
        // Don't parse again if not needed
        if (this.parsed)
            return this.sections[0];
        this.index = 4;
        while (this.index < this.data.length) {
            var payloadType = this.data.readUInt8(this.index++);
            if (payloadType === 0) {
                var bsonSize = this.data.readUInt32LE(this.index);
                var bin = this.data.subarray(this.index, this.index + bsonSize);
                this.sections.push(bin);
                this.index += bsonSize;
            }
            else if (payloadType === 1) {
                // It was decided that no driver makes use of payload type 1
                // TODO(NODE-3483): Replace with MongoDeprecationError
                throw new error_1.MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');
            }
        }
        this.parsed = true;
        return this.sections[0];
    };
    return OpMsgResponse;
}());
exports.OpMsgResponse = OpMsgResponse;
var MESSAGE_HEADER_SIZE = 16;
var COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID
/**
 * @internal
 *
 * An OP_COMPRESSED request wraps either an OP_QUERY or OP_MSG message.
 */
var OpCompressedRequest = /** @class */ (function () {
    function OpCompressedRequest(command, options) {
        this.command = command;
        this.options = options;
    }
    // Return whether a command contains an uncompressible command term
    // Will return true if command contains no uncompressible command terms
    OpCompressedRequest.canCompress = function (command) {
        var commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
        var commandName = Object.keys(commandDoc)[0];
        return !compression_1.uncompressibleCommands.has(commandName);
    };
    OpCompressedRequest.prototype.toBin = function () {
        return __awaiter(this, void 0, Promise, function () {
            var concatenatedOriginalCommandBuffer, messageToBeCompressed, originalCommandOpCode, compressedMessage, msgHeader, compressionDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
                        messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
                        originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
                        return [4 /*yield*/, compression_1.compress(this.options, messageToBeCompressed)];
                    case 1:
                        compressedMessage = _a.sent();
                        msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
                        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength
                        msgHeader.writeInt32LE(this.command.requestId, 4); // requestID
                        msgHeader.writeInt32LE(0, 8); // responseTo (zero)
                        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode
                        compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
                        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode
                        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader
                        compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8); // compressorID
                        return [2 /*return*/, [msgHeader, compressionDetails, compressedMessage]];
                }
            });
        });
    };
    return OpCompressedRequest;
}());
exports.OpCompressedRequest = OpCompressedRequest;
