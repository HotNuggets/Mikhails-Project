'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var get = require('../get');

var utils = require('../../utils');
/**
 * Given a Mongoose index definition (key + options objects) and a MongoDB server
 * index definition, determine if the two indexes are equal.
 *
 * @param {Object} schemaIndexKeysObject the Mongoose index spec
 * @param {Object} options the Mongoose index definition's options
 * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`
 * @api private
 */


module.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {
  // Special case: text indexes have a special format in the db. For example,
  // `{ name: 'text' }` becomes:
  // {
  //   v: 2,
  //   key: { _fts: 'text', _ftsx: 1 },
  //   name: 'name_text',
  //   ns: 'test.tests',
  //   background: true,
  //   weights: { name: 1 },
  //   default_language: 'english',
  //   language_override: 'language',
  //   textIndexVersion: 3
  // }
  if (dbIndex.textIndexVersion != null) {
    delete dbIndex.key._fts;
    delete dbIndex.key._ftsx;

    var weights = _objectSpread({}, dbIndex.weights, {}, dbIndex.key);

    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {
      return false;
    }

    for (var _i = 0, _Object$keys = Object.keys(weights); _i < _Object$keys.length; _i++) {
      var prop = _Object$keys[_i];

      if (!(prop in schemaIndexKeysObject)) {
        return false;
      }

      var weight = weights[prop];

      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {
        return false;
      }
    }

    if (options['default_language'] !== dbIndex['default_language']) {
      return dbIndex['default_language'] === 'english' && options['default_language'] == null;
    }

    return true;
  }

  var optionKeys = ['unique', 'partialFilterExpression', 'sparse', 'expireAfterSeconds', 'collation'];

  for (var _i2 = 0, _optionKeys = optionKeys; _i2 < _optionKeys.length; _i2++) {
    var key = _optionKeys[_i2];

    if (!(key in options) && !(key in dbIndex)) {
      continue;
    }

    if (key === 'collation') {
      if (options[key] == null || dbIndex[key] == null) {
        return options[key] == null && dbIndex[key] == null;
      }

      var definedKeys = Object.keys(options.collation);
      var schemaCollation = options.collation;
      var dbCollation = dbIndex.collation;

      for (var _i3 = 0, _definedKeys = definedKeys; _i3 < _definedKeys.length; _i3++) {
        var opt = _definedKeys[_i3];

        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
          return false;
        }
      }
    } else if (!utils.deepEqual(options[key], dbIndex[key])) {
      return false;
    }
  }

  var schemaIndexKeys = Object.keys(schemaIndexKeysObject);
  var dbIndexKeys = Object.keys(dbIndex.key);

  if (schemaIndexKeys.length !== dbIndexKeys.length) {
    return false;
  }

  for (var i = 0; i < schemaIndexKeys.length; ++i) {
    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
      return false;
    }

    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
      return false;
    }
  }

  return true;
};