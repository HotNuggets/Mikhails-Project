"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.BulkOperationBase = exports.BulkWriteShimOperation = exports.FindOperators = exports.MongoBulkWriteError = exports.mergeBatchResults = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;
var bson_1 = require("../bson");
var error_1 = require("../error");
var delete_1 = require("../operations/delete");
var execute_operation_1 = require("../operations/execute_operation");
var insert_1 = require("../operations/insert");
var operation_1 = require("../operations/operation");
var update_1 = require("../operations/update");
var utils_1 = require("../utils");
var write_concern_1 = require("../write_concern");
/** @internal */
var kServerError = Symbol('serverError');
/** @public */
exports.BatchType = Object.freeze({
    INSERT: 1,
    UPDATE: 2,
    DELETE: 3
});
/**
 * Keeps the state of a unordered batch so we can rewrite the results
 * correctly after command execution
 *
 * @public
 */
var Batch = /** @class */ (function () {
    function Batch(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
    }
    return Batch;
}());
exports.Batch = Batch;
/**
 * @public
 * The result of a bulk write.
 */
var BulkWriteResult = /** @class */ (function () {
    /**
     * Create a new BulkWriteResult instance
     * @internal
     */
    function BulkWriteResult(bulkResult, isOrdered) {
        var _a, _b, _c, _d, _e;
        this.result = bulkResult;
        this.insertedCount = (_a = this.result.nInserted) !== null && _a !== void 0 ? _a : 0;
        this.matchedCount = (_b = this.result.nMatched) !== null && _b !== void 0 ? _b : 0;
        this.modifiedCount = (_c = this.result.nModified) !== null && _c !== void 0 ? _c : 0;
        this.deletedCount = (_d = this.result.nRemoved) !== null && _d !== void 0 ? _d : 0;
        this.upsertedCount = (_e = this.result.upserted.length) !== null && _e !== void 0 ? _e : 0;
        this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
        this.insertedIds = BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
        Object.defineProperty(this, 'result', { value: this.result, enumerable: false });
    }
    BulkWriteResult.generateIdMap = function (ids) {
        var idMap = {};
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var doc = ids_1[_i];
            idMap[doc.index] = doc._id;
        }
        return idMap;
    };
    Object.defineProperty(BulkWriteResult.prototype, "ok", {
        /** Evaluates to true if the bulk operation correctly executes */
        get: function () {
            return this.result.ok;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns document_ids that were actually inserted
     * @internal
     */
    BulkWriteResult.prototype.getSuccessfullyInsertedIds = function (bulkResult, isOrdered) {
        if (bulkResult.writeErrors.length === 0)
            return bulkResult.insertedIds;
        if (isOrdered) {
            return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
        }
        return bulkResult.insertedIds.filter(function (_a) {
            var index = _a.index;
            return !bulkResult.writeErrors.some(function (writeError) { return index === writeError.index; });
        });
    };
    /** Returns the upserted id at the given index */
    BulkWriteResult.prototype.getUpsertedIdAt = function (index) {
        return this.result.upserted[index];
    };
    /** Returns raw internal result */
    BulkWriteResult.prototype.getRawResponse = function () {
        return this.result;
    };
    /** Returns true if the bulk operation contains a write error */
    BulkWriteResult.prototype.hasWriteErrors = function () {
        return this.result.writeErrors.length > 0;
    };
    /** Returns the number of write errors off the bulk operation */
    BulkWriteResult.prototype.getWriteErrorCount = function () {
        return this.result.writeErrors.length;
    };
    /** Returns a specific write error object */
    BulkWriteResult.prototype.getWriteErrorAt = function (index) {
        return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    };
    /** Retrieve all write errors */
    BulkWriteResult.prototype.getWriteErrors = function () {
        return this.result.writeErrors;
    };
    /** Retrieve the write concern error if one exists */
    BulkWriteResult.prototype.getWriteConcernError = function () {
        if (this.result.writeConcernErrors.length === 0) {
            return;
        }
        else if (this.result.writeConcernErrors.length === 1) {
            // Return the error
            return this.result.writeConcernErrors[0];
        }
        else {
            // Combine the errors
            var errmsg = '';
            for (var i = 0; i < this.result.writeConcernErrors.length; i++) {
                var err = this.result.writeConcernErrors[i];
                errmsg = errmsg + err.errmsg;
                // TODO: Something better
                if (i === 0)
                    errmsg = errmsg + ' and ';
            }
            return new WriteConcernError({ errmsg: errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });
        }
    };
    BulkWriteResult.prototype.toString = function () {
        return "BulkWriteResult(" + bson_1.EJSON.stringify(this.result) + ")";
    };
    BulkWriteResult.prototype.isOk = function () {
        return this.result.ok === 1;
    };
    return BulkWriteResult;
}());
exports.BulkWriteResult = BulkWriteResult;
/**
 * An error representing a failure by the server to apply the requested write concern to the bulk operation.
 * @public
 * @category Error
 */
var WriteConcernError = /** @class */ (function () {
    function WriteConcernError(error) {
        this[kServerError] = error;
    }
    Object.defineProperty(WriteConcernError.prototype, "code", {
        /** Write concern error code. */
        get: function () {
            return this[kServerError].code;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WriteConcernError.prototype, "errmsg", {
        /** Write concern error message. */
        get: function () {
            return this[kServerError].errmsg;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WriteConcernError.prototype, "errInfo", {
        /** Write concern error info. */
        get: function () {
            return this[kServerError].errInfo;
        },
        enumerable: false,
        configurable: true
    });
    WriteConcernError.prototype.toJSON = function () {
        return this[kServerError];
    };
    WriteConcernError.prototype.toString = function () {
        return "WriteConcernError(" + this.errmsg + ")";
    };
    return WriteConcernError;
}());
exports.WriteConcernError = WriteConcernError;
/**
 * An error that occurred during a BulkWrite on the server.
 * @public
 * @category Error
 */
var WriteError = /** @class */ (function () {
    function WriteError(err) {
        this.err = err;
    }
    Object.defineProperty(WriteError.prototype, "code", {
        /** WriteError code. */
        get: function () {
            return this.err.code;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WriteError.prototype, "index", {
        /** WriteError original bulk operation index. */
        get: function () {
            return this.err.index;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WriteError.prototype, "errmsg", {
        /** WriteError message. */
        get: function () {
            return this.err.errmsg;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WriteError.prototype, "errInfo", {
        /** WriteError details. */
        get: function () {
            return this.err.errInfo;
        },
        enumerable: false,
        configurable: true
    });
    /** Returns the underlying operation that caused the error */
    WriteError.prototype.getOperation = function () {
        return this.err.op;
    };
    WriteError.prototype.toJSON = function () {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
    };
    WriteError.prototype.toString = function () {
        return "WriteError(" + JSON.stringify(this.toJSON()) + ")";
    };
    return WriteError;
}());
exports.WriteError = WriteError;
/** Merges results into shared data structure */
function mergeBatchResults(batch, bulkResult, err, result) {
    // If we have an error set the result to be the err object
    if (err) {
        result = err;
    }
    else if (result && result.result) {
        result = result.result;
    }
    if (result == null) {
        return;
    }
    // Do we have a top level error stop processing and return
    if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        var writeError = {
            index: 0,
            code: result.code || 0,
            errmsg: result.message,
            errInfo: result.errInfo,
            op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
    }
    else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
    }
    // If we have an insert Batch type
    if (isInsertBatch(batch) && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    // If we have an insert Batch type
    if (isDeleteBatch(batch) && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    var nUpserted = 0;
    // We have an array of upserted values, we need to rewrite the indexes
    if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (var i = 0; i < result.upserted.length; i++) {
            bulkResult.upserted.push({
                index: result.upserted[i].index + batch.originalZeroIndex,
                _id: result.upserted[i]._id
            });
        }
    }
    else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
            index: batch.originalZeroIndex,
            _id: result.upserted
        });
    }
    // If we have an update Batch type
    if (isUpdateBatch(batch) && result.n) {
        var nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === 'number') {
            bulkResult.nModified = bulkResult.nModified + nModified;
        }
        else {
            bulkResult.nModified = 0;
        }
    }
    if (Array.isArray(result.writeErrors)) {
        for (var i = 0; i < result.writeErrors.length; i++) {
            var writeError = {
                index: batch.originalIndexes[result.writeErrors[i].index],
                code: result.writeErrors[i].code,
                errmsg: result.writeErrors[i].errmsg,
                errInfo: result.writeErrors[i].errInfo,
                op: batch.operations[result.writeErrors[i].index]
            };
            bulkResult.writeErrors.push(new WriteError(writeError));
        }
    }
    if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
}
exports.mergeBatchResults = mergeBatchResults;
function executeCommands(bulkOperation, options) {
    return __awaiter(this, void 0, Promise, function () {
        var _i, _a, batch, finalOptions, operation, thrownError, result, error_2, writeResult_1, writeResult_2, writeResult;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (bulkOperation.s.batches.length === 0) {
                        return [2 /*return*/, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered)];
                    }
                    _i = 0, _a = bulkOperation.s.batches;
                    _b.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 7];
                    batch = _a[_i];
                    finalOptions = utils_1.resolveOptions(bulkOperation, __assign(__assign({}, options), { ordered: bulkOperation.isOrdered }));
                    if (finalOptions.bypassDocumentValidation !== true) {
                        delete finalOptions.bypassDocumentValidation;
                    }
                    // Is the bypassDocumentValidation options specific
                    if (bulkOperation.s.bypassDocumentValidation === true) {
                        finalOptions.bypassDocumentValidation = true;
                    }
                    // Is the checkKeys option disabled
                    if (bulkOperation.s.checkKeys === false) {
                        finalOptions.checkKeys = false;
                    }
                    if (finalOptions.retryWrites) {
                        if (isUpdateBatch(batch)) {
                            finalOptions.retryWrites =
                                finalOptions.retryWrites && !batch.operations.some(function (op) { return op.multi; });
                        }
                        if (isDeleteBatch(batch)) {
                            finalOptions.retryWrites =
                                finalOptions.retryWrites && !batch.operations.some(function (op) { return op.limit === 0; });
                        }
                    }
                    operation = isInsertBatch(batch)
                        ? new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions)
                        : isUpdateBatch(batch)
                            ? new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions)
                            : isDeleteBatch(batch)
                                ? new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions)
                                : null;
                    if (operation == null)
                        throw new error_1.MongoRuntimeError("Unknown batchType: " + batch.batchType);
                    thrownError = null;
                    result = void 0;
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, execute_operation_1.executeOperation(bulkOperation.s.collection.client, operation)];
                case 3:
                    result = _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    error_2 = _b.sent();
                    thrownError = error_2;
                    return [3 /*break*/, 5];
                case 5:
                    if (thrownError != null) {
                        if (thrownError instanceof error_1.MongoWriteConcernError) {
                            mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
                            writeResult_1 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
                            throw new MongoBulkWriteError({
                                message: thrownError.result.writeConcernError.errmsg,
                                code: thrownError.result.writeConcernError.code
                            }, writeResult_1);
                        }
                        else {
                            // Error is a driver related error not a bulk op error, return early
                            throw new MongoBulkWriteError(thrownError, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
                        }
                    }
                    mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
                    writeResult_2 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
                    bulkOperation.handleWriteError(writeResult_2);
                    _b.label = 6;
                case 6:
                    _i++;
                    return [3 /*break*/, 1];
                case 7:
                    bulkOperation.s.batches.length = 0;
                    writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
                    bulkOperation.handleWriteError(writeResult);
                    return [2 /*return*/, writeResult];
            }
        });
    });
}
/**
 * An error indicating an unsuccessful Bulk Write
 * @public
 * @category Error
 */
var MongoBulkWriteError = /** @class */ (function (_super) {
    __extends(MongoBulkWriteError, _super);
    /**
     * **Do not use this constructor!**
     *
     * Meant for internal use only.
     *
     * @remarks
     * This class is only meant to be constructed within the driver. This constructor is
     * not subject to semantic versioning compatibility guarantees and may change at any time.
     *
     * @public
     **/
    function MongoBulkWriteError(error, result) {
        var _a;
        var _this = _super.call(this, error) || this;
        _this.writeErrors = [];
        if (error instanceof WriteConcernError)
            _this.err = error;
        else if (!(error instanceof Error)) {
            _this.message = error.message;
            _this.code = error.code;
            _this.writeErrors = (_a = error.writeErrors) !== null && _a !== void 0 ? _a : [];
        }
        _this.result = result;
        Object.assign(_this, error);
        return _this;
    }
    Object.defineProperty(MongoBulkWriteError.prototype, "name", {
        get: function () {
            return 'MongoBulkWriteError';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "insertedCount", {
        /** Number of documents inserted. */
        get: function () {
            return this.result.insertedCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "matchedCount", {
        /** Number of documents matched for update. */
        get: function () {
            return this.result.matchedCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "modifiedCount", {
        /** Number of documents modified. */
        get: function () {
            return this.result.modifiedCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "deletedCount", {
        /** Number of documents deleted. */
        get: function () {
            return this.result.deletedCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "upsertedCount", {
        /** Number of documents upserted. */
        get: function () {
            return this.result.upsertedCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "insertedIds", {
        /** Inserted document generated Id's, hash key is the index of the originating operation */
        get: function () {
            return this.result.insertedIds;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MongoBulkWriteError.prototype, "upsertedIds", {
        /** Upserted document generated Id's, hash key is the index of the originating operation */
        get: function () {
            return this.result.upsertedIds;
        },
        enumerable: false,
        configurable: true
    });
    return MongoBulkWriteError;
}(error_1.MongoServerError));
exports.MongoBulkWriteError = MongoBulkWriteError;
/**
 * A builder object that is returned from {@link BulkOperationBase#find}.
 * Is used to build a write operation that involves a query filter.
 *
 * @public
 */
var FindOperators = /** @class */ (function () {
    /**
     * Creates a new FindOperators object.
     * @internal
     */
    function FindOperators(bulkOperation) {
        this.bulkOperation = bulkOperation;
    }
    /** Add a multiple update operation to the bulk operation */
    FindOperators.prototype.update = function (updateDocument) {
        var currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, updateDocument, __assign(__assign({}, currentOp), { multi: true })));
    };
    /** Add a single update operation to the bulk operation */
    FindOperators.prototype.updateOne = function (updateDocument) {
        if (!utils_1.hasAtomicOperators(updateDocument)) {
            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
        }
        var currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, updateDocument, __assign(__assign({}, currentOp), { multi: false })));
    };
    /** Add a replace one operation to the bulk operation */
    FindOperators.prototype.replaceOne = function (replacement) {
        if (utils_1.hasAtomicOperators(replacement)) {
            throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
        }
        var currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, replacement, __assign(__assign({}, currentOp), { multi: false })));
    };
    /** Add a delete one operation to the bulk operation */
    FindOperators.prototype.deleteOne = function () {
        var currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(currentOp.selector, __assign(__assign({}, currentOp), { limit: 1 })));
    };
    /** Add a delete many operation to the bulk operation */
    FindOperators.prototype["delete"] = function () {
        var currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(currentOp.selector, __assign(__assign({}, currentOp), { limit: 0 })));
    };
    /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */
    FindOperators.prototype.upsert = function () {
        if (!this.bulkOperation.s.currentOp) {
            this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.upsert = true;
        return this;
    };
    /** Specifies the collation for the query condition. */
    FindOperators.prototype.collation = function (collation) {
        if (!this.bulkOperation.s.currentOp) {
            this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.collation = collation;
        return this;
    };
    /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */
    FindOperators.prototype.arrayFilters = function (arrayFilters) {
        if (!this.bulkOperation.s.currentOp) {
            this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
        return this;
    };
    /** Specifies hint for the bulk operation. */
    FindOperators.prototype.hint = function (hint) {
        if (!this.bulkOperation.s.currentOp) {
            this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.hint = hint;
        return this;
    };
    return FindOperators;
}());
exports.FindOperators = FindOperators;
/**
 * TODO(NODE-4063)
 * BulkWrites merge complexity is implemented in executeCommands
 * This provides a vehicle to treat bulkOperations like any other operation (hence "shim")
 * We would like this logic to simply live inside the BulkWriteOperation class
 * @internal
 */
var BulkWriteShimOperation = /** @class */ (function (_super) {
    __extends(BulkWriteShimOperation, _super);
    function BulkWriteShimOperation(bulkOperation, options) {
        var _this = _super.call(this, options) || this;
        _this.bulkOperation = bulkOperation;
        return _this;
    }
    Object.defineProperty(BulkWriteShimOperation.prototype, "commandName", {
        get: function () {
            return 'bulkWrite';
        },
        enumerable: false,
        configurable: true
    });
    BulkWriteShimOperation.prototype.execute = function (_server, session) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.options.session == null) {
                            // An implicit session could have been created by 'executeOperation'
                            // So if we stick it on finalOptions here, each bulk operation
                            // will use this same session, it'll be passed in the same way
                            // an explicit session would be
                            this.options.session = session;
                        }
                        return [4 /*yield*/, executeCommands(this.bulkOperation, this.options)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return BulkWriteShimOperation;
}(operation_1.AbstractOperation));
exports.BulkWriteShimOperation = BulkWriteShimOperation;
/** @public */
var BulkOperationBase = /** @class */ (function () {
    /**
     * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
     * @internal
     */
    function BulkOperationBase(collection, options, isOrdered) {
        this.collection = collection;
        // determine whether bulkOperation is ordered or unordered
        this.isOrdered = isOrdered;
        var topology = utils_1.getTopology(collection);
        options = options == null ? {} : options;
        // TODO Bring from driver information in hello
        // Get the namespace for the write operations
        var namespace = collection.s.namespace;
        // Used to mark operation as executed
        var executed = false;
        // Current item
        var currentOp = undefined;
        // Set max byte size
        var hello = topology.lastHello();
        // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents
        // over 2mb are still allowed
        var usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        var maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
        var maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        var maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000;
        // Calculates the largest possible size of an Array key, represented as a BSON string
        // element. This calculation:
        //     1 byte for BSON type
        //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))
        //   + 1 bytes for null terminator
        var maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        // Final options for retryable writes
        var finalOptions = Object.assign({}, options);
        finalOptions = utils_1.applyRetryableWrites(finalOptions, collection.s.db);
        // Final results
        var bulkResult = {
            ok: 1,
            writeErrors: [],
            writeConcernErrors: [],
            insertedIds: [],
            nInserted: 0,
            nUpserted: 0,
            nMatched: 0,
            nModified: 0,
            nRemoved: 0,
            upserted: []
        };
        // Internal state
        this.s = {
            // Final result
            bulkResult: bulkResult,
            // Current batch state
            currentBatch: undefined,
            currentIndex: 0,
            // ordered specific
            currentBatchSize: 0,
            currentBatchSizeBytes: 0,
            // unordered specific
            currentInsertBatch: undefined,
            currentUpdateBatch: undefined,
            currentRemoveBatch: undefined,
            batches: [],
            // Write concern
            writeConcern: write_concern_1.WriteConcern.fromOptions(options),
            // Max batch size options
            maxBsonObjectSize: maxBsonObjectSize,
            maxBatchSizeBytes: maxBatchSizeBytes,
            maxWriteBatchSize: maxWriteBatchSize,
            maxKeySize: maxKeySize,
            // Namespace
            namespace: namespace,
            // Topology
            topology: topology,
            // Options
            options: finalOptions,
            // BSON options
            bsonOptions: bson_1.resolveBSONOptions(options),
            // Current operation
            currentOp: currentOp,
            // Executed
            executed: executed,
            // Collection
            collection: collection,
            // Fundamental error
            err: undefined,
            // check keys
            checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : false
        };
        // bypass Validation
        if (options.bypassDocumentValidation === true) {
            this.s.bypassDocumentValidation = true;
        }
    }
    /**
     * Add a single insert document to the bulk operation
     *
     * @example
     * ```ts
     * const bulkOp = collection.initializeOrderedBulkOp();
     *
     * // Adds three inserts to the bulkOp.
     * bulkOp
     *   .insert({ a: 1 })
     *   .insert({ b: 2 })
     *   .insert({ c: 3 });
     * await bulkOp.execute();
     * ```
     */
    BulkOperationBase.prototype.insert = function (document) {
        utils_1.maybeAddIdToDocuments(this.collection, document, {
            forceServerObjectId: this.shouldForceServerObjectId()
        });
        return this.addToOperationsList(exports.BatchType.INSERT, document);
    };
    /**
     * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
     * Returns a builder object used to complete the definition of the operation.
     *
     * @example
     * ```ts
     * const bulkOp = collection.initializeOrderedBulkOp();
     *
     * // Add an updateOne to the bulkOp
     * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
     *
     * // Add an updateMany to the bulkOp
     * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
     *
     * // Add an upsert
     * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
     *
     * // Add a deletion
     * bulkOp.find({ g: 7 }).deleteOne();
     *
     * // Add a multi deletion
     * bulkOp.find({ h: 8 }).delete();
     *
     * // Add a replaceOne
     * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
     *
     * // Update using a pipeline (requires Mongodb 4.2 or higher)
     * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
     *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
     * ]);
     *
     * // All of the ops will now be executed
     * await bulkOp.execute();
     * ```
     */
    BulkOperationBase.prototype.find = function (selector) {
        if (!selector) {
            throw new error_1.MongoInvalidArgumentError('Bulk find operation must specify a selector');
        }
        // Save a current selector
        this.s.currentOp = {
            selector: selector
        };
        return new FindOperators(this);
    };
    /** Specifies a raw operation to perform in the bulk write. */
    BulkOperationBase.prototype.raw = function (op) {
        if (op == null || typeof op !== 'object') {
            throw new error_1.MongoInvalidArgumentError('Operation must be an object with an operation key');
        }
        if ('insertOne' in op) {
            var forceServerObjectId = this.shouldForceServerObjectId();
            var document = op.insertOne && op.insertOne.document == null
                ? // TODO(NODE-6003): remove support for omitting the `documents` subdocument in bulk inserts
                    op.insertOne
                : op.insertOne.document;
            utils_1.maybeAddIdToDocuments(this.collection, document, { forceServerObjectId: forceServerObjectId });
            return this.addToOperationsList(exports.BatchType.INSERT, document);
        }
        if ('replaceOne' in op || 'updateOne' in op || 'updateMany' in op) {
            if ('replaceOne' in op) {
                if ('q' in op.replaceOne) {
                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
                }
                var updateStatement = update_1.makeUpdateStatement(op.replaceOne.filter, op.replaceOne.replacement, __assign(__assign({}, op.replaceOne), { multi: false }));
                if (utils_1.hasAtomicOperators(updateStatement.u)) {
                    throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
                }
                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
            }
            if ('updateOne' in op) {
                if ('q' in op.updateOne) {
                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
                }
                var updateStatement = update_1.makeUpdateStatement(op.updateOne.filter, op.updateOne.update, __assign(__assign({}, op.updateOne), { multi: false }));
                if (!utils_1.hasAtomicOperators(updateStatement.u)) {
                    throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
                }
                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
            }
            if ('updateMany' in op) {
                if ('q' in op.updateMany) {
                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
                }
                var updateStatement = update_1.makeUpdateStatement(op.updateMany.filter, op.updateMany.update, __assign(__assign({}, op.updateMany), { multi: true }));
                if (!utils_1.hasAtomicOperators(updateStatement.u)) {
                    throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
                }
                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
            }
        }
        if ('deleteOne' in op) {
            if ('q' in op.deleteOne) {
                throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
            }
            return this.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(op.deleteOne.filter, __assign(__assign({}, op.deleteOne), { limit: 1 })));
        }
        if ('deleteMany' in op) {
            if ('q' in op.deleteMany) {
                throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
            }
            return this.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(op.deleteMany.filter, __assign(__assign({}, op.deleteMany), { limit: 0 })));
        }
        // otherwise an unknown operation was provided
        throw new error_1.MongoInvalidArgumentError('bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany');
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
        get: function () {
            return this.s.currentIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BulkOperationBase.prototype, "bsonOptions", {
        get: function () {
            return this.s.bsonOptions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BulkOperationBase.prototype, "writeConcern", {
        get: function () {
            return this.s.writeConcern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BulkOperationBase.prototype, "batches", {
        get: function () {
            var batches = __spreadArrays(this.s.batches);
            if (this.isOrdered) {
                if (this.s.currentBatch)
                    batches.push(this.s.currentBatch);
            }
            else {
                if (this.s.currentInsertBatch)
                    batches.push(this.s.currentInsertBatch);
                if (this.s.currentUpdateBatch)
                    batches.push(this.s.currentUpdateBatch);
                if (this.s.currentRemoveBatch)
                    batches.push(this.s.currentRemoveBatch);
            }
            return batches;
        },
        enumerable: false,
        configurable: true
    });
    BulkOperationBase.prototype.execute = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            var writeConcern, finalOptions, operation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.s.executed) {
                            throw new error_1.MongoBatchReExecutionError();
                        }
                        writeConcern = write_concern_1.WriteConcern.fromOptions(options);
                        if (writeConcern) {
                            this.s.writeConcern = writeConcern;
                        }
                        // If we have current batch
                        if (this.isOrdered) {
                            if (this.s.currentBatch)
                                this.s.batches.push(this.s.currentBatch);
                        }
                        else {
                            if (this.s.currentInsertBatch)
                                this.s.batches.push(this.s.currentInsertBatch);
                            if (this.s.currentUpdateBatch)
                                this.s.batches.push(this.s.currentUpdateBatch);
                            if (this.s.currentRemoveBatch)
                                this.s.batches.push(this.s.currentRemoveBatch);
                        }
                        // If we have no operations in the bulk raise an error
                        if (this.s.batches.length === 0) {
                            throw new error_1.MongoInvalidArgumentError('Invalid BulkOperation, Batch cannot be empty');
                        }
                        this.s.executed = true;
                        finalOptions = __assign(__assign({}, this.s.options), options);
                        operation = new BulkWriteShimOperation(this, finalOptions);
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.s.collection.client, operation)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Handles the write error before executing commands
     * @internal
     */
    BulkOperationBase.prototype.handleWriteError = function (writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
            var msg = this.s.bulkResult.writeErrors[0].errmsg
                ? this.s.bulkResult.writeErrors[0].errmsg
                : 'write operation failed';
            throw new MongoBulkWriteError({
                message: msg,
                code: this.s.bulkResult.writeErrors[0].code,
                writeErrors: this.s.bulkResult.writeErrors
            }, writeResult);
        }
        var writeConcernError = writeResult.getWriteConcernError();
        if (writeConcernError) {
            throw new MongoBulkWriteError(writeConcernError, writeResult);
        }
    };
    BulkOperationBase.prototype.shouldForceServerObjectId = function () {
        var _a;
        return (this.s.options.forceServerObjectId === true ||
            ((_a = this.s.collection.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId) === true);
    };
    return BulkOperationBase;
}());
exports.BulkOperationBase = BulkOperationBase;
function isInsertBatch(batch) {
    return batch.batchType === exports.BatchType.INSERT;
}
function isUpdateBatch(batch) {
    return batch.batchType === exports.BatchType.UPDATE;
}
function isDeleteBatch(batch) {
    return batch.batchType === exports.BatchType.DELETE;
}
function buildCurrentOp(bulkOp) {
    var currentOp = bulkOp.s.currentOp;
    bulkOp.s.currentOp = undefined;
    if (!currentOp)
        currentOp = {};
    return currentOp;
}
