"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.Timeout = exports.TimeoutError = void 0;
var timers_1 = require("timers");
var error_1 = require("./error");
var utils_1 = require("./utils");
/** @internal */
var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(message, options) {
        return _super.call(this, message, options) || this;
    }
    Object.defineProperty(TimeoutError.prototype, "name", {
        get: function () {
            return 'TimeoutError';
        },
        enumerable: false,
        configurable: true
    });
    TimeoutError.is = function (error) {
        return (error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError');
    };
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
 > [0];
 > [0] > [1];
/**
 * @internal
 * This class is an abstraction over timeouts
 * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve
 * if interacted with exclusively through its public API
 * */
var Timeout = /** @class */ (function (_super) {
    __extends(Timeout, _super);
    /** Create a new timeout that expires in `duration` ms */
    function Timeout(executor, duration, unref) {
        if (executor === void 0) { executor = function () { return null; }; }
        if (unref === void 0) { unref = false; }
        var _this = this;
        var reject;
        if (duration < 0) {
            throw new error_1.MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');
        }
        _this = _super.call(this, function (_, promiseReject) {
            reject = promiseReject;
            executor(utils_1.noop, promiseReject);
        }) || this;
        _this.ended = null;
        _this.timedOut = false;
        _this.duration = duration;
        _this.start = Math.trunc(performance.now());
        if (_this.duration > 0) {
            _this.id = timers_1.setTimeout(function () {
                _this.ended = Math.trunc(performance.now());
                _this.timedOut = true;
                reject(new TimeoutError("Expired after " + duration + "ms"));
            }, _this.duration);
            if (typeof _this.id.unref === 'function' && unref) {
                // Ensure we do not keep the Node.js event loop running
                _this.id.unref();
            }
        }
        return _this;
    }
    Object.defineProperty(Timeout.prototype, Symbol.toStringTag, {
        get: function () {
            return 'MongoDBTimeout';
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clears the underlying timeout. This method is idempotent
     */
    Timeout.prototype.clear = function () {
        timers_1.clearTimeout(this.id);
        this.id = undefined;
    };
    Timeout.expires = function (durationMS, unref) {
        return new Timeout(undefined, durationMS, unref);
    };
    Timeout.is = function (timeout) {
        return (typeof timeout === 'object' &&
            timeout != null &&
            Symbol.toStringTag in timeout &&
            timeout[Symbol.toStringTag] === 'MongoDBTimeout' &&
            'then' in timeout &&
            typeof timeout.then === 'function');
    };
    return Timeout;
}(Promise));
exports.Timeout = Timeout;
