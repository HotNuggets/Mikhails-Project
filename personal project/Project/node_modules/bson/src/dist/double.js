"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.Double = void 0;
var bson_value_1 = require("./bson_value");
var error_1 = require("./error");
var utils_1 = require("./parser/utils");
/**
 * A class representation of the BSON Double type.
 * @public
 * @category BSONType
 */
var Double = /** @class */ (function (_super) {
    __extends(Double, _super);
    /**
     * Create a Double type
     *
     * @param value - the number we want to represent as a double.
     */
    function Double(value) {
        var _this = _super.call(this) || this;
        if (value instanceof Number) {
            value = value.valueOf();
        }
        _this.value = +value;
        return _this;
    }
    Object.defineProperty(Double.prototype, "_bsontype", {
        get: function () {
            return 'Double';
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Attempt to create an double type from string.
     *
     * This method will throw a BSONError on any string input that is not representable as a IEEE-754 64-bit double.
     * Notably, this method will also throw on the following string formats:
     * - Strings in non-decimal and non-exponential formats (binary, hex, or octal digits)
     * - Strings with characters other than numeric, floating point, or leading sign characters (Note: 'Infinity', '-Infinity', and 'NaN' input strings are still allowed)
     * - Strings with leading and/or trailing whitespace
     *
     * Strings with leading zeros, however, are also allowed
     *
     * @param value - the string we want to represent as a double.
     */
    Double.fromString = function (value) {
        var coercedValue = Number(value);
        if (value === 'NaN')
            return new Double(NaN);
        if (value === 'Infinity')
            return new Double(Infinity);
        if (value === '-Infinity')
            return new Double(-Infinity);
        if (!Number.isFinite(coercedValue)) {
            throw new error_1.BSONError("Input: " + value + " is not representable as a Double");
        }
        if (value.trim() !== value) {
            throw new error_1.BSONError("Input: '" + value + "' contains whitespace");
        }
        if (value === '') {
            throw new error_1.BSONError("Input is an empty string");
        }
        if (/[^-0-9.+eE]/.test(value)) {
            throw new error_1.BSONError("Input: '" + value + "' is not in decimal or exponential notation");
        }
        return new Double(coercedValue);
    };
    /**
     * Access the number value.
     *
     * @returns returns the wrapped double number.
     */
    Double.prototype.valueOf = function () {
        return this.value;
    };
    Double.prototype.toJSON = function () {
        return this.value;
    };
    Double.prototype.toString = function (radix) {
        return this.value.toString(radix);
    };
    /** @internal */
    Double.prototype.toExtendedJSON = function (options) {
        if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) {
            return this.value;
        }
        if (Object.is(Math.sign(this.value), -0)) {
            // NOTE: JavaScript has +0 and -0, apparently to model limit calculations. If a user
            // explicitly provided `-0` then we need to ensure the sign makes it into the output
            return { $numberDouble: '-0.0' };
        }
        return {
            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
        };
    };
    /** @internal */
    Double.fromExtendedJSON = function (doc, options) {
        var doubleValue = parseFloat(doc.$numberDouble);
        return options && options.relaxed ? doubleValue : new Double(doubleValue);
    };
    Double.prototype.inspect = function (depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : ;
        utils_1.defaultInspect;
        return "new Double(" + inspect(this.value, options) + ")";
    };
    return Double;
}(bson_value_1.BSONValue));
exports.Double = Double;
