'use strict';
/*!
 * Module dependencies.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events').EventEmitter;

var MongooseError = require('../error/mongooseError');
/*!
 * ignore
 */


var driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];
/*!
 * ignore
 */

var ChangeStream =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(ChangeStream, _EventEmitter);

  function ChangeStream(changeStreamThunk, pipeline, options) {
    var _this;

    _classCallCheck(this, ChangeStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ChangeStream).call(this));
    _this.driverChangeStream = null;
    _this.closed = false;
    _this.bindedEvents = false;
    _this.pipeline = pipeline;
    _this.options = options;
    _this.errored = false;

    if (options && options.hydrate && !options.model) {
      throw new Error('Cannot create change stream with `hydrate: true` ' + 'unless calling `Model.watch()`');
    }

    var syncError = null;
    _this.$driverChangeStreamPromise = new Promise(function (resolve, reject) {
      // This wrapper is necessary because of buffering.
      try {
        changeStreamThunk(function (err, driverChangeStream) {
          if (err != null) {
            _this.errored = true;

            _this.emit('error', err);

            return reject(err);
          }

          _this.driverChangeStream = driverChangeStream;

          _this.emit('ready');

          resolve();
        });
      } catch (err) {
        syncError = err;
        _this.errored = true;

        _this.emit('error', err);

        reject(err);
      }
    }); // Because a ChangeStream is an event emitter, there's no way to register an 'error' handler
    // that catches errors which occur in the constructor, unless we force sync errors into async
    // errors with setImmediate(). For cleaner stack trace, we just immediately throw any synchronous
    // errors that occurred with changeStreamThunk().

    if (syncError != null) {
      throw syncError;
    }

    return _this;
  }

  _createClass(ChangeStream, [{
    key: "_bindEvents",
    value: function _bindEvents() {
      var _this2 = this;

      if (this.bindedEvents) {
        return;
      }

      this.bindedEvents = true;

      if (this.driverChangeStream == null) {
        this.$driverChangeStreamPromise.then(function () {
          _this2.driverChangeStream.on('close', function () {
            _this2.closed = true;
          });

          driverChangeStreamEvents.forEach(function (ev) {
            _this2.driverChangeStream.on(ev, function (data) {
              if (data != null && data.fullDocument != null && _this2.options && _this2.options.hydrate) {
                data.fullDocument = _this2.options.model.hydrate(data.fullDocument);
              }

              _this2.emit(ev, data);
            });
          });
        }, function () {} // No need to register events if opening change stream failed
        );
        return;
      }

      this.driverChangeStream.on('close', function () {
        _this2.closed = true;
      });
      driverChangeStreamEvents.forEach(function (ev) {
        _this2.driverChangeStream.on(ev, function (data) {
          if (data != null && data.fullDocument != null && _this2.options && _this2.options.hydrate) {
            data.fullDocument = _this2.options.model.hydrate(data.fullDocument);
          }

          _this2.emit(ev, data);
        });
      });
    }
  }, {
    key: "hasNext",
    value: function hasNext(cb) {
      if (this.errored) {
        throw new MongooseError('Cannot call hasNext() on errored ChangeStream');
      }

      return this.driverChangeStream.hasNext(cb);
    }
  }, {
    key: "next",
    value: function next(cb) {
      var _this3 = this;

      if (this.errored) {
        throw new MongooseError('Cannot call next() on errored ChangeStream');
      }

      if (this.options && this.options.hydrate) {
        if (cb != null) {
          var originalCb = cb;

          cb = function cb(err, data) {
            if (err != null) {
              return originalCb(err);
            }

            if (data.fullDocument != null) {
              data.fullDocument = _this3.options.model.hydrate(data.fullDocument);
            }

            return originalCb(null, data);
          };
        }

        var maybePromise = this.driverChangeStream.next(cb);

        if (maybePromise && typeof maybePromise.then === 'function') {
          maybePromise = maybePromise.then(function (data) {
            if (data.fullDocument != null) {
              data.fullDocument = _this3.options.model.hydrate(data.fullDocument);
            }

            return data;
          });
        }

        return maybePromise;
      }

      return this.driverChangeStream.next(cb);
    }
  }, {
    key: "addListener",
    value: function addListener(event, handler) {
      if (this.errored) {
        throw new MongooseError('Cannot call addListener() on errored ChangeStream');
      }

      this._bindEvents();

      return _get(_getPrototypeOf(ChangeStream.prototype), "addListener", this).call(this, event, handler);
    }
  }, {
    key: "on",
    value: function on(event, handler) {
      if (this.errored) {
        throw new MongooseError('Cannot call on() on errored ChangeStream');
      }

      this._bindEvents();

      return _get(_getPrototypeOf(ChangeStream.prototype), "on", this).call(this, event, handler);
    }
  }, {
    key: "once",
    value: function once(event, handler) {
      if (this.errored) {
        throw new MongooseError('Cannot call once() on errored ChangeStream');
      }

      this._bindEvents();

      return _get(_getPrototypeOf(ChangeStream.prototype), "once", this).call(this, event, handler);
    }
  }, {
    key: "_queue",
    value: function _queue(cb) {
      this.once('ready', function () {
        return cb();
      });
    }
  }, {
    key: "close",
    value: function close() {
      var _this4 = this;

      this.closed = true;

      if (this.driverChangeStream) {
        return this.driverChangeStream.close();
      } else {
        return this.$driverChangeStreamPromise.then(function () {
          return _this4.driverChangeStream.close();
        }, function () {} // No need to close if opening the change stream failed
        );
      }
    }
  }]);

  return ChangeStream;
}(EventEmitter);
/*!
 * ignore
 */


module.exports = ChangeStream;