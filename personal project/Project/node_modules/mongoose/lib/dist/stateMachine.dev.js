/*!
 * Module dependencies.
 */
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var utils = require('./utils'); // eslint-disable-line no-unused-vars

/**
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */


var StateMachine = module.exports = exports = function StateMachine() {};
/**
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @api private
 */


StateMachine.ctor = function () {
  var states = Array.prototype.slice.call(arguments);

  var ctor = function ctor() {
    StateMachine.apply(this, arguments);
    this.paths = {};
    this.states = {};
  };

  ctor.prototype = new StateMachine();
  ctor.prototype.constructor = ctor;
  ctor.prototype.stateNames = states;
  states.forEach(function (state) {
    // Changes the `path`'s state to `state`.
    ctor.prototype[state] = function (path) {
      this._changeState(path, state);
    };
  });
  return ctor;
};
/**
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */


StateMachine.prototype._changeState = function _changeState(path, nextState) {
  var prevState = this.paths[path];

  if (prevState === nextState) {
    return;
  }

  var prevBucket = this.states[prevState];
  if (prevBucket) delete prevBucket[path];
  this.paths[path] = nextState;
  this.states[nextState] = this.states[nextState] || {};
  this.states[nextState][path] = true;
};
/*!
 * ignore
 */


StateMachine.prototype.clear = function clear(state) {
  if (this.states[state] == null) {
    return;
  }

  var keys = Object.keys(this.states[state]);
  var i = keys.length;
  var path;

  while (i--) {
    path = keys[i];
    delete this.states[state][path];
    delete this.paths[path];
  }
};
/*!
 * ignore
 */


StateMachine.prototype.clearPath = function clearPath(path) {
  var state = this.paths[path];

  if (!state) {
    return;
  }

  delete this.paths[path];
  delete this.states[state][path];
};
/**
 * Gets the paths for the given state, or empty object `{}` if none.
 * @api private
 */


StateMachine.prototype.getStatePaths = function getStatePaths(state) {
  if (this.states[state] != null) {
    return this.states[state];
  }

  return {};
};
/**
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @api private
 */


StateMachine.prototype.some = function some() {
  var _this = this;

  var what = arguments.length ? arguments : this.stateNames;
  return Array.prototype.some.call(what, function (state) {
    if (_this.states[state] == null) {
      return false;
    }

    return Object.keys(_this.states[state]).length;
  });
};
/**
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */


StateMachine.prototype._iter = function _iter(iterMethod) {
  return function () {
    var states = Array.prototype.slice.call(arguments);
    var callback = states.pop();
    if (!states.length) states = this.stateNames;

    var _this = this;

    var paths = states.reduce(function (paths, state) {
      if (_this.states[state] == null) {
        return paths;
      }

      return paths.concat(Object.keys(_this.states[state]));
    }, []);
    return paths[iterMethod](function (path, i, paths) {
      return callback(path, i, paths);
    });
  };
};
/**
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @api private
 */


StateMachine.prototype.forEach = function forEach() {
  this.forEach = this._iter('forEach');
  return this.forEach.apply(this, arguments);
};
/**
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @api private
 */


StateMachine.prototype.map = function map() {
  this.map = this._iter('map');
  return this.map.apply(this, arguments);
};
/**
 * Returns a copy of this state machine
 *
 * @param {Function} callback
 * @return {StateMachine}
 * @api private
 */


StateMachine.prototype.clone = function clone() {
  var result = new this.constructor();
  result.paths = _objectSpread({}, this.paths);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = this.stateNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var state = _step.value;

      if (!(state in this.states)) {
        continue;
      }

      result.states[state] = this.states[state] == null ? this.states[state] : _objectSpread({}, this.states[state]);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
};