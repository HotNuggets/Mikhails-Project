'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Decimal = require('../types/decimal128');

var ObjectId = require('../types/objectid');

var specialProperties = require('./specialProperties');

var isMongooseObject = require('./isMongooseObject');

var getFunctionName = require('./getFunctionName');

var isBsonType = require('./isBsonType');

var isMongooseArray = require('../types/array/isMongooseArray').isMongooseArray;

var isObject = require('./isObject');

var isPOJO = require('./isPOJO');

var symbols = require('./symbols');

var trustedSymbol = require('./query/trusted').trustedSymbol;
/**
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions and primitives are never cloned.
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
 * @return {Object} the cloned object
 * @api private
 */


function clone(obj, options, isArrayChild) {
  if (obj == null) {
    return obj;
  }

  if (typeof obj === 'number' || typeof obj === 'string' || typeof obj === 'boolean' || typeof obj === 'bigint') {
    return obj;
  }

  if (Array.isArray(obj)) {
    return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);
  }

  if (isMongooseObject(obj)) {
    if (options) {
      if (options.retainDocuments && obj.$__ != null) {
        var clonedDoc = obj.$clone();

        if (obj.__index != null) {
          clonedDoc.__index = obj.__index;
        }

        if (obj.__parentArray != null) {
          clonedDoc.__parentArray = obj.__parentArray;
        }

        clonedDoc.$__parent = obj.$__parent;
        return clonedDoc;
      }
    }

    var isSingleNested = obj.$isSingleNested;

    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {
      return obj._doc;
    }

    var ret;

    if (options && options.json && typeof obj.toJSON === 'function') {
      ret = obj.toJSON(options);
    } else {
      ret = obj.toObject(options);
    }

    if (options && options.minimize && !obj.constructor.$__required && isSingleNested && Object.keys(ret).length === 0) {
      return undefined;
    }

    return ret;
  }

  var objConstructor = obj.constructor;

  if (objConstructor) {
    switch (getFunctionName(objConstructor)) {
      case 'Object':
        return cloneObject(obj, options, isArrayChild);

      case 'Date':
        return new objConstructor(+obj);

      case 'RegExp':
        return cloneRegExp(obj);

      default:
        // ignore
        break;
    }
  }

  if (isBsonType(obj, 'ObjectId')) {
    if (options && options.flattenObjectIds) {
      return obj.toJSON();
    }

    return new ObjectId(obj.id);
  }

  if (isBsonType(obj, 'Decimal128')) {
    if (options && options.flattenDecimals) {
      return obj.toJSON();
    }

    return Decimal.fromString(obj.toString());
  } // object created with Object.create(null)


  if (!objConstructor && isObject(obj)) {
    return cloneObject(obj, options, isArrayChild);
  }

  if (_typeof(obj) === 'object' && obj[symbols.schemaTypeSymbol]) {
    return obj.clone();
  } // If we're cloning this object to go into a MongoDB command,
  // and there's a `toBSON()` function, assume this object will be
  // stored as a primitive in MongoDB and doesn't need to be cloned.


  if (options && options.bson && typeof obj.toBSON === 'function') {
    return obj;
  }

  if (typeof obj.valueOf === 'function') {
    return obj.valueOf();
  }

  return cloneObject(obj, options, isArrayChild);
}

module.exports = clone;
/*!
 * ignore
 */

function cloneObject(obj, options, isArrayChild) {
  var minimize = options && options.minimize;
  var omitUndefined = options && options.omitUndefined;
  var seen = options && options._seen;
  var ret = {};
  var hasKeys;

  if (seen && seen.has(obj)) {
    return seen.get(obj);
  } else if (seen) {
    seen.set(obj, ret);
  }

  if (trustedSymbol in obj) {
    ret[trustedSymbol] = obj[trustedSymbol];
  }

  var keys = Object.keys(obj);
  var len = keys.length;

  for (var i = 0; i < len; ++i) {
    var key = keys[i];

    if (specialProperties.has(key)) {
      continue;
    } // Don't pass `isArrayChild` down


    var val = clone(obj[key], options, false);

    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {
      delete ret[key];
    } else if (minimize !== true || typeof val !== 'undefined') {
      hasKeys || (hasKeys = true);
      ret[key] = val;
    }
  }

  return minimize && !isArrayChild ? hasKeys && ret : ret;
}

function cloneArray(arr, options) {
  var i = 0;
  var len = arr.length;
  var ret = new Array(len);

  for (i = 0; i < len; ++i) {
    ret[i] = clone(arr[i], options, true);
  }

  return ret;
}

function cloneRegExp(regexp) {
  var ret = new RegExp(regexp.source, regexp.flags);

  if (ret.lastIndex !== regexp.lastIndex) {
    ret.lastIndex = regexp.lastIndex;
  }

  return ret;
}