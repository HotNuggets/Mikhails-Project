"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.decompressResponse = exports.compressCommand = exports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;
var util_1 = require("util");
var zlib = require("zlib");
var constants_1 = require("../../constants");
var deps_1 = require("../../deps");
var error_1 = require("../../error");
var commands_1 = require("../commands");
var constants_2 = require("./constants");
/** @public */
exports.Compressor = Object.freeze({
    none: 0,
    snappy: 1,
    zlib: 2,
    zstd: 3
});
exports.uncompressibleCommands = new Set([
    constants_1.LEGACY_HELLO_COMMAND,
    'saslStart',
    'saslContinue',
    'getnonce',
    'authenticate',
    'createUser',
    'updateUser',
    'copydbSaslStart',
    'copydbgetnonce',
    'copydb'
]);
var ZSTD_COMPRESSION_LEVEL = 3;
var zlibInflate = util_1.promisify(zlib.inflate.bind(zlib));
var zlibDeflate = util_1.promisify(zlib.deflate.bind(zlib));
var zstd;
var Snappy = null;
function loadSnappy() {
    if (Snappy == null) {
        var snappyImport = deps_1.getSnappy();
        if ('kModuleError' in snappyImport) {
            throw snappyImport.kModuleError;
        }
        Snappy = snappyImport;
    }
    return Snappy;
}
// Facilitate compressing a message using an agreed compressor
function compress(options, dataToBeCompressed) {
    return __awaiter(this, void 0, Promise, function () {
        var zlibOptions, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    zlibOptions = {};
                    _a = options.agreedCompressor;
                    switch (_a) {
                        case 'snappy': return [3 /*break*/, 1];
                        case 'zstd': return [3 /*break*/, 3];
                        case 'zlib': return [3 /*break*/, 5];
                    }
                    return [3 /*break*/, 7];
                case 1:
                    Snappy !== null && Snappy !== void 0 ? Snappy : ;
                    loadSnappy();
                    return [4 /*yield*/, Snappy.compress(dataToBeCompressed)];
                case 2: return [2 /*return*/, _b.sent()];
                case 3:
                    loadZstd();
                    if ('kModuleError' in zstd) {
                        throw zstd['kModuleError'];
                    }
                    return [4 /*yield*/, zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL)];
                case 4: return [2 /*return*/, _b.sent()];
                case 5:
                    if (options.zlibCompressionLevel) {
                        zlibOptions.level = options.zlibCompressionLevel;
                    }
                    return [4 /*yield*/, zlibDeflate(dataToBeCompressed, zlibOptions)];
                case 6: return [2 /*return*/, _b.sent()];
                case 7:
                    {
                        throw new error_1.MongoInvalidArgumentError("Unknown compressor " + options.agreedCompressor + " failed to compress");
                    }
                    _b.label = 8;
                case 8: return [2 /*return*/];
            }
        });
    });
}
exports.compress = compress;
// Decompress a message using the given compressor
function decompress(compressorID, compressedData) {
    return __awaiter(this, void 0, Promise, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (compressorID !== exports.Compressor.snappy &&
                        compressorID !== exports.Compressor.zstd &&
                        compressorID !== exports.Compressor.zlib &&
                        compressorID !== exports.Compressor.none) {
                        throw new error_1.MongoDecompressionError("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
                    }
                    _a = compressorID;
                    switch (_a) {
                        case exports.Compressor.snappy: return [3 /*break*/, 1];
                        case exports.Compressor.zstd: return [3 /*break*/, 3];
                        case exports.Compressor.zlib: return [3 /*break*/, 5];
                    }
                    return [3 /*break*/, 7];
                case 1:
                    Snappy !== null && Snappy !== void 0 ? Snappy : ;
                    loadSnappy();
                    return [4 /*yield*/, Snappy.uncompress(compressedData, { asBuffer: true })];
                case 2: return [2 /*return*/, _b.sent()];
                case 3:
                    loadZstd();
                    if ('kModuleError' in zstd) {
                        throw zstd['kModuleError'];
                    }
                    return [4 /*yield*/, zstd.decompress(compressedData)];
                case 4: return [2 /*return*/, _b.sent()];
                case 5: return [4 /*yield*/, zlibInflate(compressedData)];
                case 6: return [2 /*return*/, _b.sent()];
                case 7:
                    {
                        return [2 /*return*/, compressedData];
                    }
                    _b.label = 8;
                case 8: return [2 /*return*/];
            }
        });
    });
}
exports.decompress = decompress;
/**
 * Load ZStandard if it is not already set.
 */
function loadZstd() {
    if (!zstd) {
        zstd = deps_1.getZstdLibrary();
    }
}
var MESSAGE_HEADER_SIZE = 16;
/**
 * @internal
 *
 * Compresses an OP_MSG or OP_QUERY message, if compression is configured.  This method
 * also serializes the command to BSON.
 */
function compressCommand(command, description) {
    var _a, _b;
    return __awaiter(this, void 0, Promise, function () {
        var finalCommand, data;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    finalCommand = description.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command)
                        ? command
                        : new commands_1.OpCompressedRequest(command, {
                            agreedCompressor: (_a = description.agreedCompressor) !== null && _a !== void 0 ? _a : 'none',
                            zlibCompressionLevel: (_b = description.zlibCompressionLevel) !== null && _b !== void 0 ? _b : 0
                        });
                    return [4 /*yield*/, finalCommand.toBin()];
                case 1:
                    data = _c.sent();
                    return [2 /*return*/, Buffer.concat(data)];
            }
        });
    });
}
exports.compressCommand = compressCommand;
/**
 * @internal
 *
 * Decompresses an OP_MSG or OP_QUERY response from the server, if compression is configured.
 *
 * This method does not parse the response's BSON.
 */
function decompressResponse(message) {
    return __awaiter(this, void 0, Promise, function () {
        var messageHeader, ResponseType_1, messageBody_1, header, compressorID, compressedBuffer, ResponseType, messageBody;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    messageHeader = {
                        length: message.readInt32LE(0),
                        requestId: message.readInt32LE(4),
                        responseTo: message.readInt32LE(8),
                        opCode: message.readInt32LE(12)
                    };
                    if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
                        ResponseType_1 = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
                        messageBody_1 = message.subarray(MESSAGE_HEADER_SIZE);
                        return [2 /*return*/, new ResponseType_1(message, messageHeader, messageBody_1)];
                    }
                    header = __assign(__assign({}, messageHeader), { fromCompressed: true, opCode: message.readInt32LE(MESSAGE_HEADER_SIZE), length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4) });
                    compressorID = message[MESSAGE_HEADER_SIZE + 8];
                    compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
                    ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
                    return [4 /*yield*/, decompress(compressorID, compressedBuffer)];
                case 1:
                    messageBody = _a.sent();
                    if (messageBody.length !== header.length) {
                        throw new error_1.MongoDecompressionError('Message body and message header must be the same length');
                    }
                    return [2 /*return*/, new ResponseType(message, header, messageBody)];
            }
        });
    });
}
exports.decompressResponse = decompressResponse;
