'use strict';

var ArrayMethods = require('../../array/methods');

var Document = require('../../../document');

var castObjectId = require('../../../cast/objectid');

var getDiscriminatorByValue = require('../../../helpers/discriminator/getDiscriminatorByValue');

var internalToObjectOptions = require('../../../options').internalToObjectOptions;

var utils = require('../../../utils');

var isBsonType = require('../../../helpers/isBsonType');

var arrayParentSymbol = require('../../../helpers/symbols').arrayParentSymbol;

var arrayPathSymbol = require('../../../helpers/symbols').arrayPathSymbol;

var arraySchemaSymbol = require('../../../helpers/symbols').arraySchemaSymbol;

var documentArrayParent = require('../../../helpers/symbols').documentArrayParent;

var _baseToString = Array.prototype.toString;
var methods = {
  /*!
   * ignore
   */
  toBSON: function toBSON() {
    return this.toObject(internalToObjectOptions);
  },
  toString: function toString() {
    return _baseToString.call(this.__array.map(function (subdoc) {
      if (subdoc != null && subdoc.$__ != null) {
        return subdoc.toString();
      }

      return subdoc;
    }));
  },

  /*!
   * ignore
   */
  getArrayParent: function getArrayParent() {
    return this[arrayParentSymbol];
  },

  /**
   * Overrides MongooseArray#cast
   *
   * @method _cast
   * @api private
   * @memberOf MongooseDocumentArray
   */
  _cast: function _cast(value, index, options) {
    if (this[arraySchemaSymbol] == null) {
      return value;
    }

    var Constructor = this[arraySchemaSymbol].casterConstructor;
    var isInstance = Constructor.$isMongooseDocumentArray ? utils.isMongooseDocumentArray(value) : value instanceof Constructor;

    if (isInstance || // Hack re: #5001, see #5005
    value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
      if (!(value[documentArrayParent] && value.__parentArray)) {
        // value may have been created using array.create()
        value[documentArrayParent] = this[arrayParentSymbol];
        value.__parentArray = this;
      }

      value.$setIndex(index);
      return value;
    }

    if (value === undefined || value === null) {
      return null;
    } // handle cast('string') or cast(ObjectId) etc.
    // only objects are permitted so we can safely assume that
    // non-objects are to be interpreted as _id


    if (Buffer.isBuffer(value) || isBsonType(value, 'ObjectId') || !utils.isObject(value)) {
      value = {
        _id: value
      };
    }

    if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
      if (typeof value[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
        Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
      } else {
        var constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);

        if (constructorByValue) {
          Constructor = constructorByValue;
        }
      }
    }

    if (Constructor.$isMongooseDocumentArray) {
      return Constructor.cast(value, this, undefined, undefined, index);
    }

    var ret = new Constructor(value, this, options, undefined, index);
    ret.isNew = true;
    return ret;
  },

  /**
   * Searches array items for the first document with a matching _id.
   *
   * #### Example:
   *
   *     const embeddedDoc = m.array.id(some_id);
   *
   * @return {EmbeddedDocument|null} the subdocument or null if not found.
   * @param {ObjectId|String|Number|Buffer} id
   * @TODO cast to the _id based on schema for proper comparison
   * @method id
   * @api public
   * @memberOf MongooseDocumentArray
   */
  id: function id(_id2) {
    var casted;
    var sid;

    var _id;

    try {
      casted = castObjectId(_id2).toString();
    } catch (e) {
      casted = null;
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = this[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var val = _step.value;

        if (!val) {
          continue;
        }

        _id = val.get('_id');

        if (_id === null || typeof _id === 'undefined') {
          continue;
        } else if (_id instanceof Document) {
          sid || (sid = String(_id2));

          if (sid == _id._id) {
            return val;
          }
        } else if (!isBsonType(_id2, 'ObjectId') && !isBsonType(_id, 'ObjectId')) {
          if (_id2 == _id || utils.deepEqual(_id2, _id)) {
            return val;
          }
        } else if (casted == _id) {
          return val;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return null;
  },

  /**
   * Returns a native js Array of plain js objects
   *
   * #### Note:
   *
   * _Each sub-document is converted to a plain object by calling its `#toObject` method._
   *
   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
   * @return {Array}
   * @method toObject
   * @api public
   * @memberOf MongooseDocumentArray
   */
  toObject: function toObject(options) {
    // `[].concat` coerces the return value into a vanilla JS array, rather
    // than a Mongoose array.
    return [].concat(this.map(function (doc) {
      if (doc == null) {
        return null;
      }

      if (typeof doc.toObject !== 'function') {
        return doc;
      }

      return doc.toObject(options);
    }));
  },
  $toObject: function $toObject() {
    return this.constructor.prototype.toObject.apply(this, arguments);
  },

  /**
   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
   *
   * @param {...Object} [args]
   * @api public
   * @method push
   * @memberOf MongooseDocumentArray
   */
  push: function push() {
    var ret = ArrayMethods.push.apply(this, arguments);

    _updateParentPopulated(this);

    return ret;
  },

  /**
   * Pulls items from the array atomically.
   *
   * @param {...Object} [args]
   * @api public
   * @method pull
   * @memberOf MongooseDocumentArray
   */
  pull: function pull() {
    var ret = ArrayMethods.pull.apply(this, arguments);

    _updateParentPopulated(this);

    return ret;
  },

  /**
   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
   * @api private
   */
  shift: function shift() {
    var ret = ArrayMethods.shift.apply(this, arguments);

    _updateParentPopulated(this);

    return ret;
  },

  /**
   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
   * @api private
   */
  splice: function splice() {
    var ret = ArrayMethods.splice.apply(this, arguments);

    _updateParentPopulated(this);

    return ret;
  },

  /**
   * Helper for console.log
   *
   * @method inspect
   * @api public
   * @memberOf MongooseDocumentArray
   */
  inspect: function inspect() {
    return this.toObject();
  },

  /**
   * Creates a subdocument casted to this schema.
   *
   * This is the same subdocument constructor used for casting.
   *
   * @param {Object} obj the value to cast to this arrays SubDocument schema
   * @method create
   * @api public
   * @memberOf MongooseDocumentArray
   */
  create: function create(obj) {
    var Constructor = this[arraySchemaSymbol].casterConstructor;

    if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
      if (typeof obj[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
        Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
      } else {
        var constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);

        if (constructorByValue) {
          Constructor = constructorByValue;
        }
      }
    }

    return new Constructor(obj, this);
  },

  /*!
   * ignore
   */
  notify: function notify(event) {
    var _this = this;

    return function notify(val, _arr) {
      _arr = _arr || _this;
      var i = _arr.length;

      while (i--) {
        if (_arr[i] == null) {
          continue;
        }

        switch (event) {
          // only swap for save event for now, we may change this to all event types later
          case 'save':
            val = _this[i];
            break;

          default:
            // NO-OP
            break;
        }

        if (utils.isMongooseArray(_arr[i])) {
          notify(val, _arr[i]);
        } else if (_arr[i]) {
          _arr[i].emit(event, val);
        }
      }
    };
  },
  set: function set(i, val, skipModified) {
    var arr = this.__array;

    if (skipModified) {
      arr[i] = val;
      return this;
    }

    var value = methods._cast.call(this, val, i);

    methods._markModified.call(this, i);

    arr[i] = value;
    return this;
  },
  _markModified: function _markModified(elem, embeddedPath) {
    var parent = this[arrayParentSymbol];
    var dirtyPath;

    if (parent) {
      dirtyPath = this[arrayPathSymbol];

      if (arguments.length) {
        if (embeddedPath != null) {
          // an embedded doc bubbled up the change
          var index = elem.__index;
          dirtyPath = dirtyPath + '.' + index + '.' + embeddedPath;
        } else {
          // directly set an index
          dirtyPath = dirtyPath + '.' + elem;
        }
      }

      if (dirtyPath != null && dirtyPath.endsWith('.$')) {
        return this;
      }

      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
    }

    return this;
  }
};
module.exports = methods;
/**
 * If this is a document array, each element may contain single
 * populated paths, so we need to modify the top-level document's
 * populated cache. See gh-8247, gh-8265.
 * @param {Array} arr
 * @api private
 */

function _updateParentPopulated(arr) {
  var parent = arr[arrayParentSymbol];
  if (!parent || parent.$__.populated == null) return;
  var populatedPaths = Object.keys(parent.$__.populated).filter(function (p) {
    return p.startsWith(arr[arrayPathSymbol] + '.');
  });
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop = function _loop() {
      var path = _step2.value;
      var remnant = path.slice((arr[arrayPathSymbol] + '.').length);

      if (!Array.isArray(parent.$__.populated[path].value)) {
        return "continue";
      }

      parent.$__.populated[path].value = arr.map(function (val) {
        return val.$populated(remnant);
      });
    };

    for (var _iterator2 = populatedPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}