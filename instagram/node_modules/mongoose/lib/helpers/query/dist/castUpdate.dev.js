'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var CastError = require('../../error/cast');

var MongooseError = require('../../error/mongooseError');

var SchemaString = require('../../schema/string');

var StrictModeError = require('../../error/strict');

var ValidationError = require('../../error/validation');

var castNumber = require('../../cast/number');

var cast = require('../../cast');

var getConstructorName = require('../getConstructorName');

var getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');

var handleImmutable = require('./handleImmutable');

var moveImmutableProperties = require('../update/moveImmutableProperties');

var schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;

var setDottedPath = require('../path/setDottedPath');

var utils = require('../../utils');

var _require = require('../../options'),
    internalToObjectOptions = _require.internalToObjectOptions;

var mongodbUpdateOperators = new Set(['$currentDate', '$inc', '$min', '$max', '$mul', '$rename', '$set', '$setOnInsert', '$unset', '$addToSet', '$pop', '$pull', '$push', '$pullAll', '$bit']);
/**
 * Casts an update op based on the given schema
 *
 * @param {Schema} schema
 * @param {Object} obj
 * @param {Object} [options]
 * @param {Boolean|String} [options.strict] defaults to true
 * @param {Query} context passed to setters
 * @return {Boolean} true iff the update is non-empty
 * @api private
 */

module.exports = function castUpdate(schema, obj, options, context, filter) {
  if (obj == null) {
    return undefined;
  }

  options = options || {}; // Update pipeline

  if (Array.isArray(obj)) {
    var len = obj.length;

    for (var _i = 0; _i < len; ++_i) {
      var _ops = Object.keys(obj[_i]);

      for (var _i2 = 0, _ops2 = _ops; _i2 < _ops2.length; _i2++) {
        var op = _ops2[_i2];
        obj[_i][op] = castPipelineOperator(op, obj[_i][op]);
      }
    }

    return obj;
  }

  if (options.upsert) {
    moveImmutableProperties(schema, obj, context);
  }

  var ops = Object.keys(obj);
  var i = ops.length;
  var ret = {};
  var val;
  var hasDollarKey = false;
  filter = filter || {};

  while (i--) {
    var _op = ops[i];

    if (!mongodbUpdateOperators.has(_op)) {
      // fix up $set sugar
      if (!ret.$set) {
        if (obj.$set) {
          ret.$set = obj.$set;
        } else {
          ret.$set = {};
        }
      }

      ret.$set[_op] = obj[_op];
      ops.splice(i, 1);
      if (!~ops.indexOf('$set')) ops.push('$set');
    } else if (_op === '$set') {
      if (!ret.$set) {
        ret[_op] = obj[_op];
      }
    } else {
      ret[_op] = obj[_op];
    }
  } // cast each value


  i = ops.length;

  while (i--) {
    var _op2 = ops[i];
    val = ret[_op2];
    hasDollarKey = hasDollarKey || _op2.startsWith('$');

    if (val != null && val.$__) {
      val = val.toObject(internalToObjectOptions);
      ret[_op2] = val;
    }

    if (val && _typeof(val) === 'object' && !Buffer.isBuffer(val) && mongodbUpdateOperators.has(_op2)) {
      walkUpdatePath(schema, val, _op2, options, context, filter);
    } else {
      var msg = 'Invalid atomic update value for ' + _op2 + '. ' + 'Expected an object, received ' + _typeof(val);

      throw new Error(msg);
    }

    if (_op2.startsWith('$') && utils.isEmptyObject(val)) {
      delete ret[_op2];
    }
  }

  if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {
    // Trick the driver into allowing empty upserts to work around
    // https://github.com/mongodb/node-mongodb-native/pull/2490
    // Shallow clone to avoid passing defaults in re: gh-13962
    return {
      $setOnInsert: _objectSpread({}, filter)
    };
  }

  return ret;
};
/*!
 * ignore
 */


function castPipelineOperator(op, val) {
  if (op === '$unset') {
    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(function (v) {
      return typeof v !== 'string';
    }))) {
      throw new MongooseError('Invalid $unset in pipeline, must be ' + ' a string or an array of strings');
    }

    return val;
  }

  if (op === '$project') {
    if (val == null || _typeof(val) !== 'object') {
      throw new MongooseError('Invalid $project in pipeline, must be an object');
    }

    return val;
  }

  if (op === '$addFields' || op === '$set') {
    if (val == null || _typeof(val) !== 'object') {
      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');
    }

    return val;
  } else if (op === '$replaceRoot' || op === '$replaceWith') {
    if (val == null || _typeof(val) !== 'object') {
      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');
    }

    return val;
  }

  throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
}
/**
 * Walk each path of obj and cast its values
 * according to its schema.
 *
 * @param {Schema} schema
 * @param {Object} obj part of a query
 * @param {String} op the atomic operator ($pull, $set, etc)
 * @param {Object} [options]
 * @param {Boolean|String} [options.strict]
 * @param {Query} context
 * @param {Object} filter
 * @param {String} pref path prefix (internal only)
 * @return {Bool} true if this path has keys to update
 * @api private
 */


function walkUpdatePath(schema, obj, op, options, context, filter, pref) {
  var strict = options.strict;
  var prefix = pref ? pref + '.' : '';
  var keys = Object.keys(obj);
  var i = keys.length;
  var hasKeys = false;
  var schematype;
  var key;
  var val;
  var aggregatedError = null;
  var strictMode = strict != null ? strict : schema.options.strict;

  while (i--) {
    key = keys[i];
    val = obj[key]; // `$pull` is special because we need to cast the RHS as a query, not as
    // an update.

    if (op === '$pull') {
      schematype = schema._getSchema(prefix + key);

      if (schematype == null) {
        var _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);

        if (_res.schematype != null) {
          schematype = _res.schematype;
        }
      }

      if (schematype != null && schematype.schema != null) {
        obj[key] = cast(schematype.schema, obj[key], options, context);
        hasKeys = true;
        continue;
      }
    }

    var discriminatorKey = prefix ? prefix + key : key;

    if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {
      if (strictMode === 'throw') {
        var err = new Error('Can\'t modify discriminator key "' + discriminatorKey + '" on discriminator model');
        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);
        continue;
      } else if (strictMode) {
        delete obj[key];
        continue;
      }
    }

    if (getConstructorName(val) === 'Object') {
      // watch for embedded doc schemas
      schematype = schema._getSchema(prefix + key);

      if (schematype == null) {
        var _res2 = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);

        if (_res2.schematype != null) {
          schematype = _res2.schematype;
        }
      }

      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
        continue;
      }

      if (schematype && schematype.caster && op in castOps) {
        // embedded doc schema
        if ('$each' in val) {
          hasKeys = true;

          try {
            obj[key] = {
              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
            };
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }

          if (val.$slice != null) {
            obj[key].$slice = val.$slice | 0;
          }

          if (val.$sort) {
            obj[key].$sort = val.$sort;
          }

          if (val.$position != null) {
            obj[key].$position = castNumber(val.$position);
          }
        } else {
          if (schematype != null && schematype.$isSingleNested) {
            var _strict = strict == null ? schematype.schema.options.strict : strict;

            try {
              obj[key] = schematype.castForQuery(null, val, context, {
                strict: _strict
              });
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
          } else {
            try {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
          }

          if (obj[key] === void 0) {
            delete obj[key];
            continue;
          }

          hasKeys = true;
        }
      } else if (op === '$currentDate' || op in castOps && schematype) {
        // $currentDate can take an object
        try {
          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
        } catch (error) {
          aggregatedError = _appendError(error, context, key, aggregatedError);
        }

        if (obj[key] === void 0) {
          delete obj[key];
          continue;
        }

        hasKeys = true;
      } else if (op === '$rename') {
        var _schematype = new SchemaString("".concat(prefix).concat(key, ".$rename"));

        try {
          obj[key] = castUpdateVal(_schematype, val, op, key, context, prefix + key);
        } catch (error) {
          aggregatedError = _appendError(error, context, key, aggregatedError);
        }

        if (obj[key] === void 0) {
          delete obj[key];
          continue;
        }

        hasKeys = true;
      } else {
        var pathToCheck = prefix + key;

        var v = schema._getPathType(pathToCheck);

        var _strict2 = strict;

        if (v && v.schema && _strict2 == null) {
          _strict2 = v.schema.options.strict;
        }

        if (v.pathType === 'undefined') {
          if (_strict2 === 'throw') {
            throw new StrictModeError(pathToCheck);
          } else if (_strict2) {
            delete obj[key];
            continue;
          }
        } // gh-2314
        // we should be able to set a schema-less field
        // to an empty object literal


        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
      }
    } else {
      var checkPath = key === '$each' || key === '$or' || key === '$and' || key === '$in' ? pref : prefix + key;
      schematype = schema._getSchema(checkPath); // You can use `$setOnInsert` with immutable keys

      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
        continue;
      }

      var pathDetails = schema._getPathType(checkPath); // If no schema type, check for embedded discriminators because the
      // filter or update may imply an embedded discriminator type. See #8378


      if (schematype == null) {
        var _res3 = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);

        if (_res3.schematype != null) {
          schematype = _res3.schematype;
          pathDetails = _res3.type;
        }
      }

      var isStrict = strict;

      if (pathDetails && pathDetails.schema && strict == null) {
        isStrict = pathDetails.schema.options.strict;
      }

      var skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);

      if (skip) {
        // Even if strict is `throw`, avoid throwing an error because of
        // virtuals because of #6731
        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {
          throw new StrictModeError(prefix + key);
        } else {
          delete obj[key];
        }
      } else {
        if (op === '$rename') {
          if (obj[key] == null) {
            throw new CastError('String', obj[key], "".concat(prefix).concat(key, ".$rename"));
          }

          var _schematype2 = new SchemaString("".concat(prefix).concat(key, ".$rename"));

          obj[key] = _schematype2.castForQuery(null, obj[key], context);
          continue;
        }

        try {
          if (prefix.length === 0 || key.indexOf('.') === -1) {
            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
          } else if (isStrict !== false || schematype != null) {
            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in
            // a schema, so replace the dotted path with a nested object to avoid ending up with
            // dotted properties in the updated object. See (gh-10200)
            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
            delete obj[key];
          }
        } catch (error) {
          aggregatedError = _appendError(error, context, key, aggregatedError);
        }

        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {
          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {
            obj[key] = {
              $each: obj[key]
            };
          }
        }

        if (obj[key] === void 0) {
          delete obj[key];
          continue;
        }

        hasKeys = true;
      }
    }
  }

  if (aggregatedError != null) {
    throw aggregatedError;
  }

  return hasKeys;
}
/*!
 * ignore
 */


function _appendError(error, query, key, aggregatedError) {
  if (_typeof(query) !== 'object' || !query.options.multipleCastError) {
    throw error;
  }

  aggregatedError = aggregatedError || new ValidationError();
  aggregatedError.addError(key, error);
  return aggregatedError;
}
/**
 * These operators should be cast to numbers instead
 * of their path schema type.
 * @api private
 */


var numberOps = {
  $pop: 1,
  $inc: 1
};
/**
 * These ops require no casting because the RHS doesn't do anything.
 * @api private
 */

var noCastOps = {
  $unset: 1
};
/**
 * These operators require casting docs
 * to real Documents for Update operations.
 * @api private
 */

var castOps = {
  $push: 1,
  $addToSet: 1,
  $set: 1,
  $setOnInsert: 1
};
/*!
 * ignore
 */

var overwriteOps = {
  $set: 1,
  $setOnInsert: 1
};
/**
 * Casts `val` according to `schema` and atomic `op`.
 *
 * @param {SchemaType} schema
 * @param {Object} val
 * @param {String} op the atomic operator ($pull, $set, etc)
 * @param {String} $conditional
 * @param {Query} context
 * @param {String} path
 * @api private
 */

function castUpdateVal(schema, val, op, $conditional, context, path) {
  if (!schema) {
    // non-existing schema path
    if (op in numberOps) {
      try {
        return castNumber(val);
      } catch (err) {
        throw new CastError('number', val, path);
      }
    }

    return val;
  } // console.log('CastUpdateVal', path, op, val, schema);


  var cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));

  if (cond && !overwriteOps[op]) {
    // Cast values for ops that add data to MongoDB.
    // Ensures embedded documents get ObjectIds etc.
    var schemaArrayDepth = 0;
    var cur = schema;

    while (cur.$isMongooseArray) {
      ++schemaArrayDepth;
      cur = cur.caster;
    }

    var arrayDepth = 0;
    var _val = val;

    while (Array.isArray(_val)) {
      ++arrayDepth;
      _val = _val[0];
    }

    var additionalNesting = schemaArrayDepth - arrayDepth;

    while (arrayDepth < schemaArrayDepth) {
      val = [val];
      ++arrayDepth;
    }

    var tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);

    for (var i = 0; i < additionalNesting; ++i) {
      tmp = tmp[0];
    }

    return tmp;
  }

  if (op in noCastOps) {
    return val;
  }

  if (op in numberOps) {
    // Null and undefined not allowed for $pop, $inc
    if (val == null) {
      throw new CastError('number', val, schema.path);
    }

    if (op === '$inc') {
      // Support `$inc` with long, int32, etc. (gh-4283)
      return schema.castForQuery(null, val, context);
    }

    try {
      return castNumber(val);
    } catch (error) {
      throw new CastError('number', val, schema.path);
    }
  }

  if (op === '$currentDate') {
    if (_typeof(val) === 'object') {
      return {
        $type: val.$type
      };
    }

    return Boolean(val);
  }

  if (mongodbUpdateOperators.has($conditional)) {
    return schema.castForQuery($conditional, val, context);
  }

  if (overwriteOps[op]) {
    var skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/);
    var applySetters = schema[schemaMixedSymbol] != null;

    if (skipQueryCastForUpdate || applySetters) {
      return schema.applySetters(val, context);
    }

    return schema.castForQuery(null, val, context);
  }

  return schema.castForQuery(null, val, context);
}