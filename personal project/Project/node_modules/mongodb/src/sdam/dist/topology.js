"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
exports.__esModule = true;
exports.ServerCapabilities = exports.Topology = void 0;
var connection_string_1 = require("../connection_string");
var constants_1 = require("../constants");
var error_1 = require("../error");
var mongo_logger_1 = require("../mongo_logger");
var mongo_types_1 = require("../mongo_types");
var read_preference_1 = require("../read_preference");
var timeout_1 = require("../timeout");
var utils_1 = require("../utils");
var common_1 = require("./common");
var events_1 = require("./events");
var server_1 = require("./server");
var server_description_1 = require("./server_description");
var server_selection_1 = require("./server_selection");
var server_selection_events_1 = require("./server_selection_events");
var srv_polling_1 = require("./srv_polling");
var topology_description_1 = require("./topology_description");
// Global state
var globalTopologyCounter = 0;
var stateTransition = utils_1.makeStateMachine((_a = {},
    _a[common_1.STATE_CLOSED] = [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    _a[common_1.STATE_CONNECTING] = [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    _a[common_1.STATE_CONNECTED] = [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    _a[common_1.STATE_CLOSING] = [common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    _a));
/** @internal */
var kCancelled = Symbol('cancelled');
/** @internal */
var kWaitQueue = Symbol('waitQueue');
/**
 * A container of server instances representing a connection to a MongoDB topology.
 * @internal
 */
var Topology = /** @class */ (function (_super) {
    __extends(Topology, _super);
    /**
     * @param seedlist - a list of HostAddress instances to connect to
     */
    function Topology(client, seeds, options) {
        var _a;
        var _this = _super.call(this) || this;
        _this.client = client;
        // Options should only be undefined in tests, MongoClient will always have defined options
        options = options !== null && options !== void 0 ? options : __assign(__assign({ hosts: [utils_1.HostAddress.fromString('localhost:27017')] }, Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())), Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries()));
        if (typeof seeds === 'string') {
            seeds = [utils_1.HostAddress.fromString(seeds)];
        }
        else if (!Array.isArray(seeds)) {
            seeds = [seeds];
        }
        var seedlist = [];
        for (var _i = 0, seeds_1 = seeds; _i < seeds_1.length; _i++) {
            var seed = seeds_1[_i];
            if (typeof seed === 'string') {
                seedlist.push(utils_1.HostAddress.fromString(seed));
            }
            else if (seed instanceof utils_1.HostAddress) {
                seedlist.push(seed);
            }
            else {
                // FIXME(NODE-3483): May need to be a MongoParseError
                throw new error_1.MongoRuntimeError("Topology cannot be constructed from " + JSON.stringify(seed));
            }
        }
        var topologyType = topologyTypeFromOptions(options);
        var topologyId = globalTopologyCounter++;
        var selectedHosts = options.srvMaxHosts == null ||
            options.srvMaxHosts === 0 ||
            options.srvMaxHosts >= seedlist.length
            ? seedlist
            : utils_1.shuffle(seedlist, options.srvMaxHosts);
        var serverDescriptions = new Map();
        for (var _b = 0, selectedHosts_1 = selectedHosts; _b < selectedHosts_1.length; _b++) {
            var hostAddress = selectedHosts_1[_b];
            serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
        }
        _this[kWaitQueue] = new utils_1.List();
        _this.s = {
            // the id of this topology
            id: topologyId,
            // passed in options
            options: options,
            // initial seedlist of servers to connect to
            seedlist: seedlist,
            // initial state
            state: common_1.STATE_CLOSED,
            // the topology description
            description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
            serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
            heartbeatFrequencyMS: options.heartbeatFrequencyMS,
            minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
            // a map of server instances to normalized addresses
            servers: new Map(),
            credentials: options === null || options === void 0 ? void 0 : options.credentials,
            clusterTime: undefined,
            // timer management
            connectionTimers: new Set(),
            detectShardedTopology: function (ev) { return _this.detectShardedTopology(ev); },
            detectSrvRecords: function (ev) { return _this.detectSrvRecords(ev); }
        };
        _this.mongoLogger = client.mongoLogger;
        _this.component = 'topology';
        if (options.srvHost && !options.loadBalanced) {
            _this.s.srvPoller = (_a = options.srvPoller) !== null && _a !== void 0 ? _a : new srv_polling_1.SrvPoller({
                heartbeatFrequencyMS: _this.s.heartbeatFrequencyMS,
                srvHost: options.srvHost,
                srvMaxHosts: options.srvMaxHosts,
                srvServiceName: options.srvServiceName
            });
            _this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this.s.detectShardedTopology);
        }
        _this.connectionLock = undefined;
        return _this;
    }
    Topology.prototype.detectShardedTopology = function (event) {
        var _a, _b, _c;
        var previousType = event.previousDescription.type;
        var newType = event.newDescription.type;
        var transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
        var srvListeners = (_a = this.s.srvPoller) === null || _a === void 0 ? void 0 : _a.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
        var listeningToSrvPolling = !!(srvListeners === null || srvListeners === void 0 ? void 0 : srvListeners.includes(this.s.detectSrvRecords));
        if (transitionToSharded && !listeningToSrvPolling) {
            (_b = this.s.srvPoller) === null || _b === void 0 ? void 0 : _b.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
            (_c = this.s.srvPoller) === null || _c === void 0 ? void 0 : _c.start();
        }
    };
    Topology.prototype.detectSrvRecords = function (ev) {
        var previousTopologyDescription = this.s.description;
        this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
        if (this.s.description === previousTopologyDescription) {
            // Nothing changed, so return
            return;
        }
        updateServers(this);
        this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    };
    Object.defineProperty(Topology.prototype, "description", {
        /**
         * @returns A `TopologyDescription` for this topology
         */
        get: function () {
            return this.s.description;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Topology.prototype, "loadBalanced", {
        get: function () {
            return this.s.options.loadBalanced;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Topology.prototype, "serverApi", {
        get: function () {
            return this.s.options.serverApi;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Topology.prototype, "capabilities", {
        get: function () {
            return new ServerCapabilities(this.lastHello());
        },
        enumerable: false,
        configurable: true
    });
    /** Initiate server connect */
    Topology.prototype.connect = function (options) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        (_a = this.connectionLock) !== null && _a !== void 0 ? _a : ;
                        this._connect(options);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.connectionLock];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, this];
                    case 3:
                        this.connectionLock = undefined;
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this];
                }
            });
        });
    };
    Topology.prototype._connect = function (options) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var serverDescriptions, _i, serverDescriptions_1, description, newDescription, readPreference, selectServerOptions, server, skipPingOnConnect, error_2;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options = options !== null && options !== void 0 ? options : {};
                        if (this.s.state === common_1.STATE_CONNECTED) {
                            return [2 /*return*/, this];
                        }
                        stateTransition(this, common_1.STATE_CONNECTING);
                        // emit SDAM monitoring events
                        this.emitAndLog(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
                        // emit an event for the topology change
                        this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), // initial is always Unknown
                        this.s.description));
                        serverDescriptions = Array.from(this.s.description.servers.values());
                        this.s.servers = new Map(serverDescriptions.map(function (serverDescription) { return [
                            serverDescription.address,
                            createAndConnectServer(_this, serverDescription)
                        ]; }));
                        // In load balancer mode we need to fake a server description getting
                        // emitted from the monitor, since the monitor doesn't exist.
                        if (this.s.options.loadBalanced) {
                            for (_i = 0, serverDescriptions_1 = serverDescriptions; _i < serverDescriptions_1.length; _i++) {
                                description = serverDescriptions_1[_i];
                                newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
                                    loadBalanced: this.s.options.loadBalanced
                                });
                                this.serverUpdateHandler(newDescription);
                            }
                        }
                        readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
                        selectServerOptions = __assign({ operationName: 'ping' }, options);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 6]);
                        return [4 /*yield*/, this.selectServer(server_selection_1.readPreferenceServerSelector(readPreference), selectServerOptions)];
                    case 2:
                        server = _b.sent();
                        skipPingOnConnect = this.s.options[Symbol["for"]('@@mdb.skipPingOnConnect')] === true;
                        if (!(!skipPingOnConnect && server && this.s.credentials)) return [3 /*break*/, 4];
                        return [4 /*yield*/, server.command(utils_1.ns('admin.$cmd'), { ping: 1 }, {})];
                    case 3:
                        _b.sent();
                        stateTransition(this, common_1.STATE_CONNECTED);
                        this.emit(Topology.OPEN, this);
                        this.emit(Topology.CONNECT, this);
                        return [2 /*return*/, this];
                    case 4:
                        stateTransition(this, common_1.STATE_CONNECTED);
                        this.emit(Topology.OPEN, this);
                        this.emit(Topology.CONNECT, this);
                        return [2 /*return*/, this];
                    case 5:
                        error_2 = _b.sent();
                        this.close();
                        throw error_2;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /** Close this topology */
    Topology.prototype.close = function () {
        if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
            return;
        }
        for (var _i = 0, _a = this.s.servers.values(); _i < _a.length; _i++) {
            var server = _a[_i];
            destroyServer(server, this);
        }
        this.s.servers.clear();
        stateTransition(this, common_1.STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError());
        common_1.drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
            this.s.srvPoller.stop();
            this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        }
        this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        stateTransition(this, common_1.STATE_CLOSED);
        // emit an event for close
        this.emitAndLog(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
    };
    /**
     * Selects a server according to the selection predicate provided
     *
     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
     * @param options - Optional settings related to server selection
     * @param callback - The callback used to indicate success or failure
     * @returns An instance of a `Server` meeting the criteria of the predicate provided
     */
    Topology.prototype.selectServer = function (selector, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, Promise, function () {
            var serverSelector, readPreference, isSharded, session, transaction, _h, serverPromise, resolve, reject, timeout, waitQueueMember, error_3, timeoutError;
            return __generator(this, function (_j) {
                switch (_j.label) {
                    case 0:
                        if (typeof selector !== 'function') {
                            if (typeof selector === 'string') {
                                serverSelector = server_selection_1.readPreferenceServerSelector(read_preference_1.ReadPreference.fromString(selector));
                            }
                            else {
                                readPreference = void 0;
                                if (selector instanceof read_preference_1.ReadPreference) {
                                    readPreference = selector;
                                }
                                else {
                                    read_preference_1.ReadPreference.translate(options);
                                    readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
                                }
                                serverSelector = server_selection_1.readPreferenceServerSelector(readPreference);
                            }
                        }
                        else {
                            serverSelector = selector;
                        }
                        options = __assign({ serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options);
                        if ((_a = this.client.mongoLogger) === null || _a === void 0 ? void 0 : _a.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
                            (_b = this.client.mongoLogger) === null || _b === void 0 ? void 0 : _b.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionStartedEvent(selector, this.description, options.operationName));
                        }
                        isSharded = this.description.type === common_1.TopologyType.Sharded;
                        session = options.session;
                        transaction = session && session.transaction;
                        if (isSharded && transaction && transaction.server) {
                            if ((_c = this.client.mongoLogger) === null || _c === void 0 ? void 0 : _c.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
                                (_d = this.client.mongoLogger) === null || _d === void 0 ? void 0 : _d.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(selector, this.description, transaction.server.pool.address, options.operationName));
                            }
                            return [2 /*return*/, transaction.server];
                        }
                        _h = utils_1.promiseWithResolvers(), serverPromise = _h.promise, resolve = _h.resolve, reject = _h.reject;
                        timeout = timeout_1.Timeout.expires((_e = options.serverSelectionTimeoutMS) !== null && _e !== void 0 ? _e : 0);
                        waitQueueMember = {
                            serverSelector: serverSelector,
                            topologyDescription: this.description,
                            mongoLogger: this.client.mongoLogger,
                            transaction: transaction,
                            resolve: resolve,
                            reject: reject,
                            timeout: timeout,
                            startTime: utils_1.now(),
                            operationName: options.operationName,
                            waitingLogged: false,
                            previousServer: options.previousServer
                        };
                        this[kWaitQueue].push(waitQueueMember);
                        processWaitQueue(this);
                        _j.label = 1;
                    case 1:
                        _j.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.race([serverPromise, waitQueueMember.timeout])];
                    case 2: return [2 /*return*/, _j.sent()];
                    case 3:
                        error_3 = _j.sent();
                        if (timeout_1.TimeoutError.is(error_3)) {
                            // Timeout
                            waitQueueMember[kCancelled] = true;
                            timeout.clear();
                            timeoutError = new error_1.MongoServerSelectionError("Server selection timed out after " + options.serverSelectionTimeoutMS + " ms", this.description);
                            if ((_f = this.client.mongoLogger) === null || _f === void 0 ? void 0 : _f.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
                                (_g = this.client.mongoLogger) === null || _g === void 0 ? void 0 : _g.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(selector, this.description, timeoutError, options.operationName));
                            }
                            throw timeoutError;
                        }
                        // Other server selection error
                        throw error_3;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update the internal TopologyDescription with a ServerDescription
     *
     * @param serverDescription - The server to update in the internal list of server descriptions
     */
    Topology.prototype.serverUpdateHandler = function (serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
            return;
        }
        // ignore this server update if its from an outdated topologyVersion
        if (isStaleServerDescription(this.s.description, serverDescription)) {
            return;
        }
        // these will be used for monitoring events later
        var previousTopologyDescription = this.s.description;
        var previousServerDescription = this.s.description.servers.get(serverDescription.address);
        if (!previousServerDescription) {
            return;
        }
        // Driver Sessions Spec: "Whenever a driver receives a cluster time from
        // a server it MUST compare it to the current highest seen cluster time
        // for the deployment. If the new cluster time is higher than the
        // highest seen cluster time it MUST become the new highest seen cluster
        // time. Two cluster times are compared using only the BsonTimestamp
        // value of the clusterTime embedded field."
        var clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
            common_1._advanceClusterTime(this, clusterTime);
        }
        // If we already know all the information contained in this updated description, then
        // we don't need to emit SDAM events, but still need to update the description, in order
        // to keep client-tracked attributes like last update time and round trip time up to date
        var equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        // first update the TopologyDescription
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
            this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
            return;
        }
        // emit monitoring events for this change
        if (!equalDescriptions) {
            var newDescription = this.s.description.servers.get(serverDescription.address);
            if (newDescription) {
                this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
            }
        }
        // update server list from updated descriptions
        updateServers(this, serverDescription);
        // attempt to resolve any outstanding server selection attempts
        if (this[kWaitQueue].length > 0) {
            processWaitQueue(this);
        }
        if (!equalDescriptions) {
            this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
    };
    Topology.prototype.auth = function (credentials, callback) {
        if (typeof credentials === 'function')
            (callback = credentials), (credentials = undefined);
        if (typeof callback === 'function')
            callback(undefined, true);
    };
    Object.defineProperty(Topology.prototype, "clientMetadata", {
        get: function () {
            return this.s.options.metadata;
        },
        enumerable: false,
        configurable: true
    });
    Topology.prototype.isConnected = function () {
        return this.s.state === common_1.STATE_CONNECTED;
    };
    Topology.prototype.isDestroyed = function () {
        return this.s.state === common_1.STATE_CLOSED;
    };
    // NOTE: There are many places in code where we explicitly check the last hello
    //       to do feature support detection. This should be done any other way, but for
    //       now we will just return the first hello seen, which should suffice.
    Topology.prototype.lastHello = function () {
        var serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
            return {};
        var sd = serverDescriptions.filter(function (sd) { return sd.type !== common_1.ServerType.Unknown; })[0];
        var result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
    };
    Object.defineProperty(Topology.prototype, "commonWireVersion", {
        get: function () {
            return this.description.commonWireVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Topology.prototype, "logicalSessionTimeoutMinutes", {
        get: function () {
            return this.description.logicalSessionTimeoutMinutes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Topology.prototype, "clusterTime", {
        get: function () {
            return this.s.clusterTime;
        },
        set: function (clusterTime) {
            this.s.clusterTime = clusterTime;
        },
        enumerable: false,
        configurable: true
    });
    /** @event */
    Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
    /** @event */
    Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
    /** @event */
    Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
    /** @event */
    Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
    /** @event */
    Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
    /** @event */
    Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
    /** @event */
    Topology.ERROR = constants_1.ERROR;
    /** @event */
    Topology.OPEN = constants_1.OPEN;
    /** @event */
    Topology.CONNECT = constants_1.CONNECT;
    /** @event */
    Topology.CLOSE = constants_1.CLOSE;
    /** @event */
    Topology.TIMEOUT = constants_1.TIMEOUT;
    return Topology;
}(mongo_types_1.TypedEventEmitter));
exports.Topology = Topology;
/** Destroys a server, and removes all event listeners from the instance */
function destroyServer(server, topology) {
    for (var _i = 0, LOCAL_SERVER_EVENTS_1 = constants_1.LOCAL_SERVER_EVENTS; _i < LOCAL_SERVER_EVENTS_1.length; _i++) {
        var event = LOCAL_SERVER_EVENTS_1[_i];
        server.removeAllListeners(event);
    }
    server.destroy();
    topology.emitAndLog(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
    for (var _a = 0, SERVER_RELAY_EVENTS_1 = constants_1.SERVER_RELAY_EVENTS; _a < SERVER_RELAY_EVENTS_1.length; _a++) {
        var event = SERVER_RELAY_EVENTS_1[_a];
        server.removeAllListeners(event);
    }
}
/** Predicts the TopologyType from options */
function topologyTypeFromOptions(options) {
    if (options === null || options === void 0 ? void 0 : options.directConnection) {
        return common_1.TopologyType.Single;
    }
    if (options === null || options === void 0 ? void 0 : options.replicaSet) {
        return common_1.TopologyType.ReplicaSetNoPrimary;
    }
    if (options === null || options === void 0 ? void 0 : options.loadBalanced) {
        return common_1.TopologyType.LoadBalanced;
    }
    return common_1.TopologyType.Unknown;
}
/**
 * Creates new server instances and attempts to connect them
 *
 * @param topology - The topology that this server belongs to
 * @param serverDescription - The description for the server to initialize and connect to
 */
function createAndConnectServer(topology, serverDescription) {
    topology.emitAndLog(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
    var server = new server_1.Server(topology, serverDescription, topology.s.options);
    var _loop_1 = function (event) {
        server.on(event, function (e) { return topology.emit(event, e); });
    };
    for (var _i = 0, SERVER_RELAY_EVENTS_2 = constants_1.SERVER_RELAY_EVENTS; _i < SERVER_RELAY_EVENTS_2.length; _i++) {
        var event = SERVER_RELAY_EVENTS_2[_i];
        _loop_1(event);
    }
    server.on(server_1.Server.DESCRIPTION_RECEIVED, function (description) { return topology.serverUpdateHandler(description); });
    server.connect();
    return server;
}
/**
 * @param topology - Topology to update.
 * @param incomingServerDescription - New server description.
 */
function updateServers(topology, incomingServerDescription) {
    // update the internal server's description
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        var server = topology.s.servers.get(incomingServerDescription.address);
        if (server) {
            server.s.description = incomingServerDescription;
            if (incomingServerDescription.error instanceof error_1.MongoError &&
                incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
                var interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
                server.pool.clear({ interruptInUseConnections: interruptInUseConnections });
            }
            else if (incomingServerDescription.error == null) {
                var newTopologyType = topology.s.description.type;
                var shouldMarkPoolReady = incomingServerDescription.isDataBearing ||
                    (incomingServerDescription.type !== common_1.ServerType.Unknown &&
                        newTopologyType === common_1.TopologyType.Single);
                if (shouldMarkPoolReady) {
                    server.pool.ready();
                }
            }
        }
    }
    // add new servers for all descriptions we currently don't know about locally
    for (var _i = 0, _a = topology.description.servers.values(); _i < _a.length; _i++) {
        var serverDescription = _a[_i];
        if (!topology.s.servers.has(serverDescription.address)) {
            var server = createAndConnectServer(topology, serverDescription);
            topology.s.servers.set(serverDescription.address, server);
        }
    }
    // for all servers no longer known, remove their descriptions and destroy their instances
    for (var _b = 0, _c = topology.s.servers; _b < _c.length; _b++) {
        var entry = _c[_b];
        var serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
            continue;
        }
        if (!topology.s.servers.has(serverAddress)) {
            continue;
        }
        var server = topology.s.servers.get(serverAddress);
        topology.s.servers["delete"](serverAddress);
        // prepare server for garbage collection
        if (server) {
            destroyServer(server, topology);
        }
    }
}
function drainWaitQueue(queue, drainError) {
    var _a, _b;
    while (queue.length) {
        var waitQueueMember = queue.shift();
        if (!waitQueueMember) {
            continue;
        }
        waitQueueMember.timeout.clear();
        if (!waitQueueMember[kCancelled]) {
            if ((_a = waitQueueMember.mongoLogger) === null || _a === void 0 ? void 0 : _a.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
                (_b = waitQueueMember.mongoLogger) === null || _b === void 0 ? void 0 : _b.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, drainError, waitQueueMember.operationName));
            }
            waitQueueMember.reject(drainError);
        }
    }
}
function processWaitQueue(topology) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (topology.s.state === common_1.STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());
        return;
    }
    var isSharded = topology.description.type === common_1.TopologyType.Sharded;
    var serverDescriptions = Array.from(topology.description.servers.values());
    var membersToProcess = topology[kWaitQueue].length;
    for (var i = 0; i < membersToProcess; ++i) {
        var waitQueueMember = topology[kWaitQueue].shift();
        if (!waitQueueMember) {
            continue;
        }
        if (waitQueueMember[kCancelled]) {
            continue;
        }
        var selectedDescriptions = void 0;
        try {
            var serverSelector = waitQueueMember.serverSelector;
            var previousServer = waitQueueMember.previousServer;
            selectedDescriptions = serverSelector
                ? serverSelector(topology.description, serverDescriptions, previousServer ? [previousServer] : [])
                : serverDescriptions;
        }
        catch (selectorError) {
            waitQueueMember.timeout.clear();
            if ((_a = topology.client.mongoLogger) === null || _a === void 0 ? void 0 : _a.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
                (_b = topology.client.mongoLogger) === null || _b === void 0 ? void 0 : _b.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, selectorError, waitQueueMember.operationName));
            }
            waitQueueMember.reject(selectorError);
            continue;
        }
        var selectedServer = void 0;
        if (selectedDescriptions.length === 0) {
            if (!waitQueueMember.waitingLogged) {
                if ((_c = topology.client.mongoLogger) === null || _c === void 0 ? void 0 : _c.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.INFORMATIONAL)) {
                    (_d = topology.client.mongoLogger) === null || _d === void 0 ? void 0 : _d.info(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.WaitingForSuitableServerEvent(waitQueueMember.serverSelector, topology.description, topology.s.serverSelectionTimeoutMS !== 0
                        ? topology.s.serverSelectionTimeoutMS - (utils_1.now() - waitQueueMember.startTime)
                        : -1, waitQueueMember.operationName));
                }
                waitQueueMember.waitingLogged = true;
            }
            topology[kWaitQueue].push(waitQueueMember);
            continue;
        }
        else if (selectedDescriptions.length === 1) {
            selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
        }
        else {
            var descriptions = utils_1.shuffle(selectedDescriptions, 2);
            var server1 = topology.s.servers.get(descriptions[0].address);
            var server2 = topology.s.servers.get(descriptions[1].address);
            selectedServer =
                server1 && server2 && server1.s.operationCount < server2.s.operationCount
                    ? server1
                    : server2;
        }
        if (!selectedServer) {
            var serverSelectionError = new error_1.MongoServerSelectionError('server selection returned a server description but the server was not found in the topology', topology.description);
            if ((_e = topology.client.mongoLogger) === null || _e === void 0 ? void 0 : _e.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
                (_f = topology.client.mongoLogger) === null || _f === void 0 ? void 0 : _f.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, serverSelectionError, waitQueueMember.operationName));
            }
            waitQueueMember.reject(serverSelectionError);
            return;
        }
        var transaction = waitQueueMember.transaction;
        if (isSharded && transaction && transaction.isActive && selectedServer) {
            transaction.pinServer(selectedServer);
        }
        waitQueueMember.timeout.clear();
        if ((_g = topology.client.mongoLogger) === null || _g === void 0 ? void 0 : _g.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            (_h = topology.client.mongoLogger) === null || _h === void 0 ? void 0 : _h.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, selectedServer.pool.address, waitQueueMember.operationName));
        }
        waitQueueMember.resolve(selectedServer);
    }
    if (topology[kWaitQueue].length > 0) {
        var _loop_2 = function (server) {
            process.nextTick(function scheduleServerCheck() {
                return server.requestCheck();
            });
        };
        // ensure all server monitors attempt monitoring soon
        for (var _i = 0, _j = topology.s.servers; _i < _j.length; _i++) {
            var _k = _j[_i], server = _k[1];
            _loop_2(server);
        }
    }
}
function isStaleServerDescription(topologyDescription, incomingServerDescription) {
    var currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    var currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;
    return (server_description_1.compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0);
}
/** @public */
var ServerCapabilities = /** @class */ (function () {
    function ServerCapabilities(hello) {
        this.minWireVersion = hello.minWireVersion || 0;
        this.maxWireVersion = hello.maxWireVersion || 0;
    }
    Object.defineProperty(ServerCapabilities.prototype, "hasAggregationCursor", {
        get: function () {
            return this.maxWireVersion >= 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "hasWriteCommands", {
        get: function () {
            return this.maxWireVersion >= 2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "hasTextSearch", {
        get: function () {
            return this.minWireVersion >= 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "hasAuthCommands", {
        get: function () {
            return this.maxWireVersion >= 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "hasListCollectionsCommand", {
        get: function () {
            return this.maxWireVersion >= 3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "hasListIndexesCommand", {
        get: function () {
            return this.maxWireVersion >= 3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "supportsSnapshotReads", {
        get: function () {
            return this.maxWireVersion >= 13;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "commandsTakeWriteConcern", {
        get: function () {
            return this.maxWireVersion >= 5;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerCapabilities.prototype, "commandsTakeCollation", {
        get: function () {
            return this.maxWireVersion >= 5;
        },
        enumerable: false,
        configurable: true
    });
    return ServerCapabilities;
}());
exports.ServerCapabilities = ServerCapabilities;
