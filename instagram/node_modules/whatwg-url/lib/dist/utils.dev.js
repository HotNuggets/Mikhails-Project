"use strict"; // Returns "Type(value) is Object" in ES terminology.

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen["return"] !== "function") { this["return"] = undefined; } }

if (typeof Symbol === "function" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function isObject(value) {
  return _typeof(value) === "object" && value !== null || typeof value === "function";
}

var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty); // Like `Object.assign`, but using `[[GetOwnProperty]]` and `[[DefineOwnProperty]]`
// instead of `[[Get]]` and `[[Set]]` and only allowing objects

function define(target, source) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Reflect.ownKeys(source)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      var descriptor = Reflect.getOwnPropertyDescriptor(source, key);

      if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
        throw new TypeError("Cannot redefine property: ".concat(String(key)));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function newObjectInRealm(globalObject, object) {
  var ctorRegistry = initCtorRegistry(globalObject);
  return Object.defineProperties(Object.create(ctorRegistry["%Object.prototype%"]), Object.getOwnPropertyDescriptors(object));
}

var wrapperSymbol = Symbol("wrapper");
var implSymbol = Symbol("impl");
var sameObjectCaches = Symbol("SameObject caches");
var ctorRegistrySymbol = Symbol["for"]("[webidl2js] constructor registry");
var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(
/*#__PURE__*/
_wrapAsyncGenerator(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee() {
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
}))).prototype);

function initCtorRegistry(globalObject) {
  if (hasOwn(globalObject, ctorRegistrySymbol)) {
    return globalObject[ctorRegistrySymbol];
  }

  var ctorRegistry = Object.create(null); // In addition to registering all the WebIDL2JS-generated types in the constructor registry,
  // we also register a few intrinsics that we make use of in generated code, since they are not
  // easy to grab from the globalObject variable.

  ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
  ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));

  try {
    ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval("(async function* () {})").prototype));
  } catch (_unused) {
    ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
  }

  globalObject[ctorRegistrySymbol] = ctorRegistry;
  return ctorRegistry;
}

function getSameObject(wrapper, prop, creator) {
  if (!wrapper[sameObjectCaches]) {
    wrapper[sameObjectCaches] = Object.create(null);
  }

  if (prop in wrapper[sameObjectCaches]) {
    return wrapper[sameObjectCaches][prop];
  }

  wrapper[sameObjectCaches][prop] = creator();
  return wrapper[sameObjectCaches][prop];
}

function wrapperForImpl(impl) {
  return impl ? impl[wrapperSymbol] : null;
}

function implForWrapper(wrapper) {
  return wrapper ? wrapper[implSymbol] : null;
}

function tryWrapperForImpl(impl) {
  var wrapper = wrapperForImpl(impl);
  return wrapper ? wrapper : impl;
}

function tryImplForWrapper(wrapper) {
  var impl = implForWrapper(wrapper);
  return impl ? impl : wrapper;
}

var iterInternalSymbol = Symbol("internal");

function isArrayIndexPropName(P) {
  if (typeof P !== "string") {
    return false;
  }

  var i = P >>> 0;

  if (i === Math.pow(2, 32) - 1) {
    return false;
  }

  var s = "".concat(i);

  if (P !== s) {
    return false;
  }

  return true;
}

var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;

function isArrayBuffer(value) {
  try {
    byteLengthGetter.call(value);
    return true;
  } catch (e) {
    return false;
  }
}

function iteratorResult(_ref2, kind) {
  var _ref3 = _slicedToArray(_ref2, 2),
      key = _ref3[0],
      value = _ref3[1];

  var result;

  switch (kind) {
    case "key":
      result = key;
      break;

    case "value":
      result = value;
      break;

    case "key+value":
      result = [key, value];
      break;
  }

  return {
    value: result,
    done: false
  };
}

var supportsPropertyIndex = Symbol("supports property index");
var supportedPropertyIndices = Symbol("supported property indices");
var supportsPropertyName = Symbol("supports property name");
var supportedPropertyNames = Symbol("supported property names");
var indexedGet = Symbol("indexed property get");
var indexedSetNew = Symbol("indexed property set new");
var indexedSetExisting = Symbol("indexed property set existing");
var namedGet = Symbol("named property get");
var namedSetNew = Symbol("named property set new");
var namedSetExisting = Symbol("named property set existing");
var namedDelete = Symbol("named property delete");
var asyncIteratorNext = Symbol("async iterator get the next iteration result");
var asyncIteratorReturn = Symbol("async iterator return steps");
var asyncIteratorInit = Symbol("async iterator initialization steps");
var asyncIteratorEOI = Symbol("async iterator end of iteration");
module.exports = exports = {
  isObject: isObject,
  hasOwn: hasOwn,
  define: define,
  newObjectInRealm: newObjectInRealm,
  wrapperSymbol: wrapperSymbol,
  implSymbol: implSymbol,
  getSameObject: getSameObject,
  ctorRegistrySymbol: ctorRegistrySymbol,
  initCtorRegistry: initCtorRegistry,
  wrapperForImpl: wrapperForImpl,
  implForWrapper: implForWrapper,
  tryWrapperForImpl: tryWrapperForImpl,
  tryImplForWrapper: tryImplForWrapper,
  iterInternalSymbol: iterInternalSymbol,
  isArrayBuffer: isArrayBuffer,
  isArrayIndexPropName: isArrayIndexPropName,
  supportsPropertyIndex: supportsPropertyIndex,
  supportedPropertyIndices: supportedPropertyIndices,
  supportsPropertyName: supportsPropertyName,
  supportedPropertyNames: supportedPropertyNames,
  indexedGet: indexedGet,
  indexedSetNew: indexedSetNew,
  indexedSetExisting: indexedSetExisting,
  namedGet: namedGet,
  namedSetNew: namedSetNew,
  namedSetExisting: namedSetExisting,
  namedDelete: namedDelete,
  asyncIteratorNext: asyncIteratorNext,
  asyncIteratorReturn: asyncIteratorReturn,
  asyncIteratorInit: asyncIteratorInit,
  asyncIteratorEOI: asyncIteratorEOI,
  iteratorResult: iteratorResult
};