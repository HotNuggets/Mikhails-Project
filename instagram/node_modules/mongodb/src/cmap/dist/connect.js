"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.makeSocket = exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.performInitialHandshake = exports.makeConnection = exports.connect = void 0;
var net = require("net");
var tls = require("tls");
var constants_1 = require("../constants");
var deps_1 = require("../deps");
var error_1 = require("../error");
var utils_1 = require("../utils");
var auth_provider_1 = require("./auth/auth_provider");
var providers_1 = require("./auth/providers");
var connection_1 = require("./connection");
var constants_2 = require("./wire_protocol/constants");
function connect(options) {
    return __awaiter(this, void 0, Promise, function () {
        var connection, socket, error_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connection = null;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 4, , 5]);
                    return [4 /*yield*/, makeSocket(options)];
                case 2:
                    socket = _a.sent();
                    connection = makeConnection(options, socket);
                    return [4 /*yield*/, performInitialHandshake(connection, options)];
                case 3:
                    _a.sent();
                    return [2 /*return*/, connection];
                case 4:
                    error_2 = _a.sent();
                    connection === null || connection === void 0 ? void 0 : connection.destroy();
                    throw error_2;
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.connect = connect;
function makeConnection(options, socket) {
    var _a;
    var ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;
    if (options.autoEncrypter) {
        ConnectionType = connection_1.CryptoConnection;
    }
    return new ConnectionType(socket, options);
}
exports.makeConnection = makeConnection;
function checkSupportedServer(hello, options) {
    var _a;
    var maxWireVersion = Number(hello.maxWireVersion);
    var minWireVersion = Number(hello.minWireVersion);
    var serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
    var serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
            return null;
        }
        var message_1 = "Server at " + options.hostAddress + " reports minimum wire version " + JSON.stringify(hello.minWireVersion) + ", but this version of the Node.js Driver requires at most " + constants_2.MAX_SUPPORTED_WIRE_VERSION + " (MongoDB " + constants_2.MAX_SUPPORTED_SERVER_VERSION + ")";
        return new error_1.MongoCompatibilityError(message_1);
    }
    var message = "Server at " + options.hostAddress + " reports maximum wire version " + ((_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0) + ", but this version of the Node.js Driver requires at least " + constants_2.MIN_SUPPORTED_WIRE_VERSION + " (MongoDB " + constants_2.MIN_SUPPORTED_SERVER_VERSION + ")";
    return new error_1.MongoCompatibilityError(message);
}
function performInitialHandshake(conn, options) {
    return __awaiter(this, void 0, Promise, function () {
        var credentials, authContext, handshakeDoc, handshakeOptions, start, response, supportedServerErr, resolvedCredentials, provider, error_3;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    credentials = options.credentials;
                    if (credentials) {
                        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) &&
                            !options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties)) {
                            throw new error_1.MongoInvalidArgumentError("AuthMechanism '" + credentials.mechanism + "' not supported");
                        }
                    }
                    authContext = new auth_provider_1.AuthContext(conn, credentials, options);
                    conn.authContext = authContext;
                    return [4 /*yield*/, prepareHandshakeDocument(authContext)];
                case 1:
                    handshakeDoc = _a.sent();
                    handshakeOptions = __assign(__assign({}, options), { raw: false });
                    if (typeof options.connectTimeoutMS === 'number') {
                        // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS
                        handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
                    }
                    start = new Date().getTime();
                    return [4 /*yield*/, conn.command(utils_1.ns('admin.$cmd'), handshakeDoc, handshakeOptions)];
                case 2:
                    response = _a.sent();
                    if (!('isWritablePrimary' in response)) {
                        // Provide hello-style response document.
                        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
                    }
                    if (response.helloOk) {
                        conn.helloOk = true;
                    }
                    supportedServerErr = checkSupportedServer(response, options);
                    if (supportedServerErr) {
                        throw supportedServerErr;
                    }
                    if (options.loadBalanced) {
                        if (!response.serviceId) {
                            throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' +
                                'but the server does not support this mode.');
                        }
                    }
                    // NOTE: This is metadata attached to the connection while porting away from
                    //       handshake being done in the `Server` class. Likely, it should be
                    //       relocated, or at very least restructured.
                    conn.hello = response;
                    conn.lastHelloMS = new Date().getTime() - start;
                    if (!(!response.arbiterOnly && credentials)) return [3 /*break*/, 6];
                    // store the response on auth context
                    authContext.response = response;
                    resolvedCredentials = credentials.resolveAuthMechanism(response);
                    provider = options.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
                    if (!provider) {
                        throw new error_1.MongoInvalidArgumentError("No AuthProvider for " + resolvedCredentials.mechanism + " defined.");
                    }
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, provider.auth(authContext)];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_3 = _a.sent();
                    if (error_3 instanceof error_1.MongoError) {
                        error_3.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
                        if (error_1.needsRetryableWriteLabel(error_3, response.maxWireVersion, conn.description.type)) {
                            error_3.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
                        }
                    }
                    throw error_3;
                case 6:
                    // Connection establishment is socket creation (tcp handshake, tls handshake, MongoDB handshake (saslStart, saslContinue))
                    // Once connection is established, command logging can log events (if enabled)
                    conn.established = true;
                    return [2 /*return*/];
            }
        });
    });
}
exports.performInitialHandshake = performInitialHandshake;
/**
 * @internal
 *
 * This function is only exposed for testing purposes.
 */
function prepareHandshakeDocument(authContext) {
    return __awaiter(this, void 0, Promise, function () {
        var options, compressors, serverApi, clientMetadata, handshakeDoc, credentials, provider_1, provider;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    options = authContext.options;
                    compressors = options.compressors ? options.compressors : [];
                    serverApi = authContext.connection.serverApi;
                    return [4 /*yield*/, options.extendedMetadata];
                case 1:
                    clientMetadata = _b.sent();
                    handshakeDoc = (_a = {},
                        _a[(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || options.loadBalanced === true ? 'hello' : constants_1.LEGACY_HELLO_COMMAND] = 1,
                        _a.helloOk = true,
                        _a.client = clientMetadata,
                        _a.compression = compressors,
                        _a);
                    if (options.loadBalanced === true) {
                        handshakeDoc.loadBalanced = true;
                    }
                    credentials = authContext.credentials;
                    if (!credentials) return [3 /*break*/, 5];
                    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username)) return [3 /*break*/, 3];
                    handshakeDoc.saslSupportedMechs = credentials.source + "." + credentials.username;
                    provider_1 = authContext.options.authProviders.getOrCreateProvider(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, credentials.mechanismProperties);
                    if (!provider_1) {
                        // This auth mechanism is always present.
                        throw new error_1.MongoInvalidArgumentError("No AuthProvider for " + providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 + " defined.");
                    }
                    return [4 /*yield*/, provider_1.prepare(handshakeDoc, authContext)];
                case 2: return [2 /*return*/, _b.sent()];
                case 3:
                    provider = authContext.options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties);
                    if (!provider) {
                        throw new error_1.MongoInvalidArgumentError("No AuthProvider for " + credentials.mechanism + " defined.");
                    }
                    return [4 /*yield*/, provider.prepare(handshakeDoc, authContext)];
                case 4: return [2 /*return*/, _b.sent()];
                case 5: return [2 /*return*/, handshakeDoc];
            }
        });
    });
}
exports.prepareHandshakeDocument = prepareHandshakeDocument;
/** @public */
exports.LEGAL_TLS_SOCKET_OPTIONS = [
    'allowPartialTrustChain',
    'ALPNProtocols',
    'ca',
    'cert',
    'checkServerIdentity',
    'ciphers',
    'crl',
    'ecdhCurve',
    'key',
    'minDHSize',
    'passphrase',
    'pfx',
    'rejectUnauthorized',
    'secureContext',
    'secureProtocol',
    'servername',
    'session'
];
/** @public */
exports.LEGAL_TCP_SOCKET_OPTIONS = [
    'autoSelectFamily',
    'autoSelectFamilyAttemptTimeout',
    'family',
    'hints',
    'localAddress',
    'localPort',
    'lookup'
];
function parseConnectOptions(options) {
    var hostAddress = options.hostAddress;
    if (!hostAddress)
        throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
    var result = {};
    for (var _i = 0, LEGAL_TCP_SOCKET_OPTIONS_1 = exports.LEGAL_TCP_SOCKET_OPTIONS; _i < LEGAL_TCP_SOCKET_OPTIONS_1.length; _i++) {
        var name = LEGAL_TCP_SOCKET_OPTIONS_1[_i];
        if (options[name] != null) {
            result[name] = options[name];
        }
    }
    if (typeof hostAddress.socketPath === 'string') {
        result.path = hostAddress.socketPath;
        return result;
    }
    else if (typeof hostAddress.host === 'string') {
        result.host = hostAddress.host;
        result.port = hostAddress.port;
        return result;
    }
    else {
        // This should never happen since we set up HostAddresses
        // But if we don't throw here the socket could hang until timeout
        // TODO(NODE-3483)
        throw new error_1.MongoRuntimeError("Unexpected HostAddress " + JSON.stringify(hostAddress));
    }
}
function parseSslOptions(options) {
    var result = parseConnectOptions(options);
    // Merge in valid SSL options
    for (var _i = 0, LEGAL_TLS_SOCKET_OPTIONS_1 = exports.LEGAL_TLS_SOCKET_OPTIONS; _i < LEGAL_TLS_SOCKET_OPTIONS_1.length; _i++) {
        var name = LEGAL_TLS_SOCKET_OPTIONS_1[_i];
        if (options[name] != null) {
            result[name] = options[name];
        }
    }
    if (options.existingSocket) {
        result.socket = options.existingSocket;
    }
    // Set default sni servername to be the same as host
    if (result.servername == null && result.host && !net.isIP(result.host)) {
        result.servername = result.host;
    }
    return result;
}
function makeSocket(options) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, Promise, function () {
        var useTLS, noDelay, connectTimeoutMS, existingSocket, socket, tlsSocket, cancellationHandler, _e, connectedSocket, resolve, reject, connectEvent, error_4;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;
                    noDelay = (_b = options.noDelay) !== null && _b !== void 0 ? _b : true;
                    connectTimeoutMS = (_c = options.connectTimeoutMS) !== null && _c !== void 0 ? _c : 30000;
                    existingSocket = options.existingSocket;
                    if (!(options.proxyHost != null)) return [3 /*break*/, 2];
                    return [4 /*yield*/, makeSocks5Connection(__assign(__assign({}, options), { connectTimeoutMS: connectTimeoutMS // Should always be present for Socks5
                         }))];
                case 1: 
                // Currently, only Socks5 is supported.
                return [2 /*return*/, _f.sent()];
                case 2:
                    if (useTLS) {
                        tlsSocket = tls.connect(parseSslOptions(options));
                        if (typeof tlsSocket.disableRenegotiation === 'function') {
                            tlsSocket.disableRenegotiation();
                        }
                        socket = tlsSocket;
                    }
                    else if (existingSocket) {
                        // In the TLS case, parseSslOptions() sets options.socket to existingSocket,
                        // so we only need to handle the non-TLS case here (where existingSocket
                        // gives us all we need out of the box).
                        socket = existingSocket;
                    }
                    else {
                        socket = net.createConnection(parseConnectOptions(options));
                    }
                    socket.setKeepAlive(true, 300000);
                    socket.setTimeout(connectTimeoutMS);
                    socket.setNoDelay(noDelay);
                    cancellationHandler = null;
                    _e = utils_1.promiseWithResolvers(), connectedSocket = _e.promise, resolve = _e.resolve, reject = _e.reject;
                    if (existingSocket) {
                        resolve(socket);
                    }
                    else {
                        connectEvent = useTLS ? 'secureConnect' : 'connect';
                        socket
                            .once(connectEvent, function () { return resolve(socket); })
                            .once('error', function (error) { return reject(connectionFailureError('error', error)); })
                            .once('timeout', function () { return reject(connectionFailureError('timeout')); })
                            .once('close', function () { return reject(connectionFailureError('close')); });
                        if (options.cancellationToken != null) {
                            cancellationHandler = function () { return reject(connectionFailureError('cancel')); };
                            options.cancellationToken.once('cancel', cancellationHandler);
                        }
                    }
                    _f.label = 3;
                case 3:
                    _f.trys.push([3, 5, 6, 7]);
                    return [4 /*yield*/, connectedSocket];
                case 4:
                    socket = _f.sent();
                    return [2 /*return*/, socket];
                case 5:
                    error_4 = _f.sent();
                    socket.destroy();
                    throw error_4;
                case 6:
                    socket.setTimeout(0);
                    socket.removeAllListeners();
                    if (cancellationHandler != null) {
                        (_d = options.cancellationToken) === null || _d === void 0 ? void 0 : _d.removeListener('cancel', cancellationHandler);
                    }
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    });
}
exports.makeSocket = makeSocket;
var socks = null;
function loadSocks() {
    if (socks == null) {
        var socksImport = deps_1.getSocks();
        if ('kModuleError' in socksImport) {
            throw socksImport.kModuleError;
        }
        socks = socksImport;
    }
    return socks;
}
function makeSocks5Connection(options) {
    var _a, _b;
    return __awaiter(this, void 0, Promise, function () {
        var hostAddress, rawSocket, destination, socket, error_5;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '', (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080);
                    return [4 /*yield*/, makeSocket(__assign(__assign({}, options), { hostAddress: hostAddress, tls: false, proxyHost: undefined }))];
                case 1:
                    rawSocket = _c.sent();
                    destination = parseConnectOptions(options);
                    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {
                        throw new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts');
                    }
                    socks !== null && socks !== void 0 ? socks : ;
                    loadSocks();
                    _c.label = 2;
                case 2:
                    _c.trys.push([2, 5, , 6]);
                    return [4 /*yield*/, socks.SocksClient.createConnection({
                            existing_socket: rawSocket,
                            timeout: options.connectTimeoutMS,
                            command: 'connect',
                            destination: {
                                host: destination.host,
                                port: destination.port
                            },
                            proxy: {
                                // host and port are ignored because we pass existing_socket
                                host: 'iLoveJavaScript',
                                port: 0,
                                type: 5,
                                userId: options.proxyUsername || undefined,
                                password: options.proxyPassword || undefined
                            }
                        })];
                case 3:
                    socket = (_c.sent()).socket;
                    return [4 /*yield*/, makeSocket(__assign(__assign({}, options), { existingSocket: socket, proxyHost: undefined }))];
                case 4: 
                // Finally, now treat the resulting duplex stream as the
                // socket over which we send and receive wire protocol messages:
                return [2 /*return*/, _c.sent()];
                case 5:
                    error_5 = _c.sent();
                    throw connectionFailureError('error', error_5);
                case 6: return [2 /*return*/];
            }
        });
    });
}
function connectionFailureError(type, cause) {
    switch (type) {
        case 'error':
            return new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause: cause });
        case 'timeout':
            return new error_1.MongoNetworkTimeoutError('connection timed out');
        case 'close':
            return new error_1.MongoNetworkError('connection closed');
        case 'cancel':
            return new error_1.MongoNetworkError('connection establishment was cancelled');
        default:
            return new error_1.MongoNetworkError('unknown network error');
    }
}
