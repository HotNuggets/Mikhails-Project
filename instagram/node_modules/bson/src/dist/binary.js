"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.UUID = exports.Binary = void 0;
var utils_1 = require("./parser/utils");
var error_1 = require("./error");
var constants_1 = require("./constants");
var byte_utils_1 = require("./utils/byte_utils");
var bson_value_1 = require("./bson_value");
/**
 * A class representation of the BSON Binary type.
 * @public
 * @category BSONType
 */
var Binary = /** @class */ (function (_super) {
    __extends(Binary, _super);
    /**
     * Create a new Binary instance.
     * @param buffer - a buffer object containing the binary data.
     * @param subType - the option binary type.
     */
    function Binary(buffer, subType) {
        var _this = _super.call(this) || this;
        if (!(buffer == null) &&
            typeof buffer === 'string' &&
            !ArrayBuffer.isView(buffer) &&
            !utils_1.isAnyArrayBuffer(buffer) &&
            !Array.isArray(buffer)) {
            throw new error_1.BSONError('Binary can only be constructed from Uint8Array or number[]');
        }
        _this.sub_type = subType !== null && subType !== void 0 ? subType : Binary.BSON_BINARY_SUBTYPE_DEFAULT;
        if (buffer == null) {
            // create an empty binary buffer
            _this.buffer = byte_utils_1.ByteUtils.allocate(Binary.BUFFER_SIZE);
            _this.position = 0;
        }
        else {
            _this.buffer = Array.isArray(buffer)
                ? byte_utils_1.ByteUtils.fromNumberArray(buffer)
                : byte_utils_1.ByteUtils.toLocalBufferType(buffer);
            _this.position = _this.buffer.byteLength;
        }
        return _this;
    }
    Object.defineProperty(Binary.prototype, "_bsontype", {
        get: function () {
            return 'Binary';
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Updates this binary with byte_value.
     *
     * @param byteValue - a single byte we wish to write.
     */
    Binary.prototype.put = function (byteValue) {
        // If it's a string and a has more than one character throw an error
        if (typeof byteValue === 'string' && byteValue.length !== 1) {
            throw new error_1.BSONError('only accepts single character String');
        }
        else if (typeof byteValue !== 'number' && byteValue.length !== 1)
            throw new error_1.BSONError('only accepts single character Uint8Array or Array');
        // Decode the byte value once
        var decodedByte;
        if (typeof byteValue === 'string') {
            decodedByte = byteValue.charCodeAt(0);
        }
        else if (typeof byteValue === 'number') {
            decodedByte = byteValue;
        }
        else {
            decodedByte = byteValue[0];
        }
        if (decodedByte < 0 || decodedByte > 255) {
            throw new error_1.BSONError('only accepts number in a valid unsigned byte range 0-255');
        }
        if (this.buffer.byteLength > this.position) {
            this.buffer[this.position++] = decodedByte;
        }
        else {
            var newSpace = byte_utils_1.ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
            newSpace.set(this.buffer, 0);
            this.buffer = newSpace;
            this.buffer[this.position++] = decodedByte;
        }
    };
    /**
     * Writes a buffer to the binary.
     *
     * @param sequence - a string or buffer to be written to the Binary BSON object.
     * @param offset - specify the binary of where to write the content.
     */
    Binary.prototype.write = function (sequence, offset) {
        offset = typeof offset === 'number' ? offset : this.position;
        // If the buffer is to small let's extend the buffer
        if (this.buffer.byteLength < offset + sequence.length) {
            var newSpace = byte_utils_1.ByteUtils.allocate(this.buffer.byteLength + sequence.length);
            newSpace.set(this.buffer, 0);
            // Assign the new buffer
            this.buffer = newSpace;
        }
        if (ArrayBuffer.isView(sequence)) {
            this.buffer.set(byte_utils_1.ByteUtils.toLocalBufferType(sequence), offset);
            this.position =
                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
        }
        else if (typeof sequence === 'string') {
            throw new error_1.BSONError('input cannot be string');
        }
    };
    /**
     * Reads **length** bytes starting at **position**.
     *
     * @param position - read from the given position in the Binary.
     * @param length - the number of bytes to read.
     */
    Binary.prototype.read = function (position, length) {
        length = length && length > 0 ? length : this.position;
        // Let's return the data based on the type we have
        return this.buffer.slice(position, position + length);
    };
    /** returns a view of the binary value as a Uint8Array */
    Binary.prototype.value = function () {
        // Optimize to serialize for the situation where the data == size of buffer
        return this.buffer.length === this.position
            ? this.buffer
            : this.buffer.subarray(0, this.position);
    };
    /** the length of the binary sequence */
    Binary.prototype.length = function () {
        return this.position;
    };
    Binary.prototype.toJSON = function () {
        return byte_utils_1.ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    };
    Binary.prototype.toString = function (encoding) {
        if (encoding === 'hex')
            return byte_utils_1.ByteUtils.toHex(this.buffer.subarray(0, this.position));
        if (encoding === 'base64')
            return byte_utils_1.ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        if (encoding === 'utf8' || encoding === 'utf-8')
            return byte_utils_1.ByteUtils.toUTF8(this.buffer, 0, this.position, false);
        return byte_utils_1.ByteUtils.toUTF8(this.buffer, 0, this.position, false);
    };
    /** @internal */
    Binary.prototype.toExtendedJSON = function (options) {
        options = options || {};
        var base64String = byte_utils_1.ByteUtils.toBase64(this.buffer);
        var subType = Number(this.sub_type).toString(16);
        if (options.legacy) {
            return {
                $binary: base64String,
                $type: subType.length === 1 ? '0' + subType : subType
            };
        }
        return {
            $binary: {
                base64: base64String,
                subType: subType.length === 1 ? '0' + subType : subType
            }
        };
    };
    Binary.prototype.toUUID = function () {
        if (this.sub_type === Binary.SUBTYPE_UUID) {
            return new UUID(this.buffer.slice(0, this.position));
        }
        throw new error_1.BSONError("Binary sub_type \"" + this.sub_type + "\" is not supported for converting to UUID. Only \"" + Binary.SUBTYPE_UUID + "\" is currently supported.");
    };
    /** Creates an Binary instance from a hex digit string */
    Binary.createFromHexString = function (hex, subType) {
        return new Binary(byte_utils_1.ByteUtils.fromHex(hex), subType);
    };
    /** Creates an Binary instance from a base64 string */
    Binary.createFromBase64 = function (base64, subType) {
        return new Binary(byte_utils_1.ByteUtils.fromBase64(base64), subType);
    };
    /** @internal */
    Binary.fromExtendedJSON = function (doc, options) {
        options = options || {};
        var data;
        var type;
        if ('$binary' in doc) {
            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {
                type = doc.$type ? parseInt(doc.$type, 16) : 0;
                data = byte_utils_1.ByteUtils.fromBase64(doc.$binary);
            }
            else {
                if (typeof doc.$binary !== 'string') {
                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
                    data = byte_utils_1.ByteUtils.fromBase64(doc.$binary.base64);
                }
            }
        }
        else if ('$uuid' in doc) {
            type = 4;
            data = UUID.bytesFromString(doc.$uuid);
        }
        if (!data) {
            throw new error_1.BSONError("Unexpected Binary Extended JSON format " + JSON.stringify(doc));
        }
        return type === constants_1.BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    };
    Binary.prototype.inspect = function (depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : ;
        utils_1.defaultInspect;
        var base64 = byte_utils_1.ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        var base64Arg = inspect(base64, options);
        var subTypeArg = inspect(this.sub_type, options);
        return "Binary.createFromBase64(" + base64Arg + ", " + subTypeArg + ")";
    };
    /**
     * Binary default subtype
     * @internal
     */
    Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    /** Initial buffer default size */
    Binary.BUFFER_SIZE = 256;
    /** Default BSON type */
    Binary.SUBTYPE_DEFAULT = 0;
    /** Function BSON type */
    Binary.SUBTYPE_FUNCTION = 1;
    /** Byte Array BSON type */
    Binary.SUBTYPE_BYTE_ARRAY = 2;
    /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */
    Binary.SUBTYPE_UUID_OLD = 3;
    /** UUID BSON type */
    Binary.SUBTYPE_UUID = 4;
    /** MD5 BSON type */
    Binary.SUBTYPE_MD5 = 5;
    /** Encrypted BSON type */
    Binary.SUBTYPE_ENCRYPTED = 6;
    /** Column BSON type */
    Binary.SUBTYPE_COLUMN = 7;
    /** Sensitive BSON type */
    Binary.SUBTYPE_SENSITIVE = 8;
    /** User BSON type */
    Binary.SUBTYPE_USER_DEFINED = 128;
    return Binary;
}(bson_value_1.BSONValue));
exports.Binary = Binary;
var UUID_BYTE_LENGTH = 16;
var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
/**
 * A class representation of the BSON UUID type.
 * @public
 */
var UUID = /** @class */ (function (_super) {
    __extends(UUID, _super);
    /**
     * Create a UUID type
     *
     * When the argument to the constructor is omitted a random v4 UUID will be generated.
     *
     * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.
     */
    function UUID(input) {
        var _this = this;
        var bytes;
        if (input == null) {
            bytes = UUID.generate();
        }
        else if (input instanceof UUID) {
            bytes = byte_utils_1.ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
        }
        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
            bytes = byte_utils_1.ByteUtils.toLocalBufferType(input);
        }
        else if (typeof input === 'string') {
            bytes = UUID.bytesFromString(input);
        }
        else {
            throw new error_1.BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');
        }
        _this = _super.call(this, bytes, constants_1.BSON_BINARY_SUBTYPE_UUID_NEW) || this;
        return _this;
    }
    Object.defineProperty(UUID.prototype, "id", {
        /**
         * The UUID bytes
         * @readonly
         */
        get: function () {
            return this.buffer;
        },
        set: function (value) {
            this.buffer = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)
     * @param includeDashes - should the string exclude dash-separators.
     */
    UUID.prototype.toHexString = function (includeDashes) {
        if (includeDashes === void 0) { includeDashes = true; }
        if (includeDashes) {
            return [
                byte_utils_1.ByteUtils.toHex(this.buffer.subarray(0, 4)),
                byte_utils_1.ByteUtils.toHex(this.buffer.subarray(4, 6)),
                byte_utils_1.ByteUtils.toHex(this.buffer.subarray(6, 8)),
                byte_utils_1.ByteUtils.toHex(this.buffer.subarray(8, 10)),
                byte_utils_1.ByteUtils.toHex(this.buffer.subarray(10, 16))
            ].join('-');
        }
        return byte_utils_1.ByteUtils.toHex(this.buffer);
    };
    /**
     * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.
     */
    UUID.prototype.toString = function (encoding) {
        if (encoding === 'hex')
            return byte_utils_1.ByteUtils.toHex(this.id);
        if (encoding === 'base64')
            return byte_utils_1.ByteUtils.toBase64(this.id);
        return this.toHexString();
    };
    /**
     * Converts the id into its JSON string representation.
     * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
     */
    UUID.prototype.toJSON = function () {
        return this.toHexString();
    };
    /**
     * Compares the equality of this UUID with `otherID`.
     *
     * @param otherId - UUID instance to compare against.
     */
    UUID.prototype.equals = function (otherId) {
        if (!otherId) {
            return false;
        }
        if (otherId instanceof UUID) {
            return byte_utils_1.ByteUtils.equals(otherId.id, this.id);
        }
        try {
            return byte_utils_1.ByteUtils.equals(new UUID(otherId).id, this.id);
        }
        catch (_a) {
            return false;
        }
    };
    /**
     * Creates a Binary instance from the current UUID.
     */
    UUID.prototype.toBinary = function () {
        return new Binary(this.id, Binary.SUBTYPE_UUID);
    };
    /**
     * Generates a populated buffer containing a v4 uuid
     */
    UUID.generate = function () {
        var bytes = byte_utils_1.ByteUtils.randomBytes(UUID_BYTE_LENGTH);
        // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
        // Kindly borrowed from https://github.com/uuidjs/uuid/blob/master/src/v4.js
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        return bytes;
    };
    /**
     * Checks if a value is a valid bson UUID
     * @param input - UUID, string or Buffer to validate.
     */
    UUID.isValid = function (input) {
        if (!input) {
            return false;
        }
        if (typeof input === 'string') {
            return UUID.isValidUUIDString(input);
        }
        if (utils_1.isUint8Array(input)) {
            return input.byteLength === UUID_BYTE_LENGTH;
        }
        return (input._bsontype === 'Binary' &&
            input.sub_type === this.SUBTYPE_UUID &&
            input.buffer.byteLength === 16);
    };
    UUID.prototype.createFromHexString = function (hexString) {
        var buffer = UUID.bytesFromString(hexString);
        return new UUID(buffer);
    };
    UUID.prototype.createFromBase64 = function (base64) {
        return new UUID(byte_utils_1.ByteUtils.fromBase64(base64));
    };
    /** @internal */
    UUID.bytesFromString = function (representation) {
        if (!UUID.isValidUUIDString(representation)) {
            throw new error_1.BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');
        }
        return byte_utils_1.ByteUtils.fromHex(representation.replace(/-/g, ''));
    };
    /**
     * @internal
     *
     * Validates a string to be a hex digit sequence with or without dashes.
     * The canonical hyphenated representation of a uuid is hex in 8-4-4-4-12 groups.
     */
    UUID.isValidUUIDString = function (representation) {
        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    };
    /**
     * Converts to a string representation of this Id.
     *
     * @returns return the 36 character hex string representation.
     *
     */
    UUID.prototype.inspect = function (depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : ;
        utils_1.defaultInspect;
        return "new UUID(" + inspect(this.toHexString(), options) + ")";
    };
    return UUID;
}(Binary));
exports.UUID = UUID;
