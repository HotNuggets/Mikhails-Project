"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
exports.__esModule = true;
exports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = void 0;
var net = require("net");
var bson_1 = require("../bson");
var constants_1 = require("../constants");
var deps_1 = require("../deps");
var error_1 = require("../error");
var mongo_client_1 = require("../mongo_client");
var utils_1 = require("../utils");
var client_encryption_1 = require("./client_encryption");
var cryptoCallbacks = require("./crypto_callbacks");
var errors_1 = require("./errors");
var mongocryptd_manager_1 = require("./mongocryptd_manager");
var providers_1 = require("./providers");
var state_machine_1 = require("./state_machine");
/** @public */
exports.AutoEncryptionLoggerLevel = Object.freeze({
    FatalError: 0,
    Error: 1,
    Warning: 2,
    Info: 3,
    Trace: 4
});
/**
 * @internal An internal class to be used by the driver for auto encryption
 * **NOTE**: Not meant to be instantiated directly, this is for internal use only.
 */
var AutoEncrypter = /** @class */ (function () {
    /**
     * Create an AutoEncrypter
     *
     * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient
     *
     * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.
     * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.
     * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.
     * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.
     *
     * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>
     * ```ts
     * // Enabling autoEncryption via a MongoClient using mongocryptd
     * const { MongoClient } = require('mongodb');
     * const client = new MongoClient(URL, {
     *   autoEncryption: {
     *     kmsProviders: {
     *       aws: {
     *         accessKeyId: AWS_ACCESS_KEY,
     *         secretAccessKey: AWS_SECRET_KEY
     *       }
     *     }
     *   }
     * });
     * ```
     *
     * await client.connect();
     * // From here on, the client will be encrypting / decrypting automatically
     * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>
     * ```ts
     * // Enabling autoEncryption via a MongoClient using CSFLE shared library
     * const { MongoClient } = require('mongodb');
     * const client = new MongoClient(URL, {
     *   autoEncryption: {
     *     kmsProviders: {
     *       aws: {}
     *     },
     *     extraOptions: {
     *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',
     *       cryptSharedLibRequired: true
     *     }
     *   }
     * });
     * ```
     *
     * await client.connect();
     * // From here on, the client will be encrypting / decrypting automatically
     */
    function AutoEncrypter(client, options) {
        var _b;
        /**
         * Used by devtools to enable decorating decryption results.
         *
         * When set and enabled, `decrypt` will automatically recursively
         * traverse a decrypted document and if a field has been decrypted,
         * it will mark it as decrypted.  Compass uses this to determine which
         * fields were decrypted.
         */
        this[_a] = false;
        this._client = client;
        this._bypassEncryption = options.bypassAutoEncryption === true;
        this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';
        this._keyVaultClient = options.keyVaultClient || client;
        this._metaDataClient = options.metadataClient || client;
        this._proxyOptions = options.proxyOptions || {};
        this._tlsOptions = options.tlsOptions || {};
        this._kmsProviders = options.kmsProviders || {};
        var mongoCryptOptions = {
            cryptoCallbacks: cryptoCallbacks
        };
        if (options.schemaMap) {
            mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)
                ? options.schemaMap
                : bson_1.serialize(options.schemaMap);
        }
        if (options.encryptedFieldsMap) {
            mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap)
                ? options.encryptedFieldsMap
                : bson_1.serialize(options.encryptedFieldsMap);
        }
        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders)
            ? bson_1.serialize(this._kmsProviders)
            : this._kmsProviders;
        if ((_b = options.options) === null || _b === void 0 ? void 0 : _b.logger) {
            mongoCryptOptions.logger = options.options.logger;
        }
        if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {
            mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;
        }
        if (options.bypassQueryAnalysis) {
            mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;
        }
        this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;
        if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {
            // Only for driver testing
            mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;
        }
        else if (!this._bypassMongocryptdAndCryptShared) {
            mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];
        }
        var MongoCrypt = AutoEncrypter.getMongoCrypt();
        this._mongocrypt = new MongoCrypt(mongoCryptOptions);
        this._contextCounter = 0;
        if (options.extraOptions &&
            options.extraOptions.cryptSharedLibRequired &&
            !this.cryptSharedLibVersionInfo) {
            throw new errors_1.MongoCryptInvalidArgumentError('`cryptSharedLibRequired` set but no crypt_shared library loaded');
        }
        // Only instantiate mongocryptd manager/client once we know for sure
        // that we are not using the CSFLE shared library.
        if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
            this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);
            var clientOptions = {
                serverSelectionTimeoutMS: 10000
            };
            if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') &&
                !net.getDefaultAutoSelectFamily) {
                // Only set family if autoSelectFamily options are not supported.
                clientOptions.family = 4;
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore: TS complains as this always returns true on versions where it is present.
            if (net.getDefaultAutoSelectFamily) {
                Object.assign(clientOptions, client_encryption_1.autoSelectSocketOptions(this._client.options));
            }
            this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
        }
    }
    /** @internal */
    AutoEncrypter.getMongoCrypt = function () {
        var encryption = deps_1.getMongoDBClientEncryption();
        if ('kModuleError' in encryption) {
            throw encryption.kModuleError;
        }
        return encryption.MongoCrypt;
    };
    /**
     * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.
     *
     * This function is a no-op when bypassSpawn is set or the crypt shared library is used.
     */
    AutoEncrypter.prototype.init = function () {
        return __awaiter(this, void 0, Promise, function () {
            var client, error_2, message;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
                            return [2 /*return*/];
                        }
                        if (!this._mongocryptdManager) {
                            throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.');
                        }
                        if (!this._mongocryptdClient) {
                            throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.');
                        }
                        if (!!this._mongocryptdManager.bypassSpawn) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._mongocryptdManager.spawn()];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this._mongocryptdClient.connect()];
                    case 3:
                        client = _b.sent();
                        return [2 /*return*/, client];
                    case 4:
                        error_2 = _b.sent();
                        message = error_2.message;
                        if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {
                            throw new error_1.MongoRuntimeError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn', { cause: error_2 });
                        }
                        throw error_2;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Cleans up the `_mongocryptdClient`, if present.
     */
    AutoEncrypter.prototype.teardown = function (force) {
        var _b;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, ((_b = this._mongocryptdClient) === null || _b === void 0 ? void 0 : _b.close(force))];
                    case 1:
                        _c.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Encrypt a command for a given namespace.
     */
    AutoEncrypter.prototype.encrypt = function (ns, cmd, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            var commandBuffer, context, stateMachine, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this._bypassEncryption) {
                            // If `bypassAutoEncryption` has been specified, don't encrypt
                            return [2 /*return*/, cmd];
                        }
                        commandBuffer = Buffer.isBuffer(cmd) ? cmd : bson_1.serialize(cmd, options);
                        context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
                        context.id = this._contextCounter++;
                        context.ns = ns;
                        context.document = cmd;
                        stateMachine = new state_machine_1.StateMachine({
                            promoteValues: false,
                            promoteLongs: false,
                            proxyOptions: this._proxyOptions,
                            tlsOptions: this._tlsOptions,
                            socketOptions: client_encryption_1.autoSelectSocketOptions(this._client.options)
                        });
                        _b = bson_1.deserialize;
                        return [4 /*yield*/, stateMachine.execute(this, context)];
                    case 1: return [2 /*return*/, _b.apply(void 0, [_c.sent(), {
                                promoteValues: false,
                                promoteLongs: false
                            }])];
                }
            });
        });
    };
    /**
     * Decrypt a command response
     */
    AutoEncrypter.prototype.decrypt = function (response, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            var context, stateMachine;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        context = this._mongocrypt.makeDecryptionContext(response);
                        context.id = this._contextCounter++;
                        stateMachine = new state_machine_1.StateMachine(__assign(__assign({}, options), { proxyOptions: this._proxyOptions, tlsOptions: this._tlsOptions, socketOptions: client_encryption_1.autoSelectSocketOptions(this._client.options) }));
                        return [4 /*yield*/, stateMachine.execute(this, context)];
                    case 1: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    /**
     * Ask the user for KMS credentials.
     *
     * This returns anything that looks like the kmsProviders original input
     * option. It can be empty, and any provider specified here will override
     * the original ones.
     */
    AutoEncrypter.prototype.askForKMSCredentials = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, providers_1.refreshKMSCredentials(this._kmsProviders)];
                    case 1: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    Object.defineProperty(AutoEncrypter.prototype, "cryptSharedLibVersionInfo", {
        /**
         * Return the current libmongocrypt's CSFLE shared library version
         * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE
         * shared library was loaded.
         */
        get: function () {
            return this._mongocrypt.cryptSharedLibVersionInfo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AutoEncrypter, "libmongocryptVersion", {
        get: function () {
            return AutoEncrypter.getMongoCrypt().libmongocryptVersion;
        },
        enumerable: false,
        configurable: true
    });
    return AutoEncrypter;
}());
exports.AutoEncrypter = AutoEncrypter;
_a = constants_1.kDecorateResult;
