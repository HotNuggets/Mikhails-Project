"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MongocryptdManager = void 0;

var error_1 = require("../error");
/**
 * @internal
 * An internal class that handles spawning a mongocryptd.
 */


var MongocryptdManager =
/*#__PURE__*/
function () {
  function MongocryptdManager() {
    var extraOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MongocryptdManager);

    this.spawnPath = '';
    this.spawnArgs = [];
    this.uri = typeof extraOptions.mongocryptdURI === 'string' && extraOptions.mongocryptdURI.length > 0 ? extraOptions.mongocryptdURI : MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
    this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;

    if (Object.hasOwn(extraOptions, 'mongocryptdSpawnPath') && extraOptions.mongocryptdSpawnPath) {
      this.spawnPath = extraOptions.mongocryptdSpawnPath;
    }

    if (Object.hasOwn(extraOptions, 'mongocryptdSpawnArgs') && Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
      this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
    }

    if (this.spawnArgs.filter(function (arg) {
      return typeof arg === 'string';
    }).every(function (arg) {
      return arg.indexOf('--idleShutdownTimeoutSecs') < 0;
    })) {
      this.spawnArgs.push('--idleShutdownTimeoutSecs', '60');
    }
  }
  /**
   * Will check to see if a mongocryptd is up. If it is not up, it will attempt
   * to spawn a mongocryptd in a detached process, and then wait for it to be up.
   */


  _createClass(MongocryptdManager, [{
    key: "spawn",
    value: function spawn() {
      var cmdName, _require, spawn;

      return regeneratorRuntime.async(function spawn$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cmdName = this.spawnPath || 'mongocryptd'; // eslint-disable-next-line @typescript-eslint/no-require-imports

              _require = require('child_process'), spawn = _require.spawn; // Spawned with stdio: ignore and detached: true
              // to ensure child can outlive parent.

              this._child = spawn(cmdName, this.spawnArgs, {
                stdio: 'ignore',
                detached: true
              });

              this._child.on('error', function () {// From the FLE spec:
                // "The stdout and stderr of the spawned process MUST not be exposed in the driver
                // (e.g. redirect to /dev/null). Users can pass the argument --logpath to
                // extraOptions.mongocryptdSpawnArgs if they need to inspect mongocryptd logs.
                // If spawning is necessary, the driver MUST spawn mongocryptd whenever server
                // selection on the MongoClient to mongocryptd fails. If the MongoClient fails to
                // connect after spawning, the server selection error is propagated to the user."
                // The AutoEncrypter and MongoCryptdManager should work together to spawn
                // mongocryptd whenever necessary.  Additionally, the `mongocryptd` intentionally
                // shuts down after 60s and gets respawned when necessary.  We rely on server
                // selection timeouts when connecting to the `mongocryptd` to inform users that something
                // has been configured incorrectly.  For those reasons, we suppress stderr from
                // the `mongocryptd` process and immediately unref the process.
              }); // unref child to remove handle from event loop


              this._child.unref();

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * @returns the result of `fn` or rejects with an error.
     */

  }, {
    key: "withRespawn",
    value: function withRespawn(fn) {
      var _result, shouldSpawn, result;

      return regeneratorRuntime.async(function withRespawn$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return regeneratorRuntime.awrap(fn());

            case 3:
              _result = _context2.sent;
              return _context2.abrupt("return", _result);

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](0);
              // If we are not bypassing spawning, then we should retry once on a MongoTimeoutError (server selection error)
              shouldSpawn = _context2.t0 instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;

              if (shouldSpawn) {
                _context2.next = 12;
                break;
              }

              throw _context2.t0;

            case 12:
              _context2.next = 14;
              return regeneratorRuntime.awrap(this.spawn());

            case 14:
              _context2.next = 16;
              return regeneratorRuntime.awrap(fn());

            case 16:
              result = _context2.sent;
              return _context2.abrupt("return", result);

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[0, 7]]);
    }
  }]);

  return MongocryptdManager;
}();

exports.MongocryptdManager = MongocryptdManager;
MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = 'mongodb://localhost:27020';