"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
exports.__esModule = true;
exports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;
var bson_1 = require("./bson");
var metrics_1 = require("./cmap/metrics");
var shared_1 = require("./cmap/wire_protocol/shared");
var constants_1 = require("./constants");
var error_1 = require("./error");
var mongo_types_1 = require("./mongo_types");
var execute_operation_1 = require("./operations/execute_operation");
var run_command_1 = require("./operations/run_command");
var read_concern_1 = require("./read_concern");
var read_preference_1 = require("./read_preference");
var resource_management_1 = require("./resource_management");
var common_1 = require("./sdam/common");
var transactions_1 = require("./transactions");
var utils_1 = require("./utils");
var write_concern_1 = require("./write_concern");
var minWireVersionForShardedTransactions = 8;
/** @internal */
var kServerSession = Symbol('serverSession');
/** @internal */
var kSnapshotTime = Symbol('snapshotTime');
/** @internal */
var kSnapshotEnabled = Symbol('snapshotEnabled');
/** @internal */
var kPinnedConnection = Symbol('pinnedConnection');
/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */
var kTxnNumberIncrement = Symbol('txnNumberIncrement');
/**
 * A class representing a client session on the server
 *
 * NOTE: not meant to be instantiated directly.
 * @public
 */
var ClientSession = /** @class */ (function (_super) {
    __extends(ClientSession, _super);
    /**
     * Create a client session.
     * @internal
     * @param client - The current client
     * @param sessionPool - The server session pool (Internal Class)
     * @param options - Optional settings
     * @param clientOptions - Optional settings provided when creating a MongoClient
     */
    function ClientSession(client, sessionPool, options, clientOptions) {
        var _b, _c, _d;
        var _this = _super.call(this) || this;
        /** @internal */
        _this[_a] = false;
        if (client == null) {
            // TODO(NODE-3483)
            throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
            // TODO(NODE-3483)
            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');
        }
        options = options !== null && options !== void 0 ? options : {};
        if (options.snapshot === true) {
            _this[kSnapshotEnabled] = true;
            if (options.causalConsistency === true) {
                throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
            }
        }
        _this.client = client;
        _this.sessionPool = sessionPool;
        _this.hasEnded = false;
        _this.clientOptions = clientOptions;
        _this.timeoutMS = (_b = options.defaultTimeoutMS) !== null && _b !== void 0 ? _b : (_c = client.s.options) === null || _c === void 0 ? void 0 : _c.timeoutMS;
        _this.explicit = !!options.explicit;
        _this[kServerSession] = _this.explicit ? _this.sessionPool.acquire() : null;
        _this[kTxnNumberIncrement] = 0;
        var defaultCausalConsistencyValue = _this.explicit && options.snapshot !== true;
        _this.supports = {
            // if we can enable causal consistency, do so by default
            causalConsistency: (_d = options.causalConsistency) !== null && _d !== void 0 ? _d : defaultCausalConsistencyValue
        };
        _this.clusterTime = options.initialClusterTime;
        _this.operationTime = undefined;
        _this.owner = options.owner;
        _this.defaultTransactionOptions = __assign({}, options.defaultTransactionOptions);
        _this.transaction = new transactions_1.Transaction();
        return _this;
    }
    Object.defineProperty(ClientSession.prototype, "id", {
        /** The server id associated with this session */
        get: function () {
            var _b;
            return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientSession.prototype, "serverSession", {
        get: function () {
            var serverSession = this[kServerSession];
            if (serverSession == null) {
                if (this.explicit) {
                    throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');
                }
                if (this.hasEnded) {
                    throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');
                }
                serverSession = this.sessionPool.acquire();
                this[kServerSession] = serverSession;
            }
            return serverSession;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientSession.prototype, "snapshotEnabled", {
        /** Whether or not this session is configured for snapshot reads */
        get: function () {
            return this[kSnapshotEnabled];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientSession.prototype, "loadBalanced", {
        get: function () {
            var _b;
            return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientSession.prototype, "pinnedConnection", {
        /** @internal */
        get: function () {
            return this[kPinnedConnection];
        },
        enumerable: false,
        configurable: true
    });
    /** @internal */
    ClientSession.prototype.pin = function (conn) {
        if (this[kPinnedConnection]) {
            throw TypeError('Cannot pin multiple connections to the same session');
        }
        this[kPinnedConnection] = conn;
        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    };
    /** @internal */
    ClientSession.prototype.unpin = function (options) {
        if (this.loadBalanced) {
            return maybeClearPinnedConnection(this, options);
        }
        this.transaction.unpinServer();
    };
    Object.defineProperty(ClientSession.prototype, "isPinned", {
        get: function () {
            return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Frees any client-side resources held by the current session.  If a session is in a transaction,
     * the transaction is aborted.
     *
     * Does not end the session on the server.
     *
     * @param options - Optional settings. Currently reserved for future use
     */
    ClientSession.prototype.endSession = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            var serverSession, error_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, 4, 5]);
                        if (!this.inTransaction()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.abortTransaction()];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        if (!this.hasEnded) {
                            serverSession = this[kServerSession];
                            if (serverSession != null) {
                                // release the server session back to the pool
                                this.sessionPool.release(serverSession);
                                // Make sure a new serverSession never makes it onto this ClientSession
                                Object.defineProperty(this, kServerSession, {
                                    value: ServerSession.clone(serverSession),
                                    writable: false
                                });
                            }
                            // mark the session as ended, and emit a signal
                            this.hasEnded = true;
                            this.emit('ended', this);
                        }
                        return [3 /*break*/, 5];
                    case 3:
                        error_2 = _b.sent();
                        // spec indicates that we should ignore all errors for `endSessions`
                        utils_1.squashError(error_2);
                        return [3 /*break*/, 5];
                    case 4:
                        maybeClearPinnedConnection(this, __assign({ force: true }, options));
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /** @internal */
    ClientSession.prototype.asyncDispose = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.endSession({ force: true })];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Advances the operationTime for a ClientSession.
     *
     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
     */
    ClientSession.prototype.advanceOperationTime = function (operationTime) {
        if (this.operationTime == null) {
            this.operationTime = operationTime;
            return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
            this.operationTime = operationTime;
        }
    };
    /**
     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
     *
     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
     */
    ClientSession.prototype.advanceClusterTime = function (clusterTime) {
        var _b, _c;
        if (!clusterTime || typeof clusterTime !== 'object') {
            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');
        }
        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {
            throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
        }
        if (!clusterTime.signature ||
            ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' ||
            (typeof clusterTime.signature.keyId !== 'bigint' &&
                typeof clusterTime.signature.keyId !== 'number' &&
                ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long') // apparently we decode the key to number?
        ) {
            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
        }
        common_1._advanceClusterTime(this, clusterTime);
    };
    /**
     * Used to determine if this session equals another
     *
     * @param session - The session to compare to
     */
    ClientSession.prototype.equals = function (session) {
        if (!(session instanceof ClientSession)) {
            return false;
        }
        if (this.id == null || session.id == null) {
            return false;
        }
        return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
    };
    /**
     * Increment the transaction number on the internal ServerSession
     *
     * @privateRemarks
     * This helper increments a value stored on the client session that will be
     * added to the serverSession's txnNumber upon applying it to a command.
     * This is because the serverSession is lazily acquired after a connection is obtained
     */
    ClientSession.prototype.incrementTransactionNumber = function () {
        this[kTxnNumberIncrement] += 1;
    };
    /** @returns whether this session is currently in a transaction or not */
    ClientSession.prototype.inTransaction = function () {
        return this.transaction.isActive;
    };
    /**
     * Starts a new transaction with the given options.
     *
     * @remarks
     * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
     * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
     * undefined behaviour.
     *
     * @param options - Options for the transaction
     */
    ClientSession.prototype.startTransaction = function (options) {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this[kSnapshotEnabled]) {
            throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');
        }
        if (this.inTransaction()) {
            throw new error_1.MongoTransactionError('Transaction already in progress');
        }
        if (this.isPinned && this.transaction.isCommitted) {
            this.unpin();
        }
        var topologyMaxWireVersion = utils_1.maxWireVersion(this.client.topology);
        if (shared_1.isSharded(this.client.topology) &&
            topologyMaxWireVersion != null &&
            topologyMaxWireVersion < minWireVersionForShardedTransactions) {
            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');
        }
        // increment txnNumber
        this.incrementTransactionNumber();
        // create transaction state
        this.transaction = new transactions_1.Transaction({
            readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,
            writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,
            readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,
            maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS
        });
        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    };
    /**
     * Commits the currently active transaction in this session.
     */
    ClientSession.prototype.commitTransaction = function () {
        var _b, _c;
        return __awaiter(this, void 0, Promise, function () {
            var command, wc, operation, firstCommitError_1, retryCommitError_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
                            throw new error_1.MongoTransactionError('No transaction started');
                        }
                        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION ||
                            this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
                            // the transaction was never started, we can safely exit here
                            this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
                            return [2 /*return*/];
                        }
                        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
                            throw new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction');
                        }
                        command = { commitTransaction: 1 };
                        wc = (_b = this.transaction.options.writeConcern) !== null && _b !== void 0 ? _b : (_c = this.clientOptions) === null || _c === void 0 ? void 0 : _c.writeConcern;
                        if (wc != null) {
                            write_concern_1.WriteConcern.apply(command, __assign({ wtimeoutMS: 10000, w: 'majority' }, wc));
                        }
                        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED) {
                            write_concern_1.WriteConcern.apply(command, __assign(__assign({ wtimeoutMS: 10000 }, wc), { w: 'majority' }));
                        }
                        if (typeof this.transaction.options.maxTimeMS === 'number') {
                            command.maxTimeMS = this.transaction.options.maxTimeMS;
                        }
                        if (this.transaction.recoveryToken) {
                            command.recoveryToken = this.transaction.recoveryToken;
                        }
                        operation = new run_command_1.RunAdminCommandOperation(command, {
                            session: this,
                            readPreference: read_preference_1.ReadPreference.primary,
                            bypassPinningCheck: true
                        });
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 8, 9]);
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.client, operation)];
                    case 2:
                        _d.sent();
                        return [2 /*return*/];
                    case 3:
                        firstCommitError_1 = _d.sent();
                        if (!(firstCommitError_1 instanceof error_1.MongoError && error_1.isRetryableWriteError(firstCommitError_1))) return [3 /*break*/, 7];
                        // SPEC-1185: apply majority write concern when retrying commitTransaction
                        write_concern_1.WriteConcern.apply(command, __assign(__assign({ wtimeoutMS: 10000 }, wc), { w: 'majority' }));
                        // per txns spec, must unpin session in this case
                        this.unpin({ force: true });
                        _d.label = 4;
                    case 4:
                        _d.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.client, operation)];
                    case 5:
                        _d.sent();
                        return [2 /*return*/];
                    case 6:
                        retryCommitError_1 = _d.sent();
                        // If the retry failed, we process that error instead of the original
                        if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError_1)) {
                            retryCommitError_1.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
                        }
                        if (shouldUnpinAfterCommitError(retryCommitError_1)) {
                            this.unpin({ error: retryCommitError_1 });
                        }
                        throw retryCommitError_1;
                    case 7:
                        if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError_1)) {
                            firstCommitError_1.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
                        }
                        if (shouldUnpinAfterCommitError(firstCommitError_1)) {
                            this.unpin({ error: firstCommitError_1 });
                        }
                        throw firstCommitError_1;
                    case 8:
                        this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Aborts the currently active transaction in this session.
     */
    ClientSession.prototype.abortTransaction = function () {
        var _b, _c;
        return __awaiter(this, void 0, Promise, function () {
            var command, wc, operation, firstAbortError_1, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
                            throw new error_1.MongoTransactionError('No transaction started');
                        }
                        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
                            // the transaction was never started, we can safely exit here
                            this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
                            return [2 /*return*/];
                        }
                        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
                            throw new error_1.MongoTransactionError('Cannot call abortTransaction twice');
                        }
                        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED ||
                            this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
                            throw new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction');
                        }
                        command = { abortTransaction: 1 };
                        wc = (_b = this.transaction.options.writeConcern) !== null && _b !== void 0 ? _b : (_c = this.clientOptions) === null || _c === void 0 ? void 0 : _c.writeConcern;
                        if (wc != null) {
                            write_concern_1.WriteConcern.apply(command, __assign({ wtimeoutMS: 10000, w: 'majority' }, wc));
                        }
                        if (this.transaction.recoveryToken) {
                            command.recoveryToken = this.transaction.recoveryToken;
                        }
                        operation = new run_command_1.RunAdminCommandOperation(command, {
                            session: this,
                            readPreference: read_preference_1.ReadPreference.primary,
                            bypassPinningCheck: true
                        });
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 3, 8, 9]);
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.client, operation)];
                    case 2:
                        _e.sent();
                        this.unpin();
                        return [2 /*return*/];
                    case 3:
                        firstAbortError_1 = _e.sent();
                        this.unpin();
                        if (!(firstAbortError_1 instanceof error_1.MongoError && error_1.isRetryableWriteError(firstAbortError_1))) return [3 /*break*/, 7];
                        _e.label = 4;
                    case 4:
                        _e.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.client, operation)];
                    case 5:
                        _e.sent();
                        return [2 /*return*/];
                    case 6:
                        _d = _e.sent();
                        return [3 /*break*/, 7];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
                        if (this.loadBalanced) {
                            maybeClearPinnedConnection(this, { force: false });
                        }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This is here to ensure that ClientSession is never serialized to BSON.
     */
    ClientSession.prototype.toBSON = function () {
        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');
    };
    /**
     * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.
     *
     * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.
     *
     * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
     * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
     * undefined behaviour.
     *
     *
     * @remarks
     * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.
     * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.
     *   - If the transaction is manually aborted within the provided function it will not throw.
     * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.
     *
     * Checkout a descriptive example here:
     * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions
     *
     * If a command inside withTransaction fails:
     * - It may cause the transaction on the server to be aborted.
     * - This situation is normally handled transparently by the driver.
     * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.
     * - The driver will then retry the transaction indefinitely.
     *
     * To avoid this situation, the application must not silently handle errors within the provided function.
     * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.
     *
     * @param fn - callback to run within a transaction
     * @param options - optional settings for the transaction
     * @returns A raw command response or undefined
     */
    ClientSession.prototype.withTransaction = function (fn, options) {
        return __awaiter(this, void 0, Promise, function () {
            var MAX_TIMEOUT, startTime, committed, result, promise, fnError_1, commitError_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        MAX_TIMEOUT = 120000;
                        startTime = utils_1.now();
                        committed = false;
                        _b.label = 1;
                    case 1:
                        if (!!committed) return [3 /*break*/, 15];
                        this.startTransaction(options); // may throw on error
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 9]);
                        promise = fn(this);
                        if (!utils_1.isPromiseLike(promise)) {
                            throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');
                        }
                        return [4 /*yield*/, promise];
                    case 3:
                        result = _b.sent();
                        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION ||
                            this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED ||
                            this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
                            // Assume callback intentionally ended the transaction
                            return [2 /*return*/, result];
                        }
                        return [3 /*break*/, 9];
                    case 4:
                        fnError_1 = _b.sent();
                        if (!(!(fnError_1 instanceof error_1.MongoError) || fnError_1 instanceof error_1.MongoInvalidArgumentError)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.abortTransaction()];
                    case 5:
                        _b.sent();
                        throw fnError_1;
                    case 6:
                        if (!(this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION ||
                            this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS)) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.abortTransaction()];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8:
                        if (fnError_1.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&
                            utils_1.now() - startTime < MAX_TIMEOUT) {
                            return [3 /*break*/, 1];
                        }
                        throw fnError_1;
                    case 9:
                        if (!!committed) return [3 /*break*/, 14];
                        _b.label = 10;
                    case 10:
                        _b.trys.push([10, 12, , 13]);
                        /*
                         * We will rely on ClientSession.commitTransaction() to
                         * apply a majority write concern if commitTransaction is
                         * being retried (see: DRIVERS-601)
                         */
                        return [4 /*yield*/, this.commitTransaction()];
                    case 11:
                        /*
                         * We will rely on ClientSession.commitTransaction() to
                         * apply a majority write concern if commitTransaction is
                         * being retried (see: DRIVERS-601)
                         */
                        _b.sent();
                        committed = true;
                        return [3 /*break*/, 13];
                    case 12:
                        commitError_1 = _b.sent();
                        /*
                         * Note: a maxTimeMS error will have the MaxTimeMSExpired
                         * code (50) and can be reported as a top-level error or
                         * inside writeConcernError, ex.
                         * { ok:0, code: 50, codeName: 'MaxTimeMSExpired' }
                         * { ok:1, writeConcernError: { code: 50, codeName: 'MaxTimeMSExpired' } }
                         */
                        if (!isMaxTimeMSExpiredError(commitError_1) &&
                            commitError_1.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) &&
                            utils_1.now() - startTime < MAX_TIMEOUT) {
                            return [3 /*break*/, 9];
                        }
                        if (commitError_1.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&
                            utils_1.now() - startTime < MAX_TIMEOUT) {
                            return [3 /*break*/, 14];
                        }
                        throw commitError_1;
                    case 13: return [3 /*break*/, 9];
                    case 14: return [3 /*break*/, 1];
                    case 15: return [2 /*return*/, result];
                }
            });
        });
    };
    return ClientSession;
}(mongo_types_1.TypedEventEmitter));
exports.ClientSession = ClientSession;
_a = kSnapshotEnabled;
resource_management_1.configureResourceManagement(ClientSession.prototype);
var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    'CannotSatisfyWriteConcern',
    'UnknownReplWriteConcern',
    'UnsatisfiableWriteConcern'
]);
function shouldUnpinAfterCommitError(commitError) {
    if (commitError instanceof error_1.MongoError) {
        if (error_1.isRetryableWriteError(commitError) ||
            commitError instanceof error_1.MongoWriteConcernError ||
            isMaxTimeMSExpiredError(commitError)) {
            if (isUnknownTransactionCommitResult(commitError)) {
                // per txns spec, must unpin session in this case
                return true;
            }
        }
        else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
            return true;
        }
    }
    return false;
}
function shouldAddUnknownTransactionCommitResultLabel(commitError) {
    var ok = error_1.isRetryableWriteError(commitError);
    ok || ;
    commitError instanceof error_1.MongoWriteConcernError;
    ok || ;
    isMaxTimeMSExpiredError(commitError);
    ok && ;
    isUnknownTransactionCommitResult(commitError);
    return ok;
}
function isUnknownTransactionCommitResult(err) {
    var isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&
        err.codeName &&
        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
    return (isMaxTimeMSExpiredError(err) ||
        (!isNonDeterministicWriteConcernError &&
            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&
            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));
}
function maybeClearPinnedConnection(session, options) {
    // unpin a connection if it has been pinned
    var conn = session[kPinnedConnection];
    var error = options === null || options === void 0 ? void 0 : options.error;
    if (session.inTransaction() &&
        error &&
        error instanceof error_1.MongoError &&
        error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return;
    }
    var topology = session.client.topology;
    // NOTE: the spec talks about what to do on a network error only, but the tests seem to
    //       to validate that we don't unpin on _all_ errors?
    if (conn && topology != null) {
        var servers = Array.from(topology.s.servers.values());
        var loadBalancer = servers[0];
        if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {
            loadBalancer.pool.checkIn(conn);
            session[kPinnedConnection] = undefined;
            conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION
                ? metrics_1.ConnectionPoolMetrics.TXN
                : metrics_1.ConnectionPoolMetrics.CURSOR);
            if (options === null || options === void 0 ? void 0 : options.forceClear) {
                loadBalancer.pool.clear({ serviceId: conn.serviceId });
            }
        }
    }
}
exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
function isMaxTimeMSExpiredError(err) {
    var _b;
    if (err == null || !(err instanceof error_1.MongoServerError)) {
        return false;
    }
    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||
        ((_b = err.writeConcernError) === null || _b === void 0 ? void 0 : _b.code) === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired);
}
/**
 * Reflects the existence of a session on the server. Can be reused by the session pool.
 * WARNING: not meant to be instantiated directly. For internal use only.
 * @public
 */
var ServerSession = /** @class */ (function () {
    /** @internal */
    function ServerSession() {
        this.id = { id: new bson_1.Binary(utils_1.uuidV4(), bson_1.Binary.SUBTYPE_UUID) };
        this.lastUse = utils_1.now();
        this.txnNumber = 0;
        this.isDirty = false;
    }
    /**
     * Determines if the server session has timed out.
     *
     * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
     */
    ServerSession.prototype.hasTimedOut = function (sessionTimeoutMinutes) {
        // Take the difference of the lastUse timestamp and now, which will result in a value in
        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
        var idleTimeMinutes = Math.round(((utils_1.calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
    };
    /**
     * @internal
     * Cloning meant to keep a readable reference to the server session data
     * after ClientSession has ended
     */
    ServerSession.clone = function (serverSession) {
        var arrayBuffer = new ArrayBuffer(16);
        var idBytes = Buffer.from(arrayBuffer);
        idBytes.set(serverSession.id.id.buffer);
        var id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);
        // Manual prototype construction to avoid modifying the constructor of this class
        return Object.setPrototypeOf({
            id: { id: id },
            lastUse: serverSession.lastUse,
            txnNumber: serverSession.txnNumber,
            isDirty: serverSession.isDirty
        }, ServerSession.prototype);
    };
    return ServerSession;
}());
exports.ServerSession = ServerSession;
/**
 * Maintains a pool of Server Sessions.
 * For internal use only
 * @internal
 */
var ServerSessionPool = /** @class */ (function () {
    function ServerSessionPool(client) {
        if (client == null) {
            throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');
        }
        this.client = client;
        this.sessions = new utils_1.List();
    }
    /**
     * Acquire a Server Session from the pool.
     * Iterates through each session in the pool, removing any stale sessions
     * along the way. The first non-stale session found is removed from the
     * pool and returned. If no non-stale session is found, a new ServerSession is created.
     */
    ServerSessionPool.prototype.acquire = function () {
        var _b, _c, _d;
        var sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;
        var session = null;
        // Try to obtain from session pool
        while (this.sessions.length > 0) {
            var potentialSession = this.sessions.shift();
            if (potentialSession != null &&
                (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) ||
                    !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
                session = potentialSession;
                break;
            }
        }
        // If nothing valid came from the pool make a new one
        if (session == null) {
            session = new ServerSession();
        }
        return session;
    };
    /**
     * Release a session to the session pool
     * Adds the session back to the session pool if the session has not timed out yet.
     * This method also removes any stale sessions from the pool.
     *
     * @param session - The session to release to the pool
     */
    ServerSessionPool.prototype.release = function (session) {
        var _b, _c, _d;
        var sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;
        if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {
            this.sessions.unshift(session);
        }
        if (!sessionTimeoutMinutes) {
            return;
        }
        this.sessions.prune(function (session) { return session.hasTimedOut(sessionTimeoutMinutes); });
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            if (session.isDirty) {
                return;
            }
            // otherwise, readd this session to the session pool
            this.sessions.unshift(session);
        }
    };
    return ServerSessionPool;
}());
exports.ServerSessionPool = ServerSessionPool;
/**
 * Optionally decorate a command with sessions specific keys
 *
 * @param session - the session tracking transaction state
 * @param command - the command to decorate
 * @param options - Optional settings passed to calling operation
 *
 * @internal
 */
function applySession(session, command, options) {
    var _b, _c;
    if (session.hasEnded) {
        return new error_1.MongoExpiredSessionError();
    }
    // May acquire serverSession here
    var serverSession = session.serverSession;
    if (serverSession == null) {
        return new error_1.MongoRuntimeError('Unable to acquire server session');
    }
    if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {
        if (session && session.explicit) {
            // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)
            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');
        }
        return;
    }
    // mark the last use of this session, and apply the `lsid`
    serverSession.lastUse = utils_1.now();
    command.lsid = serverSession.id;
    var inTxnOrTxnCommand = session.inTransaction() || transactions_1.isTransactionCommand(command);
    var isRetryableWrite = !!options.willRetryWrite;
    if (isRetryableWrite || inTxnOrTxnCommand) {
        serverSession.txnNumber += session[kTxnNumberIncrement];
        session[kTxnNumberIncrement] = 0;
        // TODO(NODE-2674): Preserve int64 sent from MongoDB
        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTxnOrTxnCommand) {
        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency &&
            session.operationTime &&
            utils_1.commandSupportsReadConcern(command)) {
            command.readConcern = command.readConcern || {};
            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
        else if (session[kSnapshotEnabled]) {
            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
            if (session[kSnapshotTime] != null) {
                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });
            }
        }
        return;
    }
    // now attempt to apply transaction-specific sessions data
    // `autocommit` must always be false to differentiate from retryable writes
    command.autocommit = false;
    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        var readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);
        if (readConcern) {
            command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
            command.readConcern = command.readConcern || {};
            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
    }
    return;
}
exports.applySession = applySession;
function updateSessionFromResponse(session, document) {
    if (document.$clusterTime) {
        common_1._advanceClusterTime(session, document.$clusterTime);
    }
    if (document.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document.operationTime);
    }
    if (document.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document.recoveryToken;
    }
    if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {
        // find and aggregate commands return atClusterTime on the cursor
        // distinct includes it in the response body
        var atClusterTime = document.atClusterTime;
        if (atClusterTime) {
            session[kSnapshotTime] = atClusterTime;
        }
    }
}
exports.updateSessionFromResponse = updateSessionFromResponse;
