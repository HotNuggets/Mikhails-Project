"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.Timestamp = exports.LongWithoutOverridesClass = void 0;
var error_1 = require("./error");
var long_1 = require("./long");
var utils_1 = require("./parser/utils");
/** @public */
exports.LongWithoutOverridesClass = long_1.Long;
/**
 * @public
 * @category BSONType
 *
 * A special type for _internal_ MongoDB use and is **not** associated with the regular Date type.
 */
var Timestamp = /** @class */ (function (_super) {
    __extends(Timestamp, _super);
    function Timestamp(low) {
        var _this = this;
        if (low == null) {
            _this = _super.call(this, 0, 0, true) || this;
        }
        else if (typeof low === 'bigint') {
            _this = _super.call(this, low, true) || this;
        }
        else if (long_1.Long.isLong(low)) {
            _this = _super.call(this, low.low, low.high, true) || this;
        }
        else if (typeof low === 'object' && 't' in low && 'i' in low) {
            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide t as a number');
            }
            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide i as a number');
            }
            var t = Number(low.t);
            var i = Number(low.i);
            if (t < 0 || Number.isNaN(t)) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide a positive t');
            }
            if (i < 0 || Number.isNaN(i)) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide a positive i');
            }
            if (t > 4294967295) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');
            }
            if (i > 4294967295) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');
            }
            _this = _super.call(this, i, t, true) || this;
        }
        else {
            throw new error_1.BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');
        }
        return _this;
    }
    Object.defineProperty(Timestamp.prototype, "_bsontype", {
        get: function () {
            return 'Timestamp';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timestamp.prototype, "i", {
        /**
         * An incrementing ordinal for operations within a given second.
         */
        get: function () {
            return this.low >>> 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timestamp.prototype, "t", {
        /**
         * A `time_t` value measuring seconds since the Unix epoch
         */
        get: function () {
            return this.high >>> 0;
        },
        enumerable: false,
        configurable: true
    });
    Timestamp.prototype.toJSON = function () {
        return {
            $timestamp: this.toString()
        };
    };
    /** Returns a Timestamp represented by the given (32-bit) integer value. */
    Timestamp.fromInt = function (value) {
        return new Timestamp(long_1.Long.fromInt(value, true));
    };
    /** Returns a Timestamp representing the given number value, provided that it is a finite number. Otherwise, zero is returned. */
    Timestamp.fromNumber = function (value) {
        return new Timestamp(long_1.Long.fromNumber(value, true));
    };
    /**
     * Returns a Timestamp for the given high and low bits. Each is assumed to use 32 bits.
     *
     * @param lowBits - the low 32-bits.
     * @param highBits - the high 32-bits.
     */
    Timestamp.fromBits = function (lowBits, highBits) {
        return new Timestamp({ i: lowBits, t: highBits });
    };
    /**
     * Returns a Timestamp from the given string, optionally using the given radix.
     *
     * @param str - the textual representation of the Timestamp.
     * @param optRadix - the radix in which the text is written.
     */
    Timestamp.fromString = function (str, optRadix) {
        return new Timestamp(long_1.Long.fromString(str, true, optRadix));
    };
    /** @internal */
    Timestamp.prototype.toExtendedJSON = function () {
        return { $timestamp: { t: this.t, i: this.i } };
    };
    /** @internal */
    Timestamp.fromExtendedJSON = function (doc) {
        // The Long check is necessary because extended JSON has different behavior given the size of the input number
        var i = long_1.Long.isLong(doc.$timestamp.i)
            ? doc.$timestamp.i.getLowBitsUnsigned() // Need to fetch the least significant 32 bits
            : doc.$timestamp.i;
        var t = long_1.Long.isLong(doc.$timestamp.t)
            ? doc.$timestamp.t.getLowBitsUnsigned() // Need to fetch the least significant 32 bits
            : doc.$timestamp.t;
        return new Timestamp({ t: t, i: i });
    };
    Timestamp.prototype.inspect = function (depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : ;
        utils_1.defaultInspect;
        var t = inspect(this.t, options);
        var i = inspect(this.i, options);
        return "new Timestamp({ t: " + t + ", i: " + i + " })";
    };
    Timestamp.MAX_VALUE = long_1.Long.MAX_UNSIGNED_VALUE;
    return Timestamp;
}(exports.LongWithoutOverridesClass));
exports.Timestamp = Timestamp;
