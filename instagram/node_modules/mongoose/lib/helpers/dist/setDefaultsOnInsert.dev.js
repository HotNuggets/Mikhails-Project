'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var modifiedPaths = require('./common').modifiedPaths;

var get = require('./get');
/**
 * Applies defaults to update and findOneAndUpdate operations.
 *
 * @param {Object} filter
 * @param {Schema} schema
 * @param {Object} castedDoc
 * @param {Object} options
 * @method setDefaultsOnInsert
 * @api private
 */


module.exports = function (filter, schema, castedDoc, options) {
  options = options || {};
  var shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;

  if (!options.upsert || shouldSetDefaultsOnInsert === false) {
    return castedDoc;
  }

  var keys = Object.keys(castedDoc || {});
  var updatedKeys = {};
  var updatedValues = {};
  var numKeys = keys.length;
  var modified = {};
  var hasDollarUpdate = false;

  for (var i = 0; i < numKeys; ++i) {
    if (keys[i].startsWith('$')) {
      modifiedPaths(castedDoc[keys[i]], '', modified);
      hasDollarUpdate = true;
    }
  }

  if (!hasDollarUpdate) {
    modifiedPaths(castedDoc, '', modified);
  }

  var paths = Object.keys(filter);
  var numPaths = paths.length;

  for (var _i = 0; _i < numPaths; ++_i) {
    var path = paths[_i];
    var condition = filter[path];

    if (condition && _typeof(condition) === 'object') {
      var conditionKeys = Object.keys(condition);
      var numConditionKeys = conditionKeys.length;
      var hasDollarKey = false;

      for (var j = 0; j < numConditionKeys; ++j) {
        if (conditionKeys[j].startsWith('$')) {
          hasDollarKey = true;
          break;
        }
      }

      if (hasDollarKey) {
        continue;
      }
    }

    updatedKeys[path] = true;
    modified[path] = true;
  }

  if (options && options.overwrite && !hasDollarUpdate) {
    // Defaults will be set later, since we're overwriting we'll cast
    // the whole update to a document
    return castedDoc;
  }

  schema.eachPath(function (path, schemaType) {
    // Skip single nested paths if underneath a map
    if (schemaType.path === '_id' && schemaType.options.auto) {
      return;
    }

    var def = schemaType.getDefault(null, true);

    if (isModified(modified, path)) {
      return;
    }

    if (typeof def === 'undefined') {
      return;
    }

    if (schemaType.splitPath().includes('$*')) {
      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`
      return;
    }

    castedDoc = castedDoc || {};
    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};

    if (get(castedDoc, path) == null) {
      castedDoc.$setOnInsert[path] = def;
    }

    updatedValues[path] = def;
  });
  return castedDoc;
};

function isModified(modified, path) {
  if (modified[path]) {
    return true;
  } // Is any parent path of `path` modified?


  var sp = path.split('.');
  var cur = sp[0];

  for (var i = 1; i < sp.length; ++i) {
    if (modified[cur]) {
      return true;
    }

    cur += '.' + sp[i];
  } // Is any child of `path` modified?


  var modifiedKeys = Object.keys(modified);

  if (modifiedKeys.length) {
    var parentPath = path + '.';
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = modifiedKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var modifiedPath = _step.value;

        if (modifiedPath.slice(0, path.length + 1) === parentPath) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return false;
}