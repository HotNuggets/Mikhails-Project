'use strict';
/*!
 * Module dependencies.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var MongooseCollection = require('../../collection');

var MongooseError = require('../../error/mongooseError');

var Collection = require('mongodb').Collection;

var ObjectId = require('../../types/objectid');

var getConstructorName = require('../../helpers/getConstructorName');

var internalToObjectOptions = require('../../options').internalToObjectOptions;

var stream = require('stream');

var util = require('util');
/**
 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
 *
 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
 *
 * @inherits Collection https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html
 * @api private
 */


function NativeCollection(name, conn, options) {
  this.collection = null;
  this.Promise = options.Promise || Promise;
  this.modelName = options.modelName;
  delete options.modelName;
  this._closed = false;
  MongooseCollection.apply(this, arguments);
}
/*!
 * Inherit from abstract Collection.
 */


Object.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);
/**
 * Called when the connection opens.
 *
 * @api private
 */

NativeCollection.prototype.onOpen = function () {
  this.collection = this.conn.db.collection(this.name);
  MongooseCollection.prototype.onOpen.call(this);
  return this.collection;
};
/**
 * Called when the connection closes
 *
 * @api private
 */


NativeCollection.prototype.onClose = function (force) {
  MongooseCollection.prototype.onClose.call(this, force);
};
/**
 * Helper to get the collection, in case `this.collection` isn't set yet.
 * May happen if `bufferCommands` is false and created the model when
 * Mongoose was disconnected.
 *
 * @api private
 */


NativeCollection.prototype._getCollection = function _getCollection() {
  if (this.collection) {
    return this.collection;
  }

  if (this.conn.db != null) {
    this.collection = this.conn.db.collection(this.name);
    return this.collection;
  }

  return null;
};
/*!
 * ignore
 */


var syncCollectionMethods = {
  watch: true,
  find: true,
  aggregate: true
};
/**
 * Copy the collection methods and make them subject to queues
 * @param {Number|String} I
 * @api private
 */

function iter(i) {
  NativeCollection.prototype[i] = function () {
    var _this2 = this;

    var collection = this._getCollection();

    var args = Array.from(arguments);

    var _this = this;

    var globalDebug = _this && _this.conn && _this.conn.base && _this.conn.base.options && _this.conn.base.options.debug;
    var connectionDebug = _this && _this.conn && _this.conn.options && _this.conn.options.debug;
    var debug = connectionDebug == null ? globalDebug : connectionDebug;
    var lastArg = arguments[arguments.length - 1];
    var opId = new ObjectId(); // If user force closed, queueing will hang forever. See #5664

    if (this.conn.$wasForceClosed) {
      var error = new MongooseError('Connection was force closed');

      if (args.length > 0 && typeof args[args.length - 1] === 'function') {
        args[args.length - 1](error);
        return;
      } else {
        throw error;
      }
    }

    var _args = args;
    var callback = null;

    if (this._shouldBufferCommands() && this.buffer) {
      this.conn.emit('buffer', {
        _id: opId,
        modelName: _this.modelName,
        collectionName: _this.name,
        method: i,
        args: args
      });

      var _callback;

      var _args2 = args;
      var promise = null;
      var timeout = null;

      if (syncCollectionMethods[i] && typeof lastArg === 'function') {
        this.addQueue(i, _args2);
        _callback = lastArg;
      } else if (syncCollectionMethods[i]) {
        promise = new this.Promise(function (resolve, reject) {
          _callback = function collectionOperationCallback(err, res) {
            if (timeout != null) {
              clearTimeout(timeout);
            }

            if (err != null) {
              return reject(err);
            }

            resolve(res);
          };

          _args2 = args.concat([_callback]);

          _this2.addQueue(i, _args2);
        });
      } else if (typeof lastArg === 'function') {
        _callback = function collectionOperationCallback() {
          if (timeout != null) {
            clearTimeout(timeout);
          }

          return lastArg.apply(this, arguments);
        };

        _args2 = args.slice(0, args.length - 1).concat([_callback]);
      } else {
        promise = new Promise(function (resolve, reject) {
          _callback = function collectionOperationCallback(err, res) {
            if (timeout != null) {
              clearTimeout(timeout);
            }

            if (err != null) {
              return reject(err);
            }

            resolve(res);
          };

          _args2 = args.concat([_callback]);

          _this2.addQueue(i, _args2);
        });
      }

      var bufferTimeoutMS = this._getBufferTimeoutMS();

      timeout = setTimeout(function () {
        var removed = _this2.removeQueue(i, _args2);

        if (removed) {
          var message = 'Operation `' + _this2.name + '.' + i + '()` buffering timed out after ' + bufferTimeoutMS + 'ms';
          var err = new MongooseError(message);

          _this2.conn.emit('buffer-end', {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            error: err
          });

          _callback(err);
        }
      }, bufferTimeoutMS);

      if (!syncCollectionMethods[i] && typeof lastArg === 'function') {
        this.addQueue(i, _args2);
        return;
      }

      return promise;
    } else if (!syncCollectionMethods[i] && typeof lastArg === 'function') {
      callback = function collectionOperationCallback(err, res) {
        if (err != null) {
          _this.conn.emit('operation-end', {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            error: err
          });
        } else {
          _this.conn.emit('operation-end', {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            result: res
          });
        }

        return lastArg.apply(this, arguments);
      };

      _args = args.slice(0, args.length - 1).concat([callback]);
    }

    if (debug) {
      if (typeof debug === 'function') {
        var argsToAdd = null;

        if (typeof args[args.length - 1] == 'function') {
          argsToAdd = args.slice(0, args.length - 1);
        } else {
          argsToAdd = args;
        }

        debug.apply(_this, [_this.name, i].concat(argsToAdd));
      } else if (debug instanceof stream.Writable) {
        this.$printToStream(_this.name, i, args, debug);
      } else {
        var color = debug.color == null ? true : debug.color;
        var shell = debug.shell == null ? false : debug.shell;
        this.$print(_this.name, i, args, color, shell);
      }
    }

    this.conn.emit('operation-start', {
      _id: opId,
      modelName: _this.modelName,
      collectionName: this.name,
      method: i,
      params: _args
    });

    try {
      if (collection == null) {
        var message = 'Cannot call `' + this.name + '.' + i + '()` before initial connection ' + 'is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if ' + 'you have `bufferCommands = false`.';
        throw new MongooseError(message);
      }

      if (syncCollectionMethods[i] && typeof lastArg === 'function') {
        var result = collection[i].apply(collection, _args.slice(0, _args.length - 1));
        this.conn.emit('operation-end', {
          _id: opId,
          modelName: _this.modelName,
          collectionName: this.name,
          method: i,
          result: result
        });
        return lastArg.call(this, null, result);
      }

      var ret = collection[i].apply(collection, _args);

      if (ret != null && typeof ret.then === 'function') {
        return ret.then(function (result) {
          if (typeof lastArg === 'function') {
            lastArg(null, result);
          } else {
            _this2.conn.emit('operation-end', {
              _id: opId,
              modelName: _this.modelName,
              collectionName: _this2.name,
              method: i,
              result: result
            });
          }

          return result;
        }, function (error) {
          if (typeof lastArg === 'function') {
            lastArg(error);
            return;
          } else {
            _this2.conn.emit('operation-end', {
              _id: opId,
              modelName: _this.modelName,
              collectionName: _this2.name,
              method: i,
              error: error
            });
          }

          throw error;
        });
      }

      return ret;
    } catch (error) {
      // Collection operation may throw because of max bson size, catch it here
      // See gh-3906
      if (typeof lastArg === 'function') {
        return lastArg(error);
      } else {
        this.conn.emit('operation-end', {
          _id: opId,
          modelName: _this.modelName,
          collectionName: this.name,
          method: i,
          error: error
        });
        throw error;
      }
    }
  };
}

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = Object.getOwnPropertyNames(Collection.prototype)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var key = _step.value;
    // Janky hack to work around gh-3005 until we can get rid of the mongoose
    // collection abstraction
    var descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key); // Skip properties with getters because they may throw errors (gh-8528)

    if (descriptor.get !== undefined) {
      continue;
    }

    if (typeof Collection.prototype[key] !== 'function') {
      continue;
    }

    iter(key);
  }
  /**
   * Debug print helper
   *
   * @api public
   * @method $print
   */

} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
      _iterator["return"]();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

NativeCollection.prototype.$print = function (name, i, args, color, shell) {
  var moduleName = color ? '\x1B[0;36mMongoose:\x1B[0m ' : 'Mongoose: ';
  var functionCall = [name, i].join('.');
  var _args = [];

  for (var j = args.length - 1; j >= 0; --j) {
    if (this.$format(args[j]) || _args.length) {
      _args.unshift(this.$format(args[j], color, shell));
    }
  }

  var params = '(' + _args.join(', ') + ')';
  console.info(moduleName + functionCall + params);
};
/**
 * Debug print helper
 *
 * @api public
 * @method $print
 */


NativeCollection.prototype.$printToStream = function (name, i, args, stream) {
  var functionCall = [name, i].join('.');
  var _args = [];

  for (var j = args.length - 1; j >= 0; --j) {
    if (this.$format(args[j]) || _args.length) {
      _args.unshift(this.$format(args[j]));
    }
  }

  var params = '(' + _args.join(', ') + ')';
  stream.write(functionCall + params, 'utf8');
};
/**
 * Formatter for debug print args
 *
 * @api public
 * @method $format
 */


NativeCollection.prototype.$format = function (arg, color, shell) {
  var type = _typeof(arg);

  if (type === 'function' || type === 'undefined') return '';
  return format(arg, false, color, shell);
};
/**
 * Debug print helper
 * @param {Any} representation
 * @api private
 */


function inspectable(representation) {
  var ret = {
    inspect: function inspect() {
      return representation;
    }
  };

  if (util.inspect.custom) {
    ret[util.inspect.custom] = ret.inspect;
  }

  return ret;
}

function map(o) {
  return format(o, true);
}

function formatObjectId(x, key) {
  x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
}

function formatDate(x, key, shell) {
  if (shell) {
    x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
  } else {
    x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
  }
}

function format(obj, sub, color, shell) {
  if (obj && typeof obj.toBSON === 'function') {
    obj = obj.toBSON();
  }

  if (obj == null) {
    return obj;
  }

  var clone = require('../../helpers/clone');

  var x = clone(obj, internalToObjectOptions);
  var constructorName = getConstructorName(x);

  if (constructorName === 'Binary') {
    x = 'BinData(' + x.sub_type + ', "' + x.toString('base64') + '")';
  } else if (constructorName === 'ObjectId') {
    x = inspectable('ObjectId("' + x.toHexString() + '")');
  } else if (constructorName === 'Date') {
    x = inspectable('new Date("' + x.toUTCString() + '")');
  } else if (constructorName === 'Object') {
    var keys = Object.keys(x);
    var numKeys = keys.length;
    var key;

    for (var i = 0; i < numKeys; ++i) {
      key = keys[i];

      if (x[key]) {
        var error = void 0;

        if (typeof x[key].toBSON === 'function') {
          try {
            // `session.toBSON()` throws an error. This means we throw errors
            // in debug mode when using transactions, see gh-6712. As a
            // workaround, catch `toBSON()` errors, try to serialize without
            // `toBSON()`, and rethrow if serialization still fails.
            x[key] = x[key].toBSON();
          } catch (_error) {
            error = _error;
          }
        }

        var _constructorName = getConstructorName(x[key]);

        if (_constructorName === 'Binary') {
          x[key] = 'BinData(' + x[key].sub_type + ', "' + x[key].buffer.toString('base64') + '")';
        } else if (_constructorName === 'Object') {
          x[key] = format(x[key], true);
        } else if (_constructorName === 'ObjectId') {
          formatObjectId(x, key);
        } else if (_constructorName === 'Date') {
          formatDate(x, key, shell);
        } else if (_constructorName === 'ClientSession') {
          x[key] = inspectable('ClientSession("' + (x[key] && x[key].id && x[key].id.id && x[key].id.id.buffer || '').toString('hex') + '")');
        } else if (Array.isArray(x[key])) {
          x[key] = x[key].map(map);
        } else if (error != null) {
          // If there was an error with `toBSON()` and the object wasn't
          // already converted to a string representation, rethrow it.
          // Open to better ideas on how to handle this.
          throw error;
        }
      }
    }
  }

  if (sub) {
    return x;
  }

  return util.inspect(x, false, 10, color).replace(/\n/g, '').replace(/\s{2,}/g, ' ');
}
/**
 * Retrieves information about this collections indexes.
 *
 * @param {Function} callback
 * @method getIndexes
 * @api public
 */


NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
/*!
 * Module exports.
 */

module.exports = NativeCollection;