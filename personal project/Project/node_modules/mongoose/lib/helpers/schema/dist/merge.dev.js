'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function merge(s1, s2, skipConflictingPaths) {
  var paths = Object.keys(s2.tree);
  var pathsToAdd = {};

  for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
    var key = _paths[_i];

    if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
      continue;
    }

    pathsToAdd[key] = s2.tree[key];
  }

  s1.options._isMerging = true;
  s1.add(pathsToAdd, null);
  delete s1.options._isMerging;
  s1.callQueue = s1.callQueue.concat(s2.callQueue);
  s1.method(s2.methods);
  s1["static"](s2.statics);

  for (var _i2 = 0, _Object$entries = Object.entries(s2._userProvidedOptions); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        option = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    if (!(option in s1._userProvidedOptions)) {
      s1.set(option, value);
    }
  }

  for (var query in s2.query) {
    s1.query[query] = s2.query[query];
  }

  for (var virtual in s2.virtuals) {
    s1.virtuals[virtual] = s2.virtuals[virtual].clone();
  }

  s1._indexes = s1._indexes.concat(s2._indexes || []);
  s1.s.hooks.merge(s2.s.hooks, false);
};