"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.ObjectId = void 0;
var bson_value_1 = require("./bson_value");
var error_1 = require("./error");
var utils_1 = require("./parser/utils");
var byte_utils_1 = require("./utils/byte_utils");
var number_utils_1 = require("./utils/number_utils");
// Unique sequence for the current process (initialized on first use)
var PROCESS_UNIQUE = null;
/**
 * A class representation of the BSON ObjectId type.
 * @public
 * @category BSONType
 */
var ObjectId = /** @class */ (function (_super) {
    __extends(ObjectId, _super);
    /**
     * Create a new ObjectId.
     *
     * @param inputId - An input value to create a new ObjectId from.
     */
    function ObjectId(inputId) {
        var _this = _super.call(this) || this;
        // workingId is set based on type of input and whether valid id exists for the input
        var workingId;
        if (typeof inputId === 'object' && inputId && 'id' in inputId) {
            if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {
                throw new error_1.BSONError('Argument passed in must have an id that is of type string or Buffer');
            }
            if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {
                workingId = byte_utils_1.ByteUtils.fromHex(inputId.toHexString());
            }
            else {
                workingId = inputId.id;
            }
        }
        else {
            workingId = inputId;
        }
        // The following cases use workingId to construct an ObjectId
        if (workingId == null || typeof workingId === 'number') {
            // The most common use case (blank id, new objectId instance)
            // Generate a new id
            _this.buffer = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);
        }
        else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
            // If intstanceof matches we can escape calling ensure buffer in Node.js environments
            _this.buffer = byte_utils_1.ByteUtils.toLocalBufferType(workingId);
        }
        else if (typeof workingId === 'string') {
            if (ObjectId.validateHexString(workingId)) {
                _this.buffer = byte_utils_1.ByteUtils.fromHex(workingId);
            }
            else {
                throw new error_1.BSONError('input must be a 24 character hex string, 12 byte Uint8Array, or an integer');
            }
        }
        else {
            throw new error_1.BSONError('Argument passed in does not match the accepted types');
        }
        // If we are caching the hex string
        if (ObjectId.cacheHexString) {
            _this.__id = byte_utils_1.ByteUtils.toHex(_this.id);
        }
        return _this;
    }
    Object.defineProperty(ObjectId.prototype, "_bsontype", {
        get: function () {
            return 'ObjectId';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObjectId.prototype, "id", {
        /**
         * The ObjectId bytes
         * @readonly
         */
        get: function () {
            return this.buffer;
        },
        set: function (value) {
            this.buffer = value;
            if (ObjectId.cacheHexString) {
                this.__id = byte_utils_1.ByteUtils.toHex(value);
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @internal
     * Validates the input string is a valid hex representation of an ObjectId.
     */
    ObjectId.validateHexString = function (string) {
        if ((string === null || string === void 0 ? void 0 : string.length) !== 24)
            return false;
        for (var i = 0; i < 24; i++) {
            var char = string.charCodeAt(i);
            if (
            // Check for ASCII 0-9
            (char >= 48 && char <= 57) ||
                // Check for ASCII a-f
                (char >= 97 && char <= 102) ||
                // Check for ASCII A-F
                (char >= 65 && char <= 70)) {
                continue;
            }
            return false;
        }
        return true;
    };
    /** Returns the ObjectId id as a 24 lowercase character hex string representation */
    ObjectId.prototype.toHexString = function () {
        if (ObjectId.cacheHexString && this.__id) {
            return this.__id;
        }
        var hexString = byte_utils_1.ByteUtils.toHex(this.id);
        if (ObjectId.cacheHexString && !this.__id) {
            this.__id = hexString;
        }
        return hexString;
    };
    /**
     * Update the ObjectId index
     * @internal
     */
    ObjectId.getInc = function () {
        return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);
    };
    /**
     * Generate a 12 byte id buffer used in ObjectId's
     *
     * @param time - pass in a second based timestamp.
     */
    ObjectId.generate = function (time) {
        if ('number' !== typeof time) {
            time = Math.floor(Date.now() / 1000);
        }
        var inc = ObjectId.getInc();
        var buffer = byte_utils_1.ByteUtils.allocateUnsafe(12);
        // 4-byte timestamp
        number_utils_1.NumberUtils.setInt32BE(buffer, 0, time);
        // set PROCESS_UNIQUE if yet not initialized
        if (PROCESS_UNIQUE === null) {
            PROCESS_UNIQUE = byte_utils_1.ByteUtils.randomBytes(5);
        }
        // 5-byte process unique
        buffer[4] = PROCESS_UNIQUE[0];
        buffer[5] = PROCESS_UNIQUE[1];
        buffer[6] = PROCESS_UNIQUE[2];
        buffer[7] = PROCESS_UNIQUE[3];
        buffer[8] = PROCESS_UNIQUE[4];
        // 3-byte counter
        buffer[11] = inc & 0xff;
        buffer[10] = (inc >> 8) & 0xff;
        buffer[9] = (inc >> 16) & 0xff;
        return buffer;
    };
    /**
     * Converts the id into a 24 character hex string for printing, unless encoding is provided.
     * @param encoding - hex or base64
     */
    ObjectId.prototype.toString = function (encoding) {
        // Is the id a buffer then use the buffer toString method to return the format
        if (encoding === 'base64')
            return byte_utils_1.ByteUtils.toBase64(this.id);
        if (encoding === 'hex')
            return this.toHexString();
        return this.toHexString();
    };
    /** Converts to its JSON the 24 character hex string representation. */
    ObjectId.prototype.toJSON = function () {
        return this.toHexString();
    };
    /** @internal */
    ObjectId.is = function (variable) {
        return (variable != null &&
            typeof variable === 'object' &&
            '_bsontype' in variable &&
            variable._bsontype === 'ObjectId');
    };
    /**
     * Compares the equality of this ObjectId with `otherID`.
     *
     * @param otherId - ObjectId instance to compare against.
     */
    ObjectId.prototype.equals = function (otherId) {
        if (otherId === undefined || otherId === null) {
            return false;
        }
        if (ObjectId.is(otherId)) {
            return (this.buffer[11] === otherId.buffer[11] && byte_utils_1.ByteUtils.equals(this.buffer, otherId.buffer));
        }
        if (typeof otherId === 'string') {
            return otherId.toLowerCase() === this.toHexString();
        }
        if (typeof otherId === 'object' && typeof otherId.toHexString === 'function') {
            var otherIdString = otherId.toHexString();
            var thisIdString = this.toHexString();
            return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;
        }
        return false;
    };
    /** Returns the generation date (accurate up to the second) that this ID was generated. */
    ObjectId.prototype.getTimestamp = function () {
        var timestamp = new Date();
        var time = number_utils_1.NumberUtils.getUint32BE(this.buffer, 0);
        timestamp.setTime(Math.floor(time) * 1000);
        return timestamp;
    };
    /** @internal */
    ObjectId.createPk = function () {
        return new ObjectId();
    };
    /** @internal */
    ObjectId.prototype.serializeInto = function (uint8array, index) {
        uint8array[index] = this.buffer[0];
        uint8array[index + 1] = this.buffer[1];
        uint8array[index + 2] = this.buffer[2];
        uint8array[index + 3] = this.buffer[3];
        uint8array[index + 4] = this.buffer[4];
        uint8array[index + 5] = this.buffer[5];
        uint8array[index + 6] = this.buffer[6];
        uint8array[index + 7] = this.buffer[7];
        uint8array[index + 8] = this.buffer[8];
        uint8array[index + 9] = this.buffer[9];
        uint8array[index + 10] = this.buffer[10];
        uint8array[index + 11] = this.buffer[11];
        return 12;
    };
    /**
     * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.
     *
     * @param time - an integer number representing a number of seconds.
     */
    ObjectId.createFromTime = function (time) {
        var buffer = byte_utils_1.ByteUtils.allocate(12);
        for (var i = 11; i >= 4; i--)
            buffer[i] = 0;
        // Encode time into first 4 bytes
        number_utils_1.NumberUtils.setInt32BE(buffer, 0, time);
        // Return the new objectId
        return new ObjectId(buffer);
    };
    /**
     * Creates an ObjectId from a hex string representation of an ObjectId.
     *
     * @param hexString - create a ObjectId from a passed in 24 character hexstring.
     */
    ObjectId.createFromHexString = function (hexString) {
        if ((hexString === null || hexString === void 0 ? void 0 : hexString.length) !== 24) {
            throw new error_1.BSONError('hex string must be 24 characters');
        }
        return new ObjectId(byte_utils_1.ByteUtils.fromHex(hexString));
    };
    /** Creates an ObjectId instance from a base64 string */
    ObjectId.createFromBase64 = function (base64) {
        if ((base64 === null || base64 === void 0 ? void 0 : base64.length) !== 16) {
            throw new error_1.BSONError('base64 string must be 16 characters');
        }
        return new ObjectId(byte_utils_1.ByteUtils.fromBase64(base64));
    };
    /**
     * Checks if a value can be used to create a valid bson ObjectId
     * @param id - any JS value
     */
    ObjectId.isValid = function (id) {
        if (id == null)
            return false;
        if (typeof id === 'string')
            return ObjectId.validateHexString(id);
        try {
            new ObjectId(id);
            return true;
        }
        catch (_a) {
            return false;
        }
    };
    /** @internal */
    ObjectId.prototype.toExtendedJSON = function () {
        if (this.toHexString)
            return { $oid: this.toHexString() };
        return { $oid: this.toString('hex') };
    };
    /** @internal */
    ObjectId.fromExtendedJSON = function (doc) {
        return new ObjectId(doc.$oid);
    };
    /**
     * Converts to a string representation of this Id.
     *
     * @returns return the 24 character hex string representation.
     */
    ObjectId.prototype.inspect = function (depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : ;
        utils_1.defaultInspect;
        return "new ObjectId(" + inspect(this.toHexString(), options) + ")";
    };
    /** @internal */
    ObjectId.index = Math.floor(Math.random() * 0xffffff);
    return ObjectId;
}(bson_value_1.BSONValue));
exports.ObjectId = ObjectId;
