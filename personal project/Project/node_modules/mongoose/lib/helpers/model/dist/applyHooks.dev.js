'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var symbols = require('../../schema/symbols');

var promiseOrCallback = require('../promiseOrCallback');
/*!
 * ignore
 */


module.exports = applyHooks;
/*!
 * ignore
 */

applyHooks.middlewareFunctions = ['deleteOne', 'save', 'validate', 'remove', 'updateOne', 'init'];
/*!
 * ignore
 */

var alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(function (fn) {
  return [fn, "$__".concat(fn)];
}));
/**
 * Register hooks for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 * @param {Object} options
 * @api private
 */

function applyHooks(model, schema, options) {
  options = options || {};
  var kareemOptions = {
    useErrorHandlers: true,
    numCallbackParams: 1,
    nullResultByDefault: true,
    contextParameter: true
  };
  var objToDecorate = options.decorateDoc ? model : model.prototype;
  model.$appliedHooks = true;

  for (var _i = 0, _Object$keys = Object.keys(schema.paths); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var type = schema.paths[key];
    var childModel = null;

    if (type.$isSingleNested) {
      childModel = type.caster;
    } else if (type.$isMongooseDocumentArray) {
      childModel = type.Constructor;
    } else {
      continue;
    }

    if (childModel.$appliedHooks) {
      continue;
    }

    applyHooks(childModel, type.schema, _objectSpread({}, options, {
      isChildSchema: true
    }));

    if (childModel.discriminators != null) {
      var keys = Object.keys(childModel.discriminators);

      for (var _i4 = 0, _keys = keys; _i4 < _keys.length; _i4++) {
        var _key = _keys[_i4];
        applyHooks(childModel.discriminators[_key], childModel.discriminators[_key].schema, options);
      }
    }
  } // Built-in hooks rely on hooking internal functions in order to support
  // promises and make it so that `doc.save.toString()` provides meaningful
  // information.


  var middleware = schema.s.hooks.filter(function (hook) {
    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {
      return !!hook['document'];
    }

    if (hook.name === 'remove' || hook.name === 'init') {
      return hook['document'] == null || !!hook['document'];
    }

    if (hook.query != null || hook.document != null) {
      return hook.document !== false;
    }

    return true;
  }).filter(function (hook) {
    // If user has overwritten the method, don't apply built-in middleware
    if (schema.methods[hook.name]) {
      return !hook.fn[symbols.builtInMiddleware];
    }

    return true;
  });
  model._middleware = middleware;
  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
  var internalMethodsToWrap = options && options.isChildSchema ? ['save', 'validate', 'deleteOne'] : ['save', 'validate'];

  for (var _i2 = 0, _internalMethodsToWra = internalMethodsToWrap; _i2 < _internalMethodsToWra.length; _i2++) {
    var method = _internalMethodsToWra[_i2];
    var toWrap = method === 'validate' ? '$__originalValidate' : "$__".concat(method);
    var wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
    objToDecorate["$__".concat(method)] = wrapped;
  }

  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions); // Support hooks for custom methods

  var customMethods = Object.keys(schema.methods);
  var customMethodOptions = Object.assign({}, kareemOptions, {
    // Only use `checkForPromise` for custom methods, because mongoose
    // query thunks are not as consistent as I would like about returning
    // a nullish value rather than the query. If a query thunk returns
    // a query, `checkForPromise` causes infinite recursion
    checkForPromise: true
  });

  var _loop = function _loop() {
    var method = _customMethods[_i3];

    if (alreadyHookedFunctions.has(method)) {
      return "continue";
    }

    if (!middleware.hasHooks(method)) {
      // Don't wrap if there are no hooks for the custom method to avoid
      // surprises. Also, `createWrapper()` enforces consistent async,
      // so wrapping a sync method would break it.
      return "continue";
    }

    var originalMethod = objToDecorate[method];

    objToDecorate[method] = function () {
      var _this = this;

      var args = Array.prototype.slice.call(arguments);
      var cb = args.slice(-1).pop();
      var argsWithoutCallback = typeof cb === 'function' ? args.slice(0, args.length - 1) : args;
      return promiseOrCallback(cb, function (callback) {
        return _this["$__".concat(method)].apply(_this, argsWithoutCallback.concat([callback]));
      }, model.events);
    };

    objToDecorate["$__".concat(method)] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
  };

  for (var _i3 = 0, _customMethods = customMethods; _i3 < _customMethods.length; _i3++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }
}