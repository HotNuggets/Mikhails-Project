"use strict";
exports.__esModule = true;
exports.TopologyDescription = void 0;
var bson_1 = require("../bson");
var WIRE_CONSTANTS = require("../cmap/wire_protocol/constants");
var error_1 = require("../error");
var utils_1 = require("../utils");
var common_1 = require("./common");
var server_description_1 = require("./server_description");
// constants related to compatibility checks
var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
var NON_PRIMARY_RS_MEMBERS = new Set([
    common_1.ServerType.RSSecondary,
    common_1.ServerType.RSArbiter,
    common_1.ServerType.RSOther
]);
/**
 * Representation of a deployment of servers
 * @public
 */
var TopologyDescription = /** @class */ (function () {
    /**
     * Create a TopologyDescription
     */
    function TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {
        if (serverDescriptions === void 0) { serverDescriptions = null; }
        if (setName === void 0) { setName = null; }
        if (maxSetVersion === void 0) { maxSetVersion = null; }
        if (maxElectionId === void 0) { maxElectionId = null; }
        if (commonWireVersion === void 0) { commonWireVersion = null; }
        if (options === void 0) { options = null; }
        var _a, _b;
        options = options !== null && options !== void 0 ? options : {};
        this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;
        this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();
        this.stale = false;
        this.compatible = true;
        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;
        this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 15;
        this.setName = setName !== null && setName !== void 0 ? setName : null;
        this.maxElectionId = maxElectionId !== null && maxElectionId !== void 0 ? maxElectionId : null;
        this.maxSetVersion = maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : null;
        this.commonWireVersion = commonWireVersion !== null && commonWireVersion !== void 0 ? commonWireVersion : 0;
        // determine server compatibility
        for (var _i = 0, _c = this.servers.values(); _i < _c.length; _i++) {
            var serverDescription = _c[_i];
            // Load balancer mode is always compatible.
            if (serverDescription.type === common_1.ServerType.Unknown ||
                serverDescription.type === common_1.ServerType.LoadBalancer) {
                continue;
            }
            if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
                this.compatible = false;
                this.compatibilityError = "Server at " + serverDescription.address + " requires wire version " + serverDescription.minWireVersion + ", but this version of the driver only supports up to " + MAX_SUPPORTED_WIRE_VERSION + " (MongoDB " + MAX_SUPPORTED_SERVER_VERSION + ")";
            }
            if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
                this.compatible = false;
                this.compatibilityError = "Server at " + serverDescription.address + " reports wire version " + serverDescription.maxWireVersion + ", but this version of the driver requires at least " + MIN_SUPPORTED_WIRE_VERSION + " (MongoDB " + MIN_SUPPORTED_SERVER_VERSION + ").";
                break;
            }
        }
        // Whenever a client updates the TopologyDescription from a hello response, it MUST set
        // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes
        // value among ServerDescriptions of all data-bearing server types. If any have a null
        // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be
        // set to null.
        this.logicalSessionTimeoutMinutes = null;
        for (var _d = 0, _e = this.servers; _d < _e.length; _d++) {
            var _f = _e[_d], server = _f[1];
            if (server.isReadable) {
                if (server.logicalSessionTimeoutMinutes == null) {
                    // If any of the servers have a null logicalSessionsTimeout, then the whole topology does
                    this.logicalSessionTimeoutMinutes = null;
                    break;
                }
                if (this.logicalSessionTimeoutMinutes == null) {
                    // First server with a non null logicalSessionsTimeout
                    this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
                    continue;
                }
                // Always select the smaller of the:
                // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout
                this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
            }
        }
    }
    /**
     * Returns a new TopologyDescription based on the SrvPollingEvent
     * @internal
     */
    TopologyDescription.prototype.updateFromSrvPollingEvent = function (ev, srvMaxHosts) {
        if (srvMaxHosts === void 0) { srvMaxHosts = 0; }
        /** The SRV addresses defines the set of addresses we should be using */
        var incomingHostnames = ev.hostnames();
        var currentHostnames = new Set(this.servers.keys());
        var hostnamesToAdd = new Set(incomingHostnames);
        var hostnamesToRemove = new Set();
        for (var _i = 0, currentHostnames_1 = currentHostnames; _i < currentHostnames_1.length; _i++) {
            var hostname = currentHostnames_1[_i];
            // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames
            hostnamesToAdd["delete"](hostname);
            if (!incomingHostnames.has(hostname)) {
                // If the SRV Records no longer include this hostname
                // we have to stop using it
                hostnamesToRemove.add(hostname);
            }
        }
        if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
            // No new hosts to add and none to remove
            return this;
        }
        var serverDescriptions = new Map(this.servers);
        for (var _a = 0, hostnamesToRemove_1 = hostnamesToRemove; _a < hostnamesToRemove_1.length; _a++) {
            var removedHost = hostnamesToRemove_1[_a];
            serverDescriptions["delete"](removedHost);
        }
        if (hostnamesToAdd.size > 0) {
            if (srvMaxHosts === 0) {
                // Add all!
                for (var _b = 0, hostnamesToAdd_1 = hostnamesToAdd; _b < hostnamesToAdd_1.length; _b++) {
                    var hostToAdd = hostnamesToAdd_1[_b];
                    serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
                }
            }
            else if (serverDescriptions.size < srvMaxHosts) {
                // Add only the amount needed to get us back to srvMaxHosts
                var selectedHosts = utils_1.shuffle(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
                for (var _c = 0, selectedHosts_1 = selectedHosts; _c < selectedHosts_1.length; _c++) {
                    var selectedHostToAdd = selectedHosts_1[_c];
                    serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
                }
            }
        }
        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    };
    /**
     * Returns a copy of this description updated with a given ServerDescription
     * @internal
     */
    TopologyDescription.prototype.update = function (serverDescription) {
        var address = serverDescription.address;
        // potentially mutated values
        var _a = this, topologyType = _a.type, setName = _a.setName, maxSetVersion = _a.maxSetVersion, maxElectionId = _a.maxElectionId, commonWireVersion = _a.commonWireVersion;
        var serverType = serverDescription.type;
        var serverDescriptions = new Map(this.servers);
        // update common wire version
        if (serverDescription.maxWireVersion !== 0) {
            if (commonWireVersion == null) {
                commonWireVersion = serverDescription.maxWireVersion;
            }
            else {
                commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
            }
        }
        if (typeof serverDescription.setName === 'string' &&
            typeof setName === 'string' &&
            serverDescription.setName !== setName) {
            if (topologyType === common_1.TopologyType.Single) {
                // "Single" Topology with setName mismatch is direct connection usage, mark unknown do not remove
                serverDescription = new server_description_1.ServerDescription(address);
            }
            else {
                serverDescriptions["delete"](address);
            }
        }
        // update the actual server description
        serverDescriptions.set(address, serverDescription);
        if (topologyType === common_1.TopologyType.Single) {
            // once we are defined as single, that never changes
            return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
        }
        if (topologyType === common_1.TopologyType.Unknown) {
            if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
                serverDescriptions["delete"](address);
            }
            else {
                topologyType = topologyTypeForServerType(serverType);
            }
        }
        if (topologyType === common_1.TopologyType.Sharded) {
            if (!MONGOS_OR_UNKNOWN.has(serverType)) {
                serverDescriptions["delete"](address);
            }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
            if (MONGOS_OR_STANDALONE.has(serverType)) {
                serverDescriptions["delete"](address);
            }
            if (serverType === common_1.ServerType.RSPrimary) {
                var result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
                topologyType = result[0];
                setName = result[1];
                maxSetVersion = result[2];
                maxElectionId = result[3];
            }
            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
                var result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
                topologyType = result[0];
                setName = result[1];
            }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
            if (MONGOS_OR_STANDALONE.has(serverType)) {
                serverDescriptions["delete"](address);
                topologyType = checkHasPrimary(serverDescriptions);
            }
            else if (serverType === common_1.ServerType.RSPrimary) {
                var result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
                topologyType = result[0];
                setName = result[1];
                maxSetVersion = result[2];
                maxElectionId = result[3];
            }
            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
                topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
            }
            else {
                topologyType = checkHasPrimary(serverDescriptions);
            }
        }
        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    };
    Object.defineProperty(TopologyDescription.prototype, "error", {
        get: function () {
            var descriptionsWithError = Array.from(this.servers.values()).filter(function (sd) { return sd.error; });
            if (descriptionsWithError.length > 0) {
                return descriptionsWithError[0].error;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TopologyDescription.prototype, "hasKnownServers", {
        /**
         * Determines if the topology description has any known servers
         */
        get: function () {
            return Array.from(this.servers.values()).some(function (sd) { return sd.type !== common_1.ServerType.Unknown; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TopologyDescription.prototype, "hasDataBearingServers", {
        /**
         * Determines if this topology description has a data-bearing server available.
         */
        get: function () {
            return Array.from(this.servers.values()).some(function (sd) { return sd.isDataBearing; });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Determines if the topology has a definition for the provided address
     * @internal
     */
    TopologyDescription.prototype.hasServer = function (address) {
        return this.servers.has(address);
    };
    /**
     * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily
     * intended for use with JSON.stringify().
     *
     * This method will not throw.
     */
    TopologyDescription.prototype.toJSON = function () {
        return bson_1.EJSON.serialize(this);
    };
    return TopologyDescription;
}());
exports.TopologyDescription = TopologyDescription;
function topologyTypeForServerType(serverType) {
    switch (serverType) {
        case common_1.ServerType.Standalone:
            return common_1.TopologyType.Single;
        case common_1.ServerType.Mongos:
            return common_1.TopologyType.Sharded;
        case common_1.ServerType.RSPrimary:
            return common_1.TopologyType.ReplicaSetWithPrimary;
        case common_1.ServerType.RSOther:
        case common_1.ServerType.RSSecondary:
            return common_1.TopologyType.ReplicaSetNoPrimary;
        default:
            return common_1.TopologyType.Unknown;
    }
}
function updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {
    var _a;
    if (setName === void 0) { setName = null; }
    if (maxSetVersion === void 0) { maxSetVersion = null; }
    if (maxElectionId === void 0) { maxElectionId = null; }
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
        serverDescriptions["delete"](serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    if (serverDescription.maxWireVersion >= 17) {
        var electionIdComparison = utils_1.compareObjectId(maxElectionId, serverDescription.electionId);
        var maxElectionIdIsEqual = electionIdComparison === 0;
        var maxElectionIdIsLess = electionIdComparison === -1;
        var maxSetVersionIsLessOrEqual = (maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : -1) <= ((_a = serverDescription.setVersion) !== null && _a !== void 0 ? _a : -1);
        if (maxElectionIdIsLess || (maxElectionIdIsEqual && maxSetVersionIsLessOrEqual)) {
            // The reported electionId was greater
            // or the electionId was equal and reported setVersion was greater
            // Always update both values, they are a tuple
            maxElectionId = serverDescription.electionId;
            maxSetVersion = serverDescription.setVersion;
        }
        else {
            // Stale primary
            // replace serverDescription with a default ServerDescription of type "Unknown"
            serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
    }
    else {
        var electionId = serverDescription.electionId ? serverDescription.electionId : null;
        if (serverDescription.setVersion && electionId) {
            if (maxSetVersion && maxElectionId) {
                if (maxSetVersion > serverDescription.setVersion ||
                    utils_1.compareObjectId(maxElectionId, electionId) > 0) {
                    // this primary is stale, we must remove it
                    serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
                    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
                }
            }
            maxElectionId = serverDescription.electionId;
        }
        if (serverDescription.setVersion != null &&
            (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
            maxSetVersion = serverDescription.setVersion;
        }
    }
    // We've heard from the primary. Is it the same primary as before?
    for (var _i = 0, serverDescriptions_1 = serverDescriptions; _i < serverDescriptions_1.length; _i++) {
        var _b = serverDescriptions_1[_i], address = _b[0], server = _b[1];
        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
            // Reset old primary's type to Unknown.
            serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));
            // There can only be one primary
            break;
        }
    }
    // Discover new hosts from this primary's response.
    serverDescription.allHosts.forEach(function (address) {
        if (!serverDescriptions.has(address)) {
            serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
    });
    // Remove hosts not in the response.
    var currentAddresses = Array.from(serverDescriptions.keys());
    var responseAddresses = serverDescription.allHosts;
    currentAddresses
        .filter(function (addr) { return responseAddresses.indexOf(addr) === -1; })
        .forEach(function (address) {
        serverDescriptions["delete"](address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
}
function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {
    if (setName === void 0) { setName = null; }
    if (setName == null) {
        // TODO(NODE-3483): should be an appropriate runtime error
        throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
    }
    if (setName !== serverDescription.setName ||
        (serverDescription.me && serverDescription.address !== serverDescription.me)) {
        serverDescriptions["delete"](serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
}
function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {
    if (setName === void 0) { setName = null; }
    var topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
    setName = setName !== null && setName !== void 0 ? setName : serverDescription.setName;
    if (setName !== serverDescription.setName) {
        serverDescriptions["delete"](serverDescription.address);
        return [topologyType, setName];
    }
    serverDescription.allHosts.forEach(function (address) {
        if (!serverDescriptions.has(address)) {
            serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions["delete"](serverDescription.address);
    }
    return [topologyType, setName];
}
function checkHasPrimary(serverDescriptions) {
    for (var _i = 0, _a = serverDescriptions.values(); _i < _a.length; _i++) {
        var serverDescription = _a[_i];
        if (serverDescription.type === common_1.ServerType.RSPrimary) {
            return common_1.TopologyType.ReplicaSetWithPrimary;
        }
    }
    return common_1.TopologyType.ReplicaSetNoPrimary;
}
