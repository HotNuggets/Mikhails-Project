"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var zlib_1 = require("zlib");

var sparse_bitfield_1 = __importDefault(require("sparse-bitfield"));

var codePoints = __importStar(require("./code-points-src"));

var fs_1 = require("fs");

var prettier = __importStar(require("prettier"));

var unassigned_code_points = (0, sparse_bitfield_1["default"])();
var commonly_mapped_to_nothing = (0, sparse_bitfield_1["default"])();
var non_ascii_space_characters = (0, sparse_bitfield_1["default"])();
var prohibited_characters = (0, sparse_bitfield_1["default"])();
var bidirectional_r_al = (0, sparse_bitfield_1["default"])();
var bidirectional_l = (0, sparse_bitfield_1["default"])();

function traverse(bits, src) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = src.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var code = _step.value;
      bits.set(code, true);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var buffer = bits.toBuffer();
  return Buffer.concat([createSize(buffer), buffer]);
}

function createSize(buffer) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32BE(buffer.length);
  return buf;
}

var memory = [];
memory.push(traverse(unassigned_code_points, codePoints.unassigned_code_points), traverse(commonly_mapped_to_nothing, codePoints.commonly_mapped_to_nothing), traverse(non_ascii_space_characters, codePoints.non_ASCII_space_characters), traverse(prohibited_characters, codePoints.prohibited_characters), traverse(bidirectional_r_al, codePoints.bidirectional_r_al), traverse(bidirectional_l, codePoints.bidirectional_l));

function writeCodepoints() {
  var config, formatOptions, write, fsStreamUncompressedData;
  return regeneratorRuntime.async(function writeCodepoints$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          write = function _ref(stream, chunk) {
            return new Promise(function (resolve) {
              return stream.write(chunk, function () {
                return resolve();
              });
            });
          };

          _context.next = 3;
          return regeneratorRuntime.awrap(prettier.resolveConfig(__dirname));

        case 3:
          config = _context.sent;
          formatOptions = _objectSpread({}, config, {
            parser: 'typescript'
          });
          _context.next = 7;
          return regeneratorRuntime.awrap(write((0, fs_1.createWriteStream)(process.argv[2]), prettier.format("import { gunzipSync } from 'zlib';\n  \n  export default gunzipSync(\n    Buffer.from(\n      '".concat((0, zlib_1.gzipSync)(Buffer.concat(memory), {
            level: 9
          }).toString('base64'), "',\n      'base64'\n    )\n  );\n  "), formatOptions)));

        case 7:
          fsStreamUncompressedData = (0, fs_1.createWriteStream)(process.argv[3]);
          _context.next = 10;
          return regeneratorRuntime.awrap(write(fsStreamUncompressedData, prettier.format("const data = Buffer.from('".concat(Buffer.concat(memory).toString('base64'), "', 'base64');\nexport default data;\n"), formatOptions)));

        case 10:
        case "end":
          return _context.stop();
      }
    }
  });
}

writeCodepoints()["catch"](function (error) {
  return console.error('error occurred generating saslprep codepoint data', {
    error: error
  });
});