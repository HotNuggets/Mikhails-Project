'use strict';

var clone = require('../../helpers/clone');

var documentSchemaSymbol = require('../../helpers/symbols').documentSchemaSymbol;

var internalToObjectOptions = require('../../options').internalToObjectOptions;

var utils = require('../../utils');

var Document;

var getSymbol = require('../../helpers/symbols').getSymbol;

var scopeSymbol = require('../../helpers/symbols').scopeSymbol;

var isPOJO = utils.isPOJO;
/*!
 * exports
 */

exports.compile = compile;
exports.defineKey = defineKey;

var _isEmptyOptions = Object.freeze({
  minimize: true,
  virtuals: false,
  getters: false,
  transform: false
});

var noDottedPathGetOptions = Object.freeze({
  noDottedPath: true
});
/**
 * Compiles schemas.
 * @param {Object} tree
 * @param {Any} proto
 * @param {String} prefix
 * @param {Object} options
 * @api private
 */

function compile(tree, proto, prefix, options) {
  Document = Document || require('../../document');
  var typeKey = options.typeKey;

  for (var _i = 0, _Object$keys = Object.keys(tree); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var limb = tree[key];
    var hasSubprops = isPOJO(limb) && Object.keys(limb).length > 0 && (!limb[typeKey] || typeKey === 'type' && isPOJO(limb.type) && limb.type.type);
    var subprops = hasSubprops ? limb : null;
    defineKey({
      prop: key,
      subprops: subprops,
      prototype: proto,
      prefix: prefix,
      options: options
    });
  }
}
/**
 * Defines the accessor named prop on the incoming prototype.
 * @param {Object} options
 * @param {String} options.prop
 * @param {Boolean} options.subprops
 * @param {Any} options.prototype
 * @param {String} [options.prefix]
 * @param {Object} options.options
 * @api private
 */


function defineKey(_ref) {
  var prop = _ref.prop,
      subprops = _ref.subprops,
      prototype = _ref.prototype,
      prefix = _ref.prefix,
      options = _ref.options;
  Document = Document || require('../../document');
  var path = (prefix ? prefix + '.' : '') + prop;
  prefix = prefix || '';
  var useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;

  if (subprops) {
    Object.defineProperty(prototype, prop, {
      enumerable: true,
      configurable: true,
      get: function get() {
        var _this = this;

        if (!this.$__.getters) {
          this.$__.getters = {};
        }

        if (!this.$__.getters[path]) {
          var nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this)); // save scope for nested getters/setters

          if (!prefix) {
            nested.$__[scopeSymbol] = this;
          }

          nested.$__.nestedPath = path;
          Object.defineProperty(nested, 'schema', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: prototype.schema
          });
          Object.defineProperty(nested, '$__schema', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: prototype.schema
          });
          Object.defineProperty(nested, documentSchemaSymbol, {
            enumerable: false,
            configurable: true,
            writable: false,
            value: prototype.schema
          });
          Object.defineProperty(nested, 'toObject', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: function value() {
              return clone(_this.get(path, null, {
                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
              }));
            }
          });
          Object.defineProperty(nested, '$__get', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: function value() {
              return _this.get(path, null, {
                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
              });
            }
          });
          Object.defineProperty(nested, 'toJSON', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: function value() {
              return _this.get(path, null, {
                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null
              });
            }
          });
          Object.defineProperty(nested, '$__isNested', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: true
          });
          Object.defineProperty(nested, '$isEmpty', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: function value() {
              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
            }
          });
          Object.defineProperty(nested, '$__parent', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: this
          });
          compile(subprops, nested, path, options);
          this.$__.getters[path] = nested;
        }

        return this.$__.getters[path];
      },
      set: function set(v) {
        if (v != null && v.$__isNested) {
          // Convert top-level to POJO, but leave subdocs hydrated so `$set`
          // can handle them. See gh-9293.
          v = v.$__get();
        } else if (v instanceof Document && !v.$__isNested) {
          v = v.$toObject(internalToObjectOptions);
        }

        var doc = this.$__[scopeSymbol] || this;
        doc.$set(path, v);
      }
    });
  } else {
    Object.defineProperty(prototype, prop, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return this[getSymbol].call(this.$__[scopeSymbol] || this, path, null, useGetOptions);
      },
      set: function set(v) {
        this.$set.call(this.$__[scopeSymbol] || this, path, v);
      }
    });
  }
} // gets descriptors for all properties of `object`
// makes all properties non-enumerable to match previous behavior to #2211


function getOwnPropertyDescriptors(object) {
  var result = {};
  Object.getOwnPropertyNames(object).forEach(function (key) {
    var skip = ['isNew', '$__', '$errors', 'errors', '_doc', '$locals', '$op', '__parentArray', '__index', '$isDocumentArrayElement'].indexOf(key) === -1;

    if (skip) {
      return;
    }

    result[key] = Object.getOwnPropertyDescriptor(object, key);
    result[key].enumerable = false;
  });
  return result;
}