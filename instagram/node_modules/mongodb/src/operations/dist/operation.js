"use strict";
exports.__esModule = true;
exports.defineAspects = exports.AbstractOperation = exports.Aspect = void 0;
var bson_1 = require("../bson");
var read_preference_1 = require("../read_preference");
exports.Aspect = {
    READ_OPERATION: Symbol('READ_OPERATION'),
    WRITE_OPERATION: Symbol('WRITE_OPERATION'),
    RETRYABLE: Symbol('RETRYABLE'),
    EXPLAINABLE: Symbol('EXPLAINABLE'),
    SKIP_COLLATION: Symbol('SKIP_COLLATION'),
    CURSOR_CREATING: Symbol('CURSOR_CREATING'),
    MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER')
};
/** @internal */
var kSession = Symbol('session');
/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 * @internal
 */
var AbstractOperation = /** @class */ (function () {
    function AbstractOperation(options) {
        if (options === void 0) { options = {}; }
        var _a;
        this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION)
            ? read_preference_1.ReadPreference.primary
            : ((_a = read_preference_1.ReadPreference.fromOptions(options)) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary);
        // Pull the BSON serialize options from the already-resolved options
        this.bsonOptions = bson_1.resolveBSONOptions(options);
        this[kSession] = options.session != null ? options.session : undefined;
        this.options = options;
        this.bypassPinningCheck = !!options.bypassPinningCheck;
        this.trySecondaryWrite = false;
    }
    AbstractOperation.prototype.hasAspect = function (aspect) {
        var ctor = this.constructor;
        if (ctor.aspects == null) {
            return false;
        }
        return ctor.aspects.has(aspect);
    };
    Object.defineProperty(AbstractOperation.prototype, "session", {
        get: function () {
            return this[kSession];
        },
        enumerable: false,
        configurable: true
    });
    AbstractOperation.prototype.clearSession = function () {
        this[kSession] = undefined;
    };
    Object.defineProperty(AbstractOperation.prototype, "canRetryRead", {
        get: function () {
            return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.READ_OPERATION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractOperation.prototype, "canRetryWrite", {
        get: function () {
            return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.WRITE_OPERATION);
        },
        enumerable: false,
        configurable: true
    });
    return AbstractOperation;
}());
exports.AbstractOperation = AbstractOperation;
function defineAspects(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, 'aspects', {
        value: aspects,
        writable: false
    });
    return aspects;
}
exports.defineAspects = defineAspects;
