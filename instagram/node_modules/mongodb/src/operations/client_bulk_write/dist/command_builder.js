"use strict";
exports.__esModule = true;
exports.buildOperation = exports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = void 0;
var commands_1 = require("../../cmap/commands");
/** @internal */
var ClientBulkWriteCommandBuilder = /** @class */ (function () {
    /**
     * Create the command builder.
     * @param models - The client write models.
     */
    function ClientBulkWriteCommandBuilder(models, options) {
        this.models = models;
        this.options = options;
    }
    Object.defineProperty(ClientBulkWriteCommandBuilder.prototype, "errorsOnly", {
        /**
         * Gets the errorsOnly value for the command, which is the inverse of the
         * user provided verboseResults option. Defaults to true.
         */
        get: function () {
            if ('verboseResults' in this.options) {
                return !this.options.verboseResults;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Build the bulk write commands from the models.
     */
    ClientBulkWriteCommandBuilder.prototype.buildCommands = function () {
        var _a;
        // Iterate the models to build the ops and nsInfo fields.
        var operations = [];
        var currentNamespaceIndex = 0;
        var namespaces = new Map();
        for (var _i = 0, _b = this.models; _i < _b.length; _i++) {
            var model = _b[_i];
            var ns = model.namespace;
            var index = namespaces.get(ns);
            if (index != null) {
                operations.push(buildOperation(model, index));
            }
            else {
                namespaces.set(ns, currentNamespaceIndex);
                operations.push(buildOperation(model, currentNamespaceIndex));
                currentNamespaceIndex++;
            }
        }
        var nsInfo = Array.from(namespaces.keys(), function (ns) { return ({ ns: ns }); });
        // The base command.
        var command = {
            bulkWrite: 1,
            errorsOnly: this.errorsOnly,
            ordered: (_a = this.options.ordered) !== null && _a !== void 0 ? _a : true,
            ops: new commands_1.DocumentSequence(operations),
            nsInfo: new commands_1.DocumentSequence(nsInfo)
        };
        // Add bypassDocumentValidation if it was present in the options.
        if (this.options.bypassDocumentValidation != null) {
            command.bypassDocumentValidation = this.options.bypassDocumentValidation;
        }
        // Add let if it was present in the options.
        if (this.options.let) {
            command.let = this.options.let;
        }
        return [command];
    };
    return ClientBulkWriteCommandBuilder;
}());
exports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
/**
 * Build the insert one operation.
 * @param model - The insert one model.
 * @param index - The namespace index.
 * @returns the operation.
 */
exports.buildInsertOneOperation = function (model, index) {
    var document = {
        insert: index,
        document: model.document
    };
    return document;
};
/**
 * Build the delete one operation.
 * @param model - The insert many model.
 * @param index - The namespace index.
 * @returns the operation.
 */
exports.buildDeleteOneOperation = function (model, index) {
    return createDeleteOperation(model, index, false);
};
/**
 * Build the delete many operation.
 * @param model - The delete many model.
 * @param index - The namespace index.
 * @returns the operation.
 */
exports.buildDeleteManyOperation = function (model, index) {
    return createDeleteOperation(model, index, true);
};
/**
 * Creates a delete operation based on the parameters.
 */
function createDeleteOperation(model, index, multi) {
    var document = {
        "delete": index,
        multi: multi,
        filter: model.filter
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
}
/**
 * Build the update one operation.
 * @param model - The update one model.
 * @param index - The namespace index.
 * @returns the operation.
 */
exports.buildUpdateOneOperation = function (model, index) {
    return createUpdateOperation(model, index, false);
};
/**
 * Build the update many operation.
 * @param model - The update many model.
 * @param index - The namespace index.
 * @returns the operation.
 */
exports.buildUpdateManyOperation = function (model, index) {
    return createUpdateOperation(model, index, true);
};
/**
 * Creates a delete operation based on the parameters.
 */
function createUpdateOperation(model, index, multi) {
    var document = {
        update: index,
        multi: multi,
        filter: model.filter,
        updateMods: model.update
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.upsert) {
        document.upsert = model.upsert;
    }
    if (model.arrayFilters) {
        document.arrayFilters = model.arrayFilters;
    }
    return document;
}
/**
 * Build the replace one operation.
 * @param model - The replace one model.
 * @param index - The namespace index.
 * @returns the operation.
 */
exports.buildReplaceOneOperation = function (model, index) {
    var document = {
        update: index,
        multi: false,
        filter: model.filter,
        updateMods: model.replacement
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.upsert) {
        document.upsert = model.upsert;
    }
    return document;
};
/** @internal */
function buildOperation(model, index) {
    switch (model.name) {
        case 'insertOne':
            return exports.buildInsertOneOperation(model, index);
        case 'deleteOne':
            return exports.buildDeleteOneOperation(model, index);
        case 'deleteMany':
            return exports.buildDeleteManyOperation(model, index);
        case 'updateOne':
            return exports.buildUpdateOneOperation(model, index);
        case 'updateMany':
            return exports.buildUpdateManyOperation(model, index);
        case 'replaceOne':
            return exports.buildReplaceOneOperation(model, index);
    }
}
exports.buildOperation = buildOperation;
