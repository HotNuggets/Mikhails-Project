"use strict";
exports.__esModule = true;
exports.onData = void 0;
var utils_1 = require("../../utils");
 > ,
    'promise'
        > ;
/**
 * onData is adapted from Node.js' events.on helper
 * https://nodejs.org/api/events.html#eventsonemitter-eventname-options
 *
 * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.
 * It will reject upon an error event.
 */
function onData(emitter) {
    var _a;
    // Setup pending events and pending promise lists
    /**
     * When the caller has not yet called .next(), we store the
     * value from the event in this list. Next time they call .next()
     * we pull the first value out of this list and resolve a promise with it.
     */
    var unconsumedEvents = new utils_1.List();
    /**
     * When there has not yet been an event, a new promise will be created
     * and implicitly stored in this list. When an event occurs we take the first
     * promise in this list and resolve it.
     */
    var unconsumedPromises = new utils_1.List();
    /**
     * Stored an error created by an error event.
     * This error will turn into a rejection for the subsequent .next() call
     */
    var error = null;
    /** Set to true only after event listeners have been removed. */
    var finished = false;
    var iterator = (_a = {
            next: function () {
                // First, we consume all unread events
                var value = unconsumedEvents.shift();
                if (value != null) {
                    return Promise.resolve({ value: value, done: false });
                }
                // Then we error, if an error happened
                // This happens one time if at all, because after 'error'
                // we stop listening
                if (error != null) {
                    var p = Promise.reject(error);
                    // Only the first element errors
                    error = null;
                    return p;
                }
                // If the iterator is finished, resolve to done
                if (finished)
                    return closeHandler();
                // Wait until an event happens
                var _a = utils_1.promiseWithResolvers(), promise = _a.promise, resolve = _a.resolve, reject = _a.reject;
                unconsumedPromises.push({ resolve: resolve, reject: reject });
                return promise;
            },
            "return": function () {
                return closeHandler();
            },
            "throw": function (err) {
                errorHandler(err);
                return Promise.resolve({ value: undefined, done: true });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a);
    // Adding event handlers
    emitter.on('data', eventHandler);
    emitter.on('error', errorHandler);
    return iterator;
    function eventHandler(value) {
        var promise = unconsumedPromises.shift();
        if (promise != null)
            promise.resolve({ value: value, done: false });
        else
            unconsumedEvents.push(value);
    }
    function errorHandler(err) {
        var promise = unconsumedPromises.shift();
        if (promise != null)
            promise.reject(err);
        else
            error = err;
        void closeHandler();
    }
    function closeHandler() {
        // Adding event handlers
        emitter.off('data', eventHandler);
        emitter.off('error', errorHandler);
        finished = true;
        var doneResult = { value: undefined, done: finished };
        for (var _i = 0, unconsumedPromises_1 = unconsumedPromises; _i < unconsumedPromises_1.length; _i++) {
            var promise = unconsumedPromises_1[_i];
            promise.resolve(doneResult);
        }
        return Promise.resolve(doneResult);
    }
}
exports.onData = onData;
