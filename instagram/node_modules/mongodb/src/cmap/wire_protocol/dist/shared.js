"use strict";
exports.__esModule = true;
exports.isSharded = exports.getReadPreference = void 0;
var error_1 = require("../../error");
var read_preference_1 = require("../../read_preference");
var common_1 = require("../../sdam/common");
var topology_description_1 = require("../../sdam/topology_description");
function getReadPreference(options) {
    var _a;
    // Default to command version of the readPreference.
    var readPreference = (_a = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
    if (typeof readPreference === 'string') {
        readPreference = read_preference_1.ReadPreference.fromString(readPreference);
    }
    if (!(readPreference instanceof read_preference_1.ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
    }
    return readPreference;
}
exports.getReadPreference = getReadPreference;
function isSharded(topologyOrServer) {
    if (topologyOrServer == null) {
        return false;
    }
    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
        return true;
    }
    // NOTE: This is incredibly inefficient, and should be removed once command construction
    // happens based on `Server` not `Topology`.
    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
        var servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some(function (server) { return server.type === common_1.ServerType.Mongos; });
    }
    return false;
}
exports.isSharded = isSharded;
