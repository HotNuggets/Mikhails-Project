"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.Db = void 0;
var admin_1 = require("./admin");
var bson_1 = require("./bson");
var change_stream_1 = require("./change_stream");
var collection_1 = require("./collection");
var CONSTANTS = require("./constants");
var aggregation_cursor_1 = require("./cursor/aggregation_cursor");
var list_collections_cursor_1 = require("./cursor/list_collections_cursor");
var run_command_cursor_1 = require("./cursor/run_command_cursor");
var error_1 = require("./error");
var collections_1 = require("./operations/collections");
var create_collection_1 = require("./operations/create_collection");
var drop_1 = require("./operations/drop");
var execute_operation_1 = require("./operations/execute_operation");
var indexes_1 = require("./operations/indexes");
var profiling_level_1 = require("./operations/profiling_level");
var remove_user_1 = require("./operations/remove_user");
var rename_1 = require("./operations/rename");
var run_command_1 = require("./operations/run_command");
var set_profiling_level_1 = require("./operations/set_profiling_level");
var stats_1 = require("./operations/stats");
var read_concern_1 = require("./read_concern");
var read_preference_1 = require("./read_preference");
var utils_1 = require("./utils");
var write_concern_1 = require("./write_concern");
// Allowed parameters
var DB_OPTIONS_ALLOW_LIST = [
    'writeConcern',
    'readPreference',
    'readPreferenceTags',
    'native_parser',
    'forceServerObjectId',
    'pkFactory',
    'serializeFunctions',
    'raw',
    'authSource',
    'ignoreUndefined',
    'readConcern',
    'retryMiliSeconds',
    'numberOfRetries',
    'useBigInt64',
    'promoteBuffers',
    'promoteLongs',
    'bsonRegExp',
    'enableUtf8Validation',
    'promoteValues',
    'compression',
    'retryWrites',
    'timeoutMS'
];
/**
 * The **Db** class is a class that represents a MongoDB Database.
 * @public
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * interface Pet {
 *   name: string;
 *   kind: 'dog' | 'cat' | 'fish';
 * }
 *
 * const client = new MongoClient('mongodb://localhost:27017');
 * const db = client.db();
 *
 * // Create a collection that validates our union
 * await db.createCollection<Pet>('pets', {
 *   validator: { $expr: { $in: ['$kind', ['dog', 'cat', 'fish']] } }
 * })
 * ```
 */
var Db = /** @class */ (function () {
    /**
     * Creates a new Db instance.
     *
     * Db name cannot contain a dot, the server may apply more restrictions when an operation is run.
     *
     * @param client - The MongoClient for the database.
     * @param databaseName - The name of the database this instance represents.
     * @param options - Optional settings for Db construction.
     */
    function Db(client, databaseName, options) {
        var _a;
        options = options !== null && options !== void 0 ? options : {};
        // Filter the options
        options = utils_1.filterOptions(options, DB_OPTIONS_ALLOW_LIST);
        // Ensure there are no dots in database name
        if (typeof databaseName === 'string' && databaseName.includes('.')) {
            throw new error_1.MongoInvalidArgumentError("Database names cannot contain the character '.'");
        }
        // Internal state of the db object
        this.s = {
            // Options
            options: options,
            // Unpack read preference
            readPreference: read_preference_1.ReadPreference.fromOptions(options),
            // Merge bson options
            bsonOptions: bson_1.resolveBSONOptions(options, client),
            // Set up the primary key factory or fallback to ObjectId
            pkFactory: (_a = options === null || options === void 0 ? void 0 : options.pkFactory) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PK_FACTORY,
            // ReadConcern
            readConcern: read_concern_1.ReadConcern.fromOptions(options),
            writeConcern: write_concern_1.WriteConcern.fromOptions(options),
            // Namespace
            namespace: new utils_1.MongoDBNamespace(databaseName)
        };
        this.client = client;
    }
    Object.defineProperty(Db.prototype, "databaseName", {
        get: function () {
            return this.s.namespace.db;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "options", {
        // Options
        get: function () {
            return this.s.options;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "secondaryOk", {
        /**
         * Check if a secondary can be used (because the read preference is *not* set to primary)
         */
        get: function () {
            var _a;
            return ((_a = this.s.readPreference) === null || _a === void 0 ? void 0 : _a.preference) !== 'primary' || false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "readConcern", {
        get: function () {
            return this.s.readConcern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "readPreference", {
        /**
         * The current readPreference of the Db. If not explicitly defined for
         * this Db, will be inherited from the parent MongoClient
         */
        get: function () {
            if (this.s.readPreference == null) {
                return this.client.readPreference;
            }
            return this.s.readPreference;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "bsonOptions", {
        get: function () {
            return this.s.bsonOptions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "writeConcern", {
        // get the write Concern
        get: function () {
            return this.s.writeConcern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Db.prototype, "namespace", {
        get: function () {
            return this.s.namespace.toString();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a new collection on a server with the specified options. Use this to create capped collections.
     * More information about command options available at https://www.mongodb.com/docs/manual/reference/command/create/
     *
     * Collection namespace validation is performed server-side.
     *
     * @param name - The name of the collection to create
     * @param options - Optional settings for the command
     */
    Db.prototype.createCollection = function (name, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new create_collection_1.CreateCollectionOperation(this, name, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Execute a command
     *
     * @remarks
     * This command does not inherit options from the MongoClient.
     *
     * The driver will ensure the following fields are attached to the command sent to the server:
     * - `lsid` - sourced from an implicit session or options.session
     * - `$readPreference` - defaults to primary or can be configured by options.readPreference
     * - `$db` - sourced from the name of this database
     *
     * If the client has a serverApi setting:
     * - `apiVersion`
     * - `apiStrict`
     * - `apiDeprecationErrors`
     *
     * When in a transaction:
     * - `readConcern` - sourced from readConcern set on the TransactionOptions
     * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
     *
     * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
     *
     * @param command - The command to run
     * @param options - Optional settings for the command
     */
    Db.prototype.command = function (command, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new run_command_1.RunCommandOperation(this, command, __assign(__assign({}, bson_1.resolveBSONOptions(options)), { session: options === null || options === void 0 ? void 0 : options.session, readPreference: options === null || options === void 0 ? void 0 : options.readPreference })))];
                    case 1: 
                    // Intentionally, we do not inherit options from parent for this operation.
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Execute an aggregation framework pipeline against the database, needs MongoDB \>= 3.6
     *
     * @param pipeline - An array of aggregation stages to be executed
     * @param options - Optional settings for the command
     */
    Db.prototype.aggregate = function (pipeline, options) {
        if (pipeline === void 0) { pipeline = []; }
        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, utils_1.resolveOptions(this, options));
    };
    /** Return the Admin db instance */
    Db.prototype.admin = function () {
        return new admin_1.Admin(this);
    };
    /**
     * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
     *
     * Collection namespace validation is performed server-side.
     *
     * @param name - the collection name we wish to access.
     * @returns return the new Collection instance
     */
    Db.prototype.collection = function (name, options) {
        if (options === void 0) { options = {}; }
        if (typeof options === 'function') {
            throw new error_1.MongoInvalidArgumentError('The callback form of this helper has been removed.');
        }
        return new collection_1.Collection(this, name, utils_1.resolveOptions(this, options));
    };
    /**
     * Get all the db statistics.
     *
     * @param options - Optional settings for the command
     */
    Db.prototype.stats = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new stats_1.DbStatsOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Db.prototype.listCollections = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return new list_collections_cursor_1.ListCollectionsCursor(this, filter, utils_1.resolveOptions(this, options));
    };
    /**
     * Rename a collection.
     *
     * @remarks
     * This operation does not inherit options from the MongoClient.
     *
     * @param fromCollection - Name of current collection to rename
     * @param toCollection - New name of of the collection
     * @param options - Optional settings for the command
     */
    Db.prototype.renameCollection = function (fromCollection, toCollection, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, __assign(__assign({}, options), { new_collection: true, readPreference: read_preference_1.ReadPreference.primary })))];
                    case 1: 
                    // Intentionally, we do not inherit options from parent for this operation.
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
     *
     * @param name - Name of collection to drop
     * @param options - Optional settings for the command
     */
    Db.prototype.dropCollection = function (name, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new drop_1.DropCollectionOperation(this, name, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Drop a database, removing it permanently from the server.
     *
     * @param options - Optional settings for the command
     */
    Db.prototype.dropDatabase = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new drop_1.DropDatabaseOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Fetch all collections for the current db.
     *
     * @param options - Optional settings for the command
     */
    Db.prototype.collections = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new collections_1.CollectionsOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Creates an index on the db and collection.
     *
     * @param name - Name of the collection to create the index on.
     * @param indexSpec - Specify the field to index, or an index specification
     * @param options - Optional settings for the command
     */
    Db.prototype.createIndex = function (name, indexSpec, options) {
        return __awaiter(this, void 0, Promise, function () {
            var indexes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, name, indexSpec, options))];
                    case 1:
                        indexes = _a.sent();
                        return [2 /*return*/, indexes[0]];
                }
            });
        });
    };
    /**
     * Remove a user from a database
     *
     * @param username - The username to remove
     * @param options - Optional settings for the command
     */
    Db.prototype.removeUser = function (username, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new remove_user_1.RemoveUserOperation(this, username, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Set the current profiling level of MongoDB
     *
     * @param level - The new profiling level (off, slow_only, all).
     * @param options - Optional settings for the command
     */
    Db.prototype.setProfilingLevel = function (level, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Retrieve the current profiling Level for MongoDB
     *
     * @param options - Optional settings for the command
     */
    Db.prototype.profilingLevel = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new profiling_level_1.ProfilingLevelOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Db.prototype.indexInformation = function (name, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.collection(name).indexInformation(utils_1.resolveOptions(this, options))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this database. Will ignore all
     * changes to system collections.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct use cases:
     * - The first is to provide the schema that may be defined for all the collections within this database
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TSchema - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */
    Db.prototype.watch = function (pipeline, options) {
        if (pipeline === void 0) { pipeline = []; }
        if (options === void 0) { options = {}; }
        // Allow optionally not specifying a pipeline
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));
    };
    /**
     * A low level cursor API providing basic driver functionality:
     * - ClientSession management
     * - ReadPreference for server selection
     * - Running getMores automatically when a local batch is exhausted
     *
     * @param command - The command that will start a cursor on the server.
     * @param options - Configurations for running the command, bson options will apply to getMores
     */
    Db.prototype.runCursorCommand = function (command, options) {
        return new run_command_cursor_1.RunCommandCursor(this, command, options);
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    return Db;
}());
exports.Db = Db;
