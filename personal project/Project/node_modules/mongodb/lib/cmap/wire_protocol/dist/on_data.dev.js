"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onData = onData;

var utils_1 = require("../../utils");
/**
 * onData is adapted from Node.js' events.on helper
 * https://nodejs.org/api/events.html#eventsonemitter-eventname-options
 *
 * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.
 * It will reject upon an error event.
 */


function onData(emitter) {
  // Setup pending events and pending promise lists

  /**
   * When the caller has not yet called .next(), we store the
   * value from the event in this list. Next time they call .next()
   * we pull the first value out of this list and resolve a promise with it.
   */
  var unconsumedEvents = new utils_1.List();
  /**
   * When there has not yet been an event, a new promise will be created
   * and implicitly stored in this list. When an event occurs we take the first
   * promise in this list and resolve it.
   */

  var unconsumedPromises = new utils_1.List();
  /**
   * Stored an error created by an error event.
   * This error will turn into a rejection for the subsequent .next() call
   */

  var error = null;
  /** Set to true only after event listeners have been removed. */

  var finished = false;

  var iterator = _defineProperty({
    next: function next() {
      // First, we consume all unread events
      var value = unconsumedEvents.shift();

      if (value != null) {
        return Promise.resolve({
          value: value,
          done: false
        });
      } // Then we error, if an error happened
      // This happens one time if at all, because after 'error'
      // we stop listening


      if (error != null) {
        var p = Promise.reject(error); // Only the first element errors

        error = null;
        return p;
      } // If the iterator is finished, resolve to done


      if (finished) return closeHandler(); // Wait until an event happens

      var _ref = (0, utils_1.promiseWithResolvers)(),
          promise = _ref.promise,
          resolve = _ref.resolve,
          reject = _ref.reject;

      unconsumedPromises.push({
        resolve: resolve,
        reject: reject
      });
      return promise;
    },
    "return": function _return() {
      return closeHandler();
    },
    "throw": function _throw(err) {
      errorHandler(err);
      return Promise.resolve({
        value: undefined,
        done: true
      });
    }
  }, Symbol.asyncIterator, function () {
    return this;
  }); // Adding event handlers


  emitter.on('data', eventHandler);
  emitter.on('error', errorHandler);
  return iterator;

  function eventHandler(value) {
    var promise = unconsumedPromises.shift();
    if (promise != null) promise.resolve({
      value: value,
      done: false
    });else unconsumedEvents.push(value);
  }

  function errorHandler(err) {
    var promise = unconsumedPromises.shift();
    if (promise != null) promise.reject(err);else error = err;
    void closeHandler();
  }

  function closeHandler() {
    // Adding event handlers
    emitter.off('data', eventHandler);
    emitter.off('error', errorHandler);
    finished = true;
    var doneResult = {
      value: undefined,
      done: finished
    };
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator2 = unconsumedPromises[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator2.next()).done); _iteratorNormalCompletion = true) {
        var promise = _step.value;
        promise.resolve(doneResult);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return Promise.resolve(doneResult);
  }
}