"use strict";
exports.__esModule = true;
exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;
var constants_1 = require("../constants");
var utils_1 = require("../utils");
var commands_1 = require("./commands");
/**
 * An event indicating the start of a given command
 * @public
 * @category Event
 */
var CommandStartedEvent = /** @class */ (function () {
    /**
     * Create a started event
     *
     * @internal
     * @param pool - the pool that originated the command
     * @param command - the command
     */
    function CommandStartedEvent(connection, command, serverConnectionId) {
        /** @internal */
        this.name = constants_1.COMMAND_STARTED;
        var cmd = extractCommand(command);
        var commandName = extractCommandName(cmd);
        var _a = extractConnectionDetails(connection), address = _a.address, connectionId = _a.connectionId, serviceId = _a.serviceId;
        // TODO: remove in major revision, this is not spec behavior
        if (exports.SENSITIVE_COMMANDS.has(commandName)) {
            this.commandObj = {};
            this.commandObj[commandName] = true;
        }
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.databaseName = command.databaseName;
        this.commandName = commandName;
        this.command = maybeRedact(commandName, cmd, cmd);
        this.serverConnectionId = serverConnectionId;
    }
    Object.defineProperty(CommandStartedEvent.prototype, "hasServiceId", {
        /* @internal */
        get: function () {
            return !!this.serviceId;
        },
        enumerable: false,
        configurable: true
    });
    return CommandStartedEvent;
}());
exports.CommandStartedEvent = CommandStartedEvent;
/**
 * An event indicating the success of a given command
 * @public
 * @category Event
 */
var CommandSucceededEvent = /** @class */ (function () {
    /**
     * Create a succeeded event
     *
     * @internal
     * @param pool - the pool that originated the command
     * @param command - the command
     * @param reply - the reply for this command from the server
     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
     */
    function CommandSucceededEvent(connection, command, reply, started, serverConnectionId) {
        /** @internal */
        this.name = constants_1.COMMAND_SUCCEEDED;
        var cmd = extractCommand(command);
        var commandName = extractCommandName(cmd);
        var _a = extractConnectionDetails(connection), address = _a.address, connectionId = _a.connectionId, serviceId = _a.serviceId;
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = utils_1.calculateDurationInMs(started);
        this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
        this.serverConnectionId = serverConnectionId;
    }
    Object.defineProperty(CommandSucceededEvent.prototype, "hasServiceId", {
        /* @internal */
        get: function () {
            return !!this.serviceId;
        },
        enumerable: false,
        configurable: true
    });
    return CommandSucceededEvent;
}());
exports.CommandSucceededEvent = CommandSucceededEvent;
/**
 * An event indicating the failure of a given command
 * @public
 * @category Event
 */
var CommandFailedEvent = /** @class */ (function () {
    /**
     * Create a failure event
     *
     * @internal
     * @param pool - the pool that originated the command
     * @param command - the command
     * @param error - the generated error or a server error response
     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
     */
    function CommandFailedEvent(connection, command, error, started, serverConnectionId) {
        /** @internal */
        this.name = constants_1.COMMAND_FAILED;
        var cmd = extractCommand(command);
        var commandName = extractCommandName(cmd);
        var _a = extractConnectionDetails(connection), address = _a.address, connectionId = _a.connectionId, serviceId = _a.serviceId;
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = utils_1.calculateDurationInMs(started);
        this.failure = maybeRedact(commandName, cmd, error);
        this.serverConnectionId = serverConnectionId;
    }
    Object.defineProperty(CommandFailedEvent.prototype, "hasServiceId", {
        /* @internal */
        get: function () {
            return !!this.serviceId;
        },
        enumerable: false,
        configurable: true
    });
    return CommandFailedEvent;
}());
exports.CommandFailedEvent = CommandFailedEvent;
/**
 * Commands that we want to redact because of the sensitive nature of their contents
 * @internal
 */
exports.SENSITIVE_COMMANDS = new Set([
    'authenticate',
    'saslStart',
    'saslContinue',
    'getnonce',
    'createUser',
    'updateUser',
    'copydbgetnonce',
    'copydbsaslstart',
    'copydb'
]);
var HELLO_COMMANDS = new Set(['hello', constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
// helper methods
var extractCommandName = function (commandDoc) { return Object.keys(commandDoc)[0]; };
var namespace = function (command) { return command.ns; };
var collectionName = function (command) { return command.ns.split('.')[1]; };
var maybeRedact = function (commandName, commandDoc, result) {
    return exports.SENSITIVE_COMMANDS.has(commandName) ||
        (HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate)
        ? {}
        : result;
};
var LEGACY_FIND_QUERY_MAP = {
    $query: 'filter',
    $orderby: 'sort',
    $hint: 'hint',
    $comment: 'comment',
    $maxScan: 'maxScan',
    $max: 'max',
    $min: 'min',
    $returnKey: 'returnKey',
    $showDiskLoc: 'showRecordId',
    $maxTimeMS: 'maxTimeMS',
    $snapshot: 'snapshot'
};
var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: 'skip',
    numberToReturn: 'batchSize',
    returnFieldSelector: 'projection'
};
var OP_QUERY_KEYS = [
    'tailable',
    'oplogReplay',
    'noCursorTimeout',
    'awaitData',
    'partial',
    'exhaust'
];
/** Extract the actual command from the query, possibly up-converting if it's a legacy format */
function extractCommand(command) {
    var _a;
    if (command instanceof commands_1.OpMsgRequest) {
        var cmd = utils_1.deepCopy(command.command);
        // For OP_MSG with payload type 1 we need to pull the documents
        // array out of the document sequence for monitoring.
        if (cmd.ops instanceof commands_1.DocumentSequence) {
            cmd.ops = cmd.ops.documents;
        }
        if (cmd.nsInfo instanceof commands_1.DocumentSequence) {
            cmd.nsInfo = cmd.nsInfo.documents;
        }
        return cmd;
    }
    if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {
        var result_1;
        if (command.ns === 'admin.$cmd') {
            // up-convert legacy command
            result_1 = Object.assign({}, command.query.$query);
        }
        else {
            // up-convert legacy find command
            result_1 = { find: collectionName(command) };
            Object.keys(LEGACY_FIND_QUERY_MAP).forEach(function (key) {
                if (command.query[key] != null) {
                    result_1[LEGACY_FIND_QUERY_MAP[key]] = utils_1.deepCopy(command.query[key]);
                }
            });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(function (key) {
            var legacyKey = key;
            if (command[legacyKey] != null) {
                result_1[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = utils_1.deepCopy(command[legacyKey]);
            }
        });
        OP_QUERY_KEYS.forEach(function (key) {
            if (command[key]) {
                result_1[key] = command[key];
            }
        });
        if (command.pre32Limit != null) {
            result_1.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
            return { explain: result_1 };
        }
        return result_1;
    }
    var clonedQuery = {};
    var clonedCommand = {};
    if (command.query) {
        for (var k in command.query) {
            clonedQuery[k] = utils_1.deepCopy(command.query[k]);
        }
        clonedCommand.query = clonedQuery;
    }
    for (var k in command) {
        if (k === 'query')
            continue;
        clonedCommand[k] = utils_1.deepCopy(command[k]);
    }
    return command.query ? clonedQuery : clonedCommand;
}
function extractReply(command, reply) {
    if (!reply) {
        return reply;
    }
    if (command instanceof commands_1.OpMsgRequest) {
        return utils_1.deepCopy(reply.result ? reply.result : reply);
    }
    // is this a legacy find command?
    if (command.query && command.query.$query != null) {
        return {
            ok: 1,
            cursor: {
                id: utils_1.deepCopy(reply.cursorId),
                ns: namespace(command),
                firstBatch: utils_1.deepCopy(reply.documents)
            }
        };
    }
    return utils_1.deepCopy(reply.result ? reply.result : reply);
}
function extractConnectionDetails(connection) {
    var connectionId;
    if ('id' in connection) {
        connectionId = connection.id;
    }
    return {
        address: connection.address,
        serviceId: connection.serviceId,
        connectionId: connectionId
    };
}
