"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
exports.__esModule = true;
exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;
var stream_1 = require("stream");
var bson_1 = require("../bson");
var error_1 = require("../error");
var mongo_types_1 = require("../mongo_types");
var execute_operation_1 = require("../operations/execute_operation");
var get_more_1 = require("../operations/get_more");
var kill_cursors_1 = require("../operations/kill_cursors");
var read_concern_1 = require("../read_concern");
var read_preference_1 = require("../read_preference");
var resource_management_1 = require("../resource_management");
var sessions_1 = require("../sessions");
var utils_1 = require("../utils");
/** @public */
exports.CURSOR_FLAGS = [
    'tailable',
    'oplogReplay',
    'noCursorTimeout',
    'awaitData',
    'exhaust',
    'partial'
];
/** @public */
var AbstractCursor = /** @class */ (function (_super) {
    __extends(AbstractCursor, _super);
    /** @internal */
    function AbstractCursor(client, namespace, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        /** @internal */
        _this.documents = null;
        /** @internal */
        _this.hasEmittedClose = false;
        if (!client.s.isMongoClient) {
            throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');
        }
        _this.cursorClient = client;
        _this.cursorNamespace = namespace;
        _this.cursorId = null;
        _this.initialized = false;
        _this.isClosed = false;
        _this.isKilled = false;
        _this.cursorOptions = __assign({ readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference
                ? options.readPreference
                : read_preference_1.ReadPreference.primary }, bson_1.pluckBSONSerializeOptions(options));
        _this.cursorOptions.timeoutMS = options.timeoutMS;
        var readConcern = read_concern_1.ReadConcern.fromOptions(options);
        if (readConcern) {
            _this.cursorOptions.readConcern = readConcern;
        }
        if (typeof options.batchSize === 'number') {
            _this.cursorOptions.batchSize = options.batchSize;
        }
        // we check for undefined specifically here to allow falsy values
        // eslint-disable-next-line no-restricted-syntax
        if (options.comment !== undefined) {
            _this.cursorOptions.comment = options.comment;
        }
        if (typeof options.maxTimeMS === 'number') {
            _this.cursorOptions.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.maxAwaitTimeMS === 'number') {
            _this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;
        }
        if (options.session instanceof sessions_1.ClientSession) {
            _this.cursorSession = options.session;
        }
        else {
            _this.cursorSession = _this.cursorClient.startSession({ owner: _this, explicit: false });
        }
        _this.deserializationOptions = __assign(__assign({}, _this.cursorOptions), { validation: {
                utf8: (options === null || options === void 0 ? void 0 : options.enableUtf8Validation) === false ? false : true
            } });
        return _this;
    }
    Object.defineProperty(AbstractCursor.prototype, "id", {
        /**
         * The cursor has no id until it receives a response from the initial cursor creating command.
         *
         * It is non-zero for as long as the database has an open cursor.
         *
         * The initiating command may receive a zero id if the entire result is in the `firstBatch`.
         */
        get: function () {
            var _a;
            return (_a = this.cursorId) !== null && _a !== void 0 ? _a : undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "isDead", {
        /** @internal */
        get: function () {
            var _a, _b;
            return ((_b = (_a = this.cursorId) === null || _a === void 0 ? void 0 : _a.isZero()) !== null && _b !== void 0 ? _b : false) || this.isClosed || this.isKilled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "client", {
        /** @internal */
        get: function () {
            return this.cursorClient;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "server", {
        /** @internal */
        get: function () {
            return this.selectedServer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "namespace", {
        get: function () {
            return this.cursorNamespace;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "readPreference", {
        get: function () {
            return this.cursorOptions.readPreference;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "readConcern", {
        get: function () {
            return this.cursorOptions.readConcern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "session", {
        /** @internal */
        get: function () {
            return this.cursorSession;
        },
        set: function (clientSession) {
            this.cursorSession = clientSession;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "closed", {
        /**
         * The cursor is closed and all remaining locally buffered documents have been iterated.
         */
        get: function () {
            var _a, _b;
            return this.isClosed && ((_b = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "killed", {
        /**
         * A `killCursors` command was attempted on this cursor.
         * This is performed if the cursor id is non zero.
         */
        get: function () {
            return this.isKilled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractCursor.prototype, "loadBalanced", {
        get: function () {
            var _a;
            return !!((_a = this.cursorClient.topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);
        },
        enumerable: false,
        configurable: true
    });
    /** @internal */
    AbstractCursor.prototype.asyncDispose = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.close()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Returns current buffered documents length */
    AbstractCursor.prototype.bufferedCount = function () {
        var _a, _b;
        return (_b = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    };
    /** Returns current buffered documents */
    AbstractCursor.prototype.readBufferedDocuments = function (number) {
        var _a, _b, _c, _d, _e;
        var bufferedDocs = [];
        var documentsToRead = Math.min((_b = number !== null && number !== void 0 ? number : (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this.documents) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0);
        for (var count = 0; count < documentsToRead; count++) {
            var document = (_e = this.documents) === null || _e === void 0 ? void 0 : _e.shift(this.deserializationOptions);
            if (document != null) {
                bufferedDocs.push(document);
            }
        }
        return bufferedDocs;
    };
    AbstractCursor.prototype[Symbol.asyncIterator] = function () {
        var _a, _b;
        return __asyncGenerator(this, arguments, function _c() {
            var document, error_2;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!this.closed) return [3 /*break*/, 2];
                        return [4 /*yield*/, __await(void 0)];
                    case 1: return [2 /*return*/, _d.sent()];
                    case 2:
                        _d.trys.push([2, , 16, 21]);
                        _d.label = 3;
                    case 3:
                        if (!true) return [3 /*break*/, 15];
                        if (!this.isKilled) return [3 /*break*/, 5];
                        return [4 /*yield*/, __await(void 0)];
                    case 4: return [2 /*return*/, _d.sent()];
                    case 5:
                        if (!this.closed) return [3 /*break*/, 7];
                        return [4 /*yield*/, __await(void 0)];
                    case 6: return [2 /*return*/, _d.sent()];
                    case 7:
                        if (!(this.cursorId != null && this.isDead && ((_b = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0)) return [3 /*break*/, 9];
                        return [4 /*yield*/, __await(void 0)];
                    case 8: return [2 /*return*/, _d.sent()];
                    case 9: return [4 /*yield*/, __await(this.next())];
                    case 10:
                        document = _d.sent();
                        if (!(document === null)) return [3 /*break*/, 12];
                        return [4 /*yield*/, __await(void 0)];
                    case 11: return [2 /*return*/, _d.sent()];
                    case 12: return [4 /*yield*/, __await(document)];
                    case 13: return [4 /*yield*/, _d.sent()];
                    case 14:
                        _d.sent();
                        return [3 /*break*/, 3];
                    case 15: return [3 /*break*/, 21];
                    case 16:
                        if (!!this.isClosed) return [3 /*break*/, 20];
                        _d.label = 17;
                    case 17:
                        _d.trys.push([17, 19, , 20]);
                        return [4 /*yield*/, __await(this.close())];
                    case 18:
                        _d.sent();
                        return [3 /*break*/, 20];
                    case 19:
                        error_2 = _d.sent();
                        utils_1.squashError(error_2);
                        return [3 /*break*/, 20];
                    case 20: return [7 /*endfinally*/];
                    case 21: return [2 /*return*/];
                }
            });
        });
    };
    AbstractCursor.prototype.stream = function (options) {
        if (options === null || options === void 0 ? void 0 : options.transform) {
            var transform_1 = options.transform;
            var readable = new ReadableCursorStream(this);
            var transformedStream_1 = readable.pipe(new stream_1.Transform({
                objectMode: true,
                highWaterMark: 1,
                transform: function (chunk, _, callback) {
                    try {
                        var transformed = transform_1(chunk);
                        callback(undefined, transformed);
                    }
                    catch (err) {
                        callback(err);
                    }
                }
            }));
            // Bubble errors to transformed stream, because otherwise no way
            // to handle this error.
            readable.on('error', function (err) { return transformedStream_1.emit('error', err); });
            return transformedStream_1;
        }
        return new ReadableCursorStream(this);
    };
    AbstractCursor.prototype.hasNext = function () {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (this.cursorId === bson_1.Long.ZERO) {
                            return [2 /*return*/, false];
                        }
                        _e.label = 1;
                    case 1:
                        if (((_b = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) !== 0) {
                            return [2 /*return*/, true];
                        }
                        return [4 /*yield*/, this.fetchBatch()];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        if (!this.isDead || ((_d = (_c = this.documents) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) !== 0) return [3 /*break*/, 1];
                        _e.label = 4;
                    case 4: return [2 /*return*/, false];
                }
            });
        });
    };
    /** Get the next available document from the cursor, returns null if no more documents are available. */
    AbstractCursor.prototype.next = function () {
        var _a, _b, _c;
        return __awaiter(this, void 0, Promise, function () {
            var doc;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (this.cursorId === bson_1.Long.ZERO) {
                            throw new error_1.MongoCursorExhaustedError();
                        }
                        _d.label = 1;
                    case 1:
                        doc = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.shift(this.deserializationOptions);
                        if (!(doc != null)) return [3 /*break*/, 4];
                        if (!(this.transform != null)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.transformDocument(doc)];
                    case 2: return [2 /*return*/, _d.sent()];
                    case 3: return [2 /*return*/, doc];
                    case 4: return [4 /*yield*/, this.fetchBatch()];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6:
                        if (!this.isDead || ((_c = (_b = this.documents) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) !== 0) return [3 /*break*/, 1];
                        _d.label = 7;
                    case 7: return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * Try to get the next available document from the cursor or `null` if an empty batch is returned
     */
    AbstractCursor.prototype.tryNext = function () {
        var _a, _b;
        return __awaiter(this, void 0, Promise, function () {
            var doc;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.cursorId === bson_1.Long.ZERO) {
                            throw new error_1.MongoCursorExhaustedError();
                        }
                        doc = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.shift(this.deserializationOptions);
                        if (!(doc != null)) return [3 /*break*/, 3];
                        if (!(this.transform != null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.transformDocument(doc)];
                    case 1: return [2 /*return*/, _c.sent()];
                    case 2: return [2 /*return*/, doc];
                    case 3: return [4 /*yield*/, this.fetchBatch()];
                    case 4:
                        _c.sent();
                        doc = (_b = this.documents) === null || _b === void 0 ? void 0 : _b.shift(this.deserializationOptions);
                        if (!(doc != null)) return [3 /*break*/, 7];
                        if (!(this.transform != null)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.transformDocument(doc)];
                    case 5: return [2 /*return*/, _c.sent()];
                    case 6: return [2 /*return*/, doc];
                    case 7: return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * Iterates over all the documents for this cursor using the iterator, callback pattern.
     *
     * If the iterator returns `false`, iteration will stop.
     *
     * @param iterator - The iteration callback.
     * @deprecated - Will be removed in a future release. Use for await...of instead.
     */
    AbstractCursor.prototype.forEach = function (iterator) {
        var e_1, _a;
        return __awaiter(this, void 0, Promise, function () {
            var _b, _c, document, result, e_1_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (typeof iterator !== 'function') {
                            throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
                        }
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = __asyncValues(this);
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        document = _c.value;
                        result = iterator(document);
                        if (result === false) {
                            return [3 /*break*/, 5];
                        }
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b["return"]))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Frees any client-side resources used by the cursor.
     */
    AbstractCursor.prototype.close = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cleanup()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an array of documents. The caller is responsible for making sure that there
     * is enough memory to store the results. Note that the array only contains partial
     * results when this cursor had been previously accessed. In that case,
     * cursor.rewind() can be used to reset the cursor.
     */
    AbstractCursor.prototype.toArray = function () {
        var e_2, _a;
        return __awaiter(this, void 0, Promise, function () {
            var array, _b, _c, document, docs, _i, docs_1, doc, _d, _e, e_2_1;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        array = [];
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 11, 12, 17]);
                        _b = __asyncValues(this);
                        _f.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 10];
                        document = _c.value;
                        array.push(document);
                        docs = this.readBufferedDocuments();
                        if (!(this.transform != null)) return [3 /*break*/, 8];
                        _i = 0, docs_1 = docs;
                        _f.label = 4;
                    case 4:
                        if (!(_i < docs_1.length)) return [3 /*break*/, 7];
                        doc = docs_1[_i];
                        _e = (_d = array).push;
                        return [4 /*yield*/, this.transformDocument(doc)];
                    case 5:
                        _e.apply(_d, [_f.sent()]);
                        _f.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        array.push.apply(array, docs);
                        _f.label = 9;
                    case 9: return [3 /*break*/, 2];
                    case 10: return [3 /*break*/, 17];
                    case 11:
                        e_2_1 = _f.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 17];
                    case 12:
                        _f.trys.push([12, , 15, 16]);
                        if (!(_c && !_c.done && (_a = _b["return"]))) return [3 /*break*/, 14];
                        return [4 /*yield*/, _a.call(_b)];
                    case 13:
                        _f.sent();
                        _f.label = 14;
                    case 14: return [3 /*break*/, 16];
                    case 15:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 16: return [7 /*endfinally*/];
                    case 17: return [2 /*return*/, array];
                }
            });
        });
    };
    /**
     * Add a cursor flag to the cursor
     *
     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
     * @param value - The flag boolean value.
     */
    AbstractCursor.prototype.addCursorFlag = function (flag, value) {
        this.throwIfInitialized();
        if (!exports.CURSOR_FLAGS.includes(flag)) {
            throw new error_1.MongoInvalidArgumentError("Flag " + flag + " is not one of " + exports.CURSOR_FLAGS);
        }
        if (typeof value !== 'boolean') {
            throw new error_1.MongoInvalidArgumentError("Flag " + flag + " must be a boolean value");
        }
        this.cursorOptions[flag] = value;
        return this;
    };
    /**
     * Map all documents using the provided function
     * If there is a transform set on the cursor, that will be called first and the result passed to
     * this function's transform.
     *
     * @remarks
     *
     * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping
     * function that maps values to `null` will result in the cursor closing itself before it has finished iterating
     * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:
     *
     * ```typescript
     * const cursor = collection.find({});
     * cursor.map(() => null);
     *
     * const documents = await cursor.toArray();
     * // documents is always [], regardless of how many documents are in the collection.
     * ```
     *
     * Other falsey values are allowed:
     *
     * ```typescript
     * const cursor = collection.find({});
     * cursor.map(() => '');
     *
     * const documents = await cursor.toArray();
     * // documents is now an array of empty strings
     * ```
     *
     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling map,
     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
     * Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: FindCursor<Document> = coll.find();
     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
     * ```
     * @param transform - The mapping transformation method.
     */
    AbstractCursor.prototype.map = function (transform) {
        this.throwIfInitialized();
        var oldTransform = this.transform;
        if (oldTransform) {
            this.transform = function (doc) {
                return transform(oldTransform(doc));
            };
        }
        else {
            this.transform = transform;
        }
        return this;
    };
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */
    AbstractCursor.prototype.withReadPreference = function (readPreference) {
        this.throwIfInitialized();
        if (readPreference instanceof read_preference_1.ReadPreference) {
            this.cursorOptions.readPreference = readPreference;
        }
        else if (typeof readPreference === 'string') {
            this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);
        }
        else {
            throw new error_1.MongoInvalidArgumentError("Invalid read preference: " + readPreference);
        }
        return this;
    };
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */
    AbstractCursor.prototype.withReadConcern = function (readConcern) {
        this.throwIfInitialized();
        var resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern: readConcern });
        if (resolvedReadConcern) {
            this.cursorOptions.readConcern = resolvedReadConcern;
        }
        return this;
    };
    /**
     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
     *
     * @param value - Number of milliseconds to wait before aborting the query.
     */
    AbstractCursor.prototype.maxTimeMS = function (value) {
        this.throwIfInitialized();
        if (typeof value !== 'number') {
            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
        }
        this.cursorOptions.maxTimeMS = value;
        return this;
    };
    /**
     * Set the batch size for the cursor.
     *
     * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.
     */
    AbstractCursor.prototype.batchSize = function (value) {
        this.throwIfInitialized();
        if (this.cursorOptions.tailable) {
            throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');
        }
        if (typeof value !== 'number') {
            throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
        }
        this.cursorOptions.batchSize = value;
        return this;
    };
    /**
     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
     * if the resultant data has already been retrieved by this cursor.
     */
    AbstractCursor.prototype.rewind = function () {
        var _a;
        if (!this.initialized) {
            return;
        }
        this.cursorId = null;
        (_a = this.documents) === null || _a === void 0 ? void 0 : _a.clear();
        this.isClosed = false;
        this.isKilled = false;
        this.initialized = false;
        var session = this.cursorSession;
        if (session) {
            // We only want to end this session if we created it, and it hasn't ended yet
            if (session.explicit === false) {
                if (!session.hasEnded) {
                    session.endSession().then(undefined, utils_1.squashError);
                }
                this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
            }
        }
    };
    /** @internal */
    AbstractCursor.prototype.getMore = function (batchSize) {
        return __awaiter(this, void 0, Promise, function () {
            var getMoreOperation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.cursorId == null) {
                            throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');
                        }
                        if (this.selectedServer == null) {
                            throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');
                        }
                        getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, __assign(__assign({}, this.cursorOptions), { session: this.cursorSession, batchSize: batchSize }));
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.cursorClient, getMoreOperation)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * @internal
     *
     * This function is exposed for the unified test runner's createChangeStream
     * operation.  We cannot refactor to use the abstract _initialize method without
     * a significant refactor.
     */
    AbstractCursor.prototype.cursorInit = function () {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var state, response, error_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 4]);
                        return [4 /*yield*/, this._initialize(this.cursorSession)];
                    case 1:
                        state = _b.sent();
                        response = state.response;
                        this.selectedServer = state.server;
                        this.cursorId = response.id;
                        this.cursorNamespace = (_a = response.ns) !== null && _a !== void 0 ? _a : this.namespace;
                        this.documents = response;
                        this.initialized = true; // the cursor is now initialized, even if it is dead
                        return [3 /*break*/, 4];
                    case 2:
                        error_3 = _b.sent();
                        // the cursor is now initialized, even if an error occurred
                        this.initialized = true;
                        return [4 /*yield*/, this.cleanup(error_3)];
                    case 3:
                        _b.sent();
                        throw error_3;
                    case 4:
                        if (!this.isDead) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.cleanup()];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /** @internal Attempt to obtain more documents */
    AbstractCursor.prototype.fetchBatch = function () {
        var _a, _b;
        return __awaiter(this, void 0, Promise, function () {
            var batchSize, response, error_4, error_5;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.isClosed) {
                            return [2 /*return*/];
                        }
                        if (!this.isDead) return [3 /*break*/, 2];
                        // if the cursor is dead, we clean it up
                        // cleanupCursor should never throw, but if it does it indicates a bug in the driver
                        // and we should surface the error
                        return [4 /*yield*/, this.cleanup()];
                    case 1:
                        // if the cursor is dead, we clean it up
                        // cleanupCursor should never throw, but if it does it indicates a bug in the driver
                        // and we should surface the error
                        _c.sent();
                        return [2 /*return*/];
                    case 2:
                        if (!(this.cursorId == null)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.cursorInit()];
                    case 3:
                        _c.sent();
                        // If the cursor died or returned documents, return
                        if (((_b = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) !== 0 || this.isDead)
                            return [2 /*return*/];
                        _c.label = 4;
                    case 4:
                        batchSize = this.cursorOptions.batchSize || 1000;
                        _c.label = 5;
                    case 5:
                        _c.trys.push([5, 7, , 12]);
                        return [4 /*yield*/, this.getMore(batchSize)];
                    case 6:
                        response = _c.sent();
                        this.cursorId = response.id;
                        this.documents = response;
                        return [3 /*break*/, 12];
                    case 7:
                        error_4 = _c.sent();
                        _c.label = 8;
                    case 8:
                        _c.trys.push([8, 10, , 11]);
                        return [4 /*yield*/, this.cleanup(error_4)];
                    case 9:
                        _c.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        error_5 = _c.sent();
                        // `cleanupCursor` should never throw, squash and throw the original error
                        utils_1.squashError(error_5);
                        return [3 /*break*/, 11];
                    case 11: throw error_4;
                    case 12:
                        if (!this.isDead) return [3 /*break*/, 14];
                        // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,
                        // we intentionally clean up the cursor to release its session back into the pool before the cursor
                        // is iterated.  This prevents a cursor that is exhausted on the server from holding
                        // onto a session indefinitely until the AbstractCursor is iterated.
                        //
                        // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver
                        // and we should surface the error
                        return [4 /*yield*/, this.cleanup()];
                    case 13:
                        // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,
                        // we intentionally clean up the cursor to release its session back into the pool before the cursor
                        // is iterated.  This prevents a cursor that is exhausted on the server from holding
                        // onto a session indefinitely until the AbstractCursor is iterated.
                        //
                        // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver
                        // and we should surface the error
                        _c.sent();
                        _c.label = 14;
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /** @internal */
    AbstractCursor.prototype.cleanup = function (error) {
        return __awaiter(this, void 0, void 0, function () {
            var session, cursorId, error_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.isClosed = true;
                        session = this.cursorSession;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, 5, 8]);
                        if (!(!this.isKilled &&
                            this.cursorId &&
                            !this.cursorId.isZero() &&
                            this.cursorNamespace &&
                            this.selectedServer &&
                            !session.hasEnded)) return [3 /*break*/, 3];
                        this.isKilled = true;
                        cursorId = this.cursorId;
                        this.cursorId = bson_1.Long.ZERO;
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {
                                session: session
                            }))];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [3 /*break*/, 8];
                    case 4:
                        error_6 = _a.sent();
                        utils_1.squashError(error_6);
                        return [3 /*break*/, 8];
                    case 5:
                        if (!((session === null || session === void 0 ? void 0 : session.owner) === this)) return [3 /*break*/, 7];
                        return [4 /*yield*/, session.endSession({ error: error })];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {
                            sessions_1.maybeClearPinnedConnection(session, { error: error });
                        }
                        this.emitClose();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /** @internal */
    AbstractCursor.prototype.emitClose = function () {
        var _a, _b;
        try {
            if (!this.hasEmittedClose && (((_b = (_a = this.documents) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0 || this.isClosed)) {
                // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents["close"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.
                this.emit('close');
            }
        }
        finally {
            this.hasEmittedClose = true;
        }
    };
    /** @internal */
    AbstractCursor.prototype.transformDocument = function (document) {
        return __awaiter(this, void 0, Promise, function () {
            var transformedDocument, TRANSFORM_TO_NULL_ERROR, transformError_1, closeError_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.transform == null)
                            return [2 /*return*/, document];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 2, , 7]);
                        transformedDocument = this.transform(document);
                        // eslint-disable-next-line no-restricted-syntax
                        if (transformedDocument === null) {
                            TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';
                            throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);
                        }
                        return [2 /*return*/, transformedDocument];
                    case 2:
                        transformError_1 = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.close()];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        closeError_1 = _a.sent();
                        utils_1.squashError(closeError_1);
                        return [3 /*break*/, 6];
                    case 6: throw transformError_1;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /** @internal */
    AbstractCursor.prototype.throwIfInitialized = function () {
        if (this.initialized)
            throw new error_1.MongoCursorInUseError();
    };
    /** @event */
    AbstractCursor.CLOSE = 'close';
    return AbstractCursor;
}(mongo_types_1.TypedEventEmitter));
exports.AbstractCursor = AbstractCursor;
var ReadableCursorStream = /** @class */ (function (_super) {
    __extends(ReadableCursorStream, _super);
    function ReadableCursorStream(cursor) {
        var _this = _super.call(this, {
            objectMode: true,
            autoDestroy: false,
            highWaterMark: 1
        }) || this;
        _this._readInProgress = false;
        _this._cursor = cursor;
        return _this;
    }
    ReadableCursorStream.prototype._read = function (size) {
        if (!this._readInProgress) {
            this._readInProgress = true;
            this._readNext();
        }
    };
    ReadableCursorStream.prototype._destroy = function (error, callback) {
        this._cursor.close().then(function () { return callback(error); }, function (closeError) { return callback(closeError); });
    };
    ReadableCursorStream.prototype._readNext = function () {
        var _this = this;
        if (this._cursor.id === bson_1.Long.ZERO) {
            this.push(null);
            return;
        }
        this._cursor.next().then(function (result) {
            if (result == null) {
                _this.push(null);
            }
            else if (_this.destroyed) {
                _this._cursor.close().then(undefined, utils_1.squashError);
            }
            else {
                if (_this.push(result)) {
                    return _this._readNext();
                }
                _this._readInProgress = false;
            }
        }, function (err) {
            // NOTE: This is questionable, but we have a test backing the behavior. It seems the
            //       desired behavior is that a stream ends cleanly when a user explicitly closes
            //       a client during iteration. Alternatively, we could do the "right" thing and
            //       propagate the error message by removing this special case.
            if (err.message.match(/server is closed/)) {
                _this._cursor.close().then(undefined, utils_1.squashError);
                return _this.push(null);
            }
            // NOTE: This is also perhaps questionable. The rationale here is that these errors tend
            //       to be "operation was interrupted", where a cursor has been closed but there is an
            //       active getMore in-flight. This used to check if the cursor was killed but once
            //       that changed to happen in cleanup legitimate errors would not destroy the
            //       stream. There are change streams test specifically test these cases.
            if (err.message.match(/operation was interrupted/)) {
                return _this.push(null);
            }
            // NOTE: The two above checks on the message of the error will cause a null to be pushed
            //       to the stream, thus closing the stream before the destroy call happens. This means
            //       that either of those error messages on a change stream will not get a proper
            //       'error' event to be emitted (the error passed to destroy). Change stream resumability
            //       relies on that error event to be emitted to create its new cursor and thus was not
            //       working on 4.4 servers because the error emitted on failover was "interrupted at
            //       shutdown" while on 5.0+ it is "The server is in quiesce mode and will shut down".
            //       See NODE-4475.
            return _this.destroy(err);
        });
    };
    return ReadableCursorStream;
}(stream_1.Readable));
resource_management_1.configureResourceManagement(AbstractCursor.prototype);
