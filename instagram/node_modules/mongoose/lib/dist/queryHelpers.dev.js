'use strict';
/*!
 * Module dependencies
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');

var get = require('./helpers/get');

var getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');

var isDefiningProjection = require('./helpers/projection/isDefiningProjection');

var clone = require('./helpers/clone');

var isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');
/**
 * Prepare a set of path options for query population.
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */


exports.preparePopulationOptions = function preparePopulationOptions(query, options) {
  var _populate = query.options.populate;
  var pop = Object.keys(_populate).reduce(function (vals, key) {
    return vals.concat([_populate[key]]);
  }, []); // lean options should trickle through all queries

  if (options.lean != null) {
    pop.filter(function (p) {
      return (p && p.options && p.options.lean) == null;
    }).forEach(makeLean(options.lean));
  }

  pop.forEach(function (opts) {
    opts._localModel = query.model;
  });
  return pop;
};
/**
 * Prepare a set of path options for query population. This is the MongooseQuery
 * version
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */


exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
  var _populate = query._mongooseOptions.populate;
  var pop = Object.keys(_populate).reduce(function (vals, key) {
    return vals.concat([_populate[key]]);
  }, []); // lean options should trickle through all queries

  if (options.lean != null) {
    pop.filter(function (p) {
      return (p && p.options && p.options.lean) == null;
    }).forEach(makeLean(options.lean));
  }

  var session = query && query.options && query.options.session || null;

  if (session != null) {
    pop.forEach(function (path) {
      if (path.options == null) {
        path.options = {
          session: session
        };
        return;
      }

      if (!('session' in path.options)) {
        path.options.session = session;
      }
    });
  }

  var projection = query._fieldsForExec();

  pop.forEach(function (p) {
    p._queryProjection = projection;
  });
  pop.forEach(function (opts) {
    opts._localModel = query.model;
  });
  return pop;
};
/**
 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
 * it returns an instance of the given model.
 *
 * @param {Model}  model
 * @param {Object} doc
 * @param {Object} fields
 *
 * @return {Document}
 */


exports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
  model.hooks.execPreSync('createModel', doc);
  var discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
  var key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
  var value = doc[key];

  if (key && value && model.discriminators) {
    var discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);

    if (discriminator) {
      var _fields = clone(userProvidedFields);

      exports.applyPaths(_fields, discriminator.schema);
      return new discriminator(undefined, _fields, true);
    }
  }

  var _opts = {
    skipId: true,
    isNew: false,
    willInit: true
  };

  if (options != null && 'defaults' in options) {
    _opts.defaults = options.defaults;
  }

  return new model(undefined, fields, _opts);
};
/*!
 * ignore
 */


exports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {
  var initOpts = populatedIds ? {
    populated: populatedIds
  } : undefined;
  var casted = exports.createModel(model, doc, fields, userProvidedFields, options);

  try {
    casted.$init(doc, initOpts, callback);
  } catch (error) {
    callback(error, casted);
  }
};
/*!
 * ignore
 */


exports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {
  // determine if query is selecting or excluding fields
  var exclude;
  var keys;
  var minusPathsToSkip = new Set();

  if (fields) {
    keys = Object.keys(fields); // Collapse minus paths

    var minusPaths = [];

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (keys[i][0] !== '-') {
        continue;
      }

      delete fields[key];

      if (key === '-_id') {
        fields['_id'] = 0;
      } else {
        minusPaths.push(key.slice(1));
      }
    }

    keys = Object.keys(fields);

    for (var keyIndex = 0; keyIndex < keys.length; ++keyIndex) {
      if (keys[keyIndex][0] === '+') {
        continue;
      }

      var field = fields[keys[keyIndex]]; // Skip `$meta` and `$slice`

      if (!isDefiningProjection(field)) {
        continue;
      }

      if (keys[keyIndex] === '_id' && keys.length > 1) {
        continue;
      }

      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {
        continue;
      }

      exclude = !field;
      break;
    } // Potentially add back minus paths based on schema-level path config
    // and whether the projection is inclusive


    for (var _i = 0, _minusPaths = minusPaths; _i < _minusPaths.length; _i++) {
      var path = _minusPaths[_i];
      var type = schema.path(path); // If the path isn't selected by default or the projection is not
      // inclusive, minus path is treated as equivalent to `key: 0`.
      // But we also allow using `-name` to remove `name` from an inclusive
      // projection if `name` has schema-level `select: true`.

      if (!type || !type.selected || exclude !== false) {
        fields[path] = 0;
        exclude = true;
      } else if (type && type.selected && exclude === false) {
        // Make a note of minus paths that are overwriting paths that are
        // included by default.
        minusPathsToSkip.add(path);
      }
    }
  } // if selecting, apply default schematype select:true fields
  // if excluding, apply schematype select:false fields


  var selected = [];
  var excluded = [];
  var stack = [];
  analyzeSchema(schema);

  switch (exclude) {
    case true:
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = excluded[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fieldName = _step.value;
          fields[fieldName] = 0;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      break;

    case false:
      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {
        fields._id = 0;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = selected[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _fieldName = _step2.value;

          if (minusPathsToSkip.has(_fieldName)) {
            continue;
          }

          if (isPathSelectedInclusive(fields, _fieldName)) {
            continue;
          }

          fields[_fieldName] = fields[_fieldName] || 1;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      break;

    case undefined:
      if (fields == null) {
        break;
      } // Any leftover plus paths must in the schema, so delete them (gh-7017)


      for (var _i2 = 0, _Object$keys = Object.keys(fields || {}); _i2 < _Object$keys.length; _i2++) {
        var _key = _Object$keys[_i2];

        if (_key.startsWith('+')) {
          delete fields[_key];
        }
      } // user didn't specify fields, implies returning all fields.
      // only need to apply excluded fields and delete any plus paths


      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = excluded[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _fieldName2 = _step3.value;

          if (fields[_fieldName2] != null) {
            // Skip applying default projections to fields with non-defining
            // projections, like `$slice`
            continue;
          }

          fields[_fieldName2] = 0;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      break;
  }

  function analyzeSchema(schema, prefix) {
    prefix || (prefix = ''); // avoid recursion

    if (stack.indexOf(schema) !== -1) {
      return [];
    }

    stack.push(schema);
    var addedPaths = [];
    schema.eachPath(function (path, type) {
      if (prefix) path = prefix + '.' + path;

      if (type.$isSchemaMap || path.endsWith('.$*')) {
        var plusPath = '+' + path;
        var hasPlusPath = fields && plusPath in fields;

        if (type.options && type.options.select === false && !hasPlusPath) {
          excluded.push(path);
        }

        return;
      }

      var addedPath = analyzePath(path, type); // arrays

      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
        addedPath = analyzePath(path, type.caster);
      }

      if (addedPath != null) {
        addedPaths.push(addedPath);
      } // nested schemas


      if (type.schema) {
        var _addedPaths = analyzeSchema(type.schema, path); // Special case: if discriminator key is the only field that would
        // be projected in, remove it.


        if (exclude === false) {
          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
        }
      }
    });
    stack.pop();
    return addedPaths;
  }

  function analyzePath(path, type) {
    if (fields == null) {
      return;
    } // If schema-level selected not set, nothing to do


    if (typeof type.selected !== 'boolean') {
      return;
    } // User overwriting default exclusion


    if (type.selected === false && fields[path]) {
      if (sanitizeProjection) {
        fields[path] = 0;
      }

      return;
    } // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,
    // because we have tests that assert that using `-path` to exclude schema-level `select: true`
    // fields counts as an exclusive projection. See gh-11546


    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {
      delete fields[path];
      return;
    }

    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {
      delete fields[path];
      return;
    }

    var plusPath = '+' + path;
    var hasPlusPath = fields && plusPath in fields;

    if (hasPlusPath) {
      // forced inclusion
      delete fields[plusPath]; // if there are other fields being included, add this one
      // if no other included fields, leave this out (implied inclusion)

      if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {
        fields[path] = 1;
      } else if (exclude == null && sanitizeProjection && type.selected === false) {
        fields[path] = 0;
      }

      return;
    } // check for parent exclusions


    var pieces = path.split('.');
    var cur = '';

    for (var _i3 = 0; _i3 < pieces.length; ++_i3) {
      cur += cur.length ? '.' + pieces[_i3] : pieces[_i3];

      if (excluded.indexOf(cur) !== -1) {
        return;
      }
    } // Special case: if user has included a parent path of a discriminator key,
    // don't explicitly project in the discriminator key because that will
    // project out everything else under the parent path


    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {
      var _cur = '';

      for (var _i4 = 0; _i4 < pieces.length; ++_i4) {
        _cur += (_cur.length === 0 ? '' : '.') + pieces[_i4];
        var projection = get(fields, _cur, false) || get(fields, _cur + '.$', false);

        if (projection && _typeof(projection) !== 'object') {
          return;
        }
      }
    }

    (type.selected ? selected : excluded).push(path);
    return path;
  }
};
/**
 * Set each path query option to lean
 *
 * @param {Object} option
 */


function makeLean(val) {
  return function (option) {
    option.options || (option.options = {});

    if (val != null && Array.isArray(val.virtuals)) {
      val = Object.assign({}, val);
      val.virtuals = val.virtuals.filter(function (path) {
        return typeof path === 'string' && path.startsWith(option.path + '.');
      }).map(function (path) {
        return path.slice(option.path.length + 1);
      });
    }

    option.options.lean = val;
  };
}