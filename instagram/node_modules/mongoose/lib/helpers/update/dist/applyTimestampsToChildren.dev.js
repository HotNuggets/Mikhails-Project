'use strict';

var cleanPositionalOperators = require('../schema/cleanPositionalOperators');

var handleTimestampOption = require('../schema/handleTimestampOption');

module.exports = applyTimestampsToChildren;
/*!
 * ignore
 */

function applyTimestampsToChildren(now, update, schema) {
  if (update == null) {
    return;
  }

  var keys = Object.keys(update);
  var hasDollarKey = keys.some(function (key) {
    return key[0] === '$';
  });

  if (hasDollarKey) {
    if (update.$push) {
      _applyTimestampToUpdateOperator(update.$push);
    }

    if (update.$addToSet) {
      _applyTimestampToUpdateOperator(update.$addToSet);
    }

    if (update.$set != null) {
      var _keys = Object.keys(update.$set);

      for (var _i = 0, _keys2 = _keys; _i < _keys2.length; _i++) {
        var key = _keys2[_i];
        applyTimestampsToUpdateKey(schema, key, update.$set, now);
      }
    }

    if (update.$setOnInsert != null) {
      var _keys3 = Object.keys(update.$setOnInsert);

      for (var _i2 = 0, _keys4 = _keys3; _i2 < _keys4.length; _i2++) {
        var _key = _keys4[_i2];
        applyTimestampsToUpdateKey(schema, _key, update.$setOnInsert, now);
      }
    }
  }

  var updateKeys = Object.keys(update).filter(function (key) {
    return key[0] !== '$';
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = updateKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _key2 = _step.value;
      applyTimestampsToUpdateKey(schema, _key2, update, now);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  function _applyTimestampToUpdateOperator(op) {
    var _loop = function _loop() {
      var key = _Object$keys[_i3];
      var $path = schema.path(key.replace(/\.\$\./i, '.').replace(/.\$$/, ''));

      if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
        var timestamps = $path.schema.options.timestamps;
        var createdAt = handleTimestampOption(timestamps, 'createdAt');
        var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

        if (op[key].$each) {
          op[key].$each.forEach(function (subdoc) {
            if (updatedAt != null) {
              subdoc[updatedAt] = now;
            }

            if (createdAt != null) {
              subdoc[createdAt] = now;
            }

            applyTimestampsToChildren(now, subdoc, $path.schema);
          });
        } else {
          if (updatedAt != null) {
            op[key][updatedAt] = now;
          }

          if (createdAt != null) {
            op[key][createdAt] = now;
          }

          applyTimestampsToChildren(now, op[key], $path.schema);
        }
      }
    };

    for (var _i3 = 0, _Object$keys = Object.keys(op); _i3 < _Object$keys.length; _i3++) {
      _loop();
    }
  }
}

function applyTimestampsToDocumentArray(arr, schematype, now) {
  var timestamps = schematype.schema.options.timestamps;
  var len = arr.length;

  if (!timestamps) {
    for (var i = 0; i < len; ++i) {
      applyTimestampsToChildren(now, arr[i], schematype.schema);
    }

    return;
  }

  var createdAt = handleTimestampOption(timestamps, 'createdAt');
  var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

  for (var _i4 = 0; _i4 < len; ++_i4) {
    if (updatedAt != null) {
      arr[_i4][updatedAt] = now;
    }

    if (createdAt != null) {
      arr[_i4][createdAt] = now;
    }

    applyTimestampsToChildren(now, arr[_i4], schematype.schema);
  }
}

function applyTimestampsToSingleNested(subdoc, schematype, now) {
  var timestamps = schematype.schema.options.timestamps;

  if (!timestamps) {
    applyTimestampsToChildren(now, subdoc, schematype.schema);
    return;
  }

  var createdAt = handleTimestampOption(timestamps, 'createdAt');
  var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

  if (updatedAt != null) {
    subdoc[updatedAt] = now;
  }

  if (createdAt != null) {
    subdoc[createdAt] = now;
  }

  applyTimestampsToChildren(now, subdoc, schematype.schema);
}

function applyTimestampsToUpdateKey(schema, key, update, now) {
  // Replace positional operator `$` and array filters `$[]` and `$[.*]`
  var keyToSearch = cleanPositionalOperators(key);
  var path = schema.path(keyToSearch);

  if (!path) {
    return;
  }

  var parentSchemaTypes = [];
  var pieces = keyToSearch.split('.');

  for (var i = pieces.length - 1; i > 0; --i) {
    var s = schema.path(pieces.slice(0, i).join('.'));

    if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
      parentSchemaTypes.push({
        parentPath: key.split('.').slice(0, i).join('.'),
        parentSchemaType: s
      });
    }
  }

  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
    applyTimestampsToDocumentArray(update[key], path, now);
  } else if (update[key] && path.$isSingleNested) {
    applyTimestampsToSingleNested(update[key], path, now);
  } else if (parentSchemaTypes.length > 0) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = parentSchemaTypes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var item = _step2.value;
        var parentPath = item.parentPath;
        var parentSchemaType = item.parentSchemaType;
        var timestamps = parentSchemaType.schema.options.timestamps;
        var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

        if (!timestamps || updatedAt == null) {
          continue;
        }

        if (parentSchemaType.$isSingleNested) {
          // Single nested is easy
          update[parentPath + '.' + updatedAt] = now;
        } else if (parentSchemaType.$isMongooseDocumentArray) {
          var childPath = key.substring(parentPath.length + 1);

          if (/^\d+$/.test(childPath)) {
            update[parentPath + '.' + childPath][updatedAt] = now;
            continue;
          }

          var firstDot = childPath.indexOf('.');
          childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;
          update[parentPath + '.' + childPath + '.' + updatedAt] = now;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } else if (path.schema != null && path.schema != schema && update[key]) {
    var _timestamps = path.schema.options.timestamps;
    var createdAt = handleTimestampOption(_timestamps, 'createdAt');

    var _updatedAt = handleTimestampOption(_timestamps, 'updatedAt');

    if (!_timestamps) {
      return;
    }

    if (_updatedAt != null) {
      update[key][_updatedAt] = now;
    }

    if (createdAt != null) {
      update[key][createdAt] = now;
    }
  }
}