"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var _a, _b;
exports.__esModule = true;
exports.OnDemandDocument = void 0;
var bson_1 = require("../../../bson");
/** @internal */
var OnDemandDocument = /** @class */ (function () {
    function OnDemandDocument(
    /** BSON bytes, this document begins at offset */
    bson, 
    /** The start of the document */
    offset, 
    /** If this is an embedded document, indicates if this was a BSON array */
    isArray, 
    /** If elements was already calculated */
    elements) {
        if (offset === void 0) { offset = 0; }
        if (isArray === void 0) { isArray = false; }
        this.bson = bson;
        this.offset = offset;
        this.isArray = isArray;
        /**
         * Maps JS strings to elements and jsValues for speeding up subsequent lookups.
         * - If `false` then name does not exist in the BSON document
         * - If `CachedBSONElement` instance name exists
         * - If `cache[name].value == null` jsValue has not yet been parsed
         *   - Null/Undefined values do not get cached because they are zero-length values.
         */
        this.cache = Object.create(null);
        /** Caches the index of elements that have been named */
        this.indexFound = Object.create(null);
        this.elements = elements !== null && elements !== void 0 ? elements : bson_1.parseToElementsToArray(this.bson, offset);
    }
    /** Only supports basic latin strings */
    OnDemandDocument.prototype.isElementName = function (name, element) {
        var nameLength = element[2 /* nameLength */];
        var nameOffset = element[1 /* nameOffset */];
        if (name.length !== nameLength)
            return false;
        var nameEnd = nameOffset + nameLength;
        for (var byteIndex = nameOffset, charIndex = 0; charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {
            if (this.bson[byteIndex] !== name.charCodeAt(charIndex))
                return false;
        }
        return true;
    };
    /**
     * Seeks into the elements array for an element matching the given name.
     *
     * @remarks
     * Caching:
     * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately
     * - Caches names mapped to elements to avoid reiterating the array and comparing the name again
     * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name
     *
     * @param name - a basic latin string name of a BSON element
     * @returns
     */
    OnDemandDocument.prototype.getElement = function (name) {
        var cachedElement = this.cache[name];
        if (cachedElement === false)
            return null;
        if (cachedElement != null) {
            return cachedElement;
        }
        if (typeof name === 'number') {
            if (this.isArray) {
                if (name < this.elements.length) {
                    var element = this.elements[name];
                    var cachedElement_1 = { element: element, value: undefined };
                    this.cache[name] = cachedElement_1;
                    this.indexFound[name] = true;
                    return cachedElement_1;
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        for (var index = 0; index < this.elements.length; index++) {
            var element = this.elements[index];
            // skip this element if it has already been associated with a name
            if (!(index in this.indexFound) && this.isElementName(name, element)) {
                var cachedElement_2 = { element: element, value: undefined };
                this.cache[name] = cachedElement_2;
                this.indexFound[index] = true;
                return cachedElement_2;
            }
        }
        this.cache[name] = false;
        return null;
    };
    OnDemandDocument.prototype.toJSValue = function (element, as) {
        var type = element[0 /* type */];
        var offset = element[3 /* offset */];
        var length = element[4 /* length */];
        if (as !== type) {
            return null;
        }
        switch (as) {
            case bson_1.BSONType["null"]:
            case bson_1.BSONType.undefined:
                return null;
            case bson_1.BSONType.double:
                return bson_1.getFloat64LE(this.bson, offset);
            case bson_1.BSONType.int:
                return bson_1.getInt32LE(this.bson, offset);
            case bson_1.BSONType.long:
                return bson_1.getBigInt64LE(this.bson, offset);
            case bson_1.BSONType.bool:
                return Boolean(this.bson[offset]);
            case bson_1.BSONType.objectId:
                return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));
            case bson_1.BSONType.timestamp:
                return new bson_1.Timestamp(bson_1.getBigInt64LE(this.bson, offset));
            case bson_1.BSONType.string:
                return bson_1.toUTF8(this.bson, offset + 4, offset + length - 1, false);
            case bson_1.BSONType.binData: {
                var totalBinarySize = bson_1.getInt32LE(this.bson, offset);
                var subType = this.bson[offset + 4];
                if (subType === 2) {
                    var subType2BinarySize = bson_1.getInt32LE(this.bson, offset + 1 + 4);
                    if (subType2BinarySize < 0)
                        throw new bson_1.BSONError('Negative binary type element size found for subtype 0x02');
                    if (subType2BinarySize > totalBinarySize - 4)
                        throw new bson_1.BSONError('Binary type with subtype 0x02 contains too long binary size');
                    if (subType2BinarySize < totalBinarySize - 4)
                        throw new bson_1.BSONError('Binary type with subtype 0x02 contains too short binary size');
                    return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);
                }
                return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);
            }
            case bson_1.BSONType.date:
                // Pretend this is correct.
                return new Date(Number(bson_1.getBigInt64LE(this.bson, offset)));
            case bson_1.BSONType.object:
                return new OnDemandDocument(this.bson, offset);
            case bson_1.BSONType.array:
                return new OnDemandDocument(this.bson, offset, true);
            default:
                throw new bson_1.BSONError("Unsupported BSON type: " + as);
        }
    };
    /**
     * Returns the number of elements in this BSON document
     */
    OnDemandDocument.prototype.size = function () {
        return this.elements.length;
    };
    /**
     * Checks for the existence of an element by name.
     *
     * @remarks
     * Uses `getElement` with the expectation that will populate caches such that a `has` call
     * followed by a `getElement` call will not repeat the cost paid by the first look up.
     *
     * @param name - element name
     */
    OnDemandDocument.prototype.has = function (name) {
        var cachedElement = this.cache[name];
        if (cachedElement === false)
            return false;
        if (cachedElement != null)
            return true;
        return this.getElement(name) != null;
    };
    return OnDemandDocument;
}());
exports.OnDemandDocument = OnDemandDocument;
keyof;
JSTypeOf > (name);
string | number,
    as;
T,
    required ?  : boolean | undefined;
JSTypeOf[T] | null;
get < ;
var T, keyof, JSTypeOf;
 > (name);
string | number,
    as;
T,
    required;
true;
JSTypeOf[T];
get < ;
var T, keyof, JSTypeOf;
 > (name);
string | number,
    as;
T,
    required ?  : boolean;
JSTypeOf[T] | null;
{
    var element = this.getElement(name);
    if (element == null) {
        if (required === true) {
            throw new bson_1.BSONError("BSON element \"" + name + "\" is missing");
        }
        else {
            return null;
        }
    }
    if (element.value == null) {
        var value = this.toJSValue(element.element, as);
        if (value == null) {
            if (required === true) {
                throw new bson_1.BSONError("BSON element \"" + name + "\" is missing");
            }
            else {
                return null;
            }
        }
        // It is important to never store null
        element.value = value;
    }
    return element.value;
}
getNumber < ;
var Req, boolean = false > (name), string, required, Req;
Req;
true ? number : number | null;
getNumber(name, string, required, boolean);
number | null;
{
    var maybeBool = this.get(name, bson_1.BSONType.bool);
    var bool = maybeBool == null ? null : maybeBool ? 1 : 0;
    var maybeLong = this.get(name, bson_1.BSONType.long);
    var long = maybeLong == null ? null : Number(maybeLong);
    var result = (_b = (_a = bool !== null && bool !== void 0 ? bool : long) !== null && _a !== void 0 ? _a : this.get(name, bson_1.BSONType.int)) !== null && _b !== void 0 ? _b : this.get(name, bson_1.BSONType.double);
    if (required === true && result == null) {
        throw new bson_1.BSONError("BSON element \"" + name + "\" is missing");
    }
    return result;
}
toObject(options ?  : OnDemandDocumentDeserializeOptions);
Record < string, any > {
    "return": bson_1.deserialize(this.bson, __assign(__assign({}, options), { index: this.offset, allowObjectSmallerThanBufferSize: true }))
};
/** Returns this document's bytes only */
toBytes();
{
    var size = bson_1.getInt32LE(this.bson, this.offset);
    return this.bson.subarray(this.offset, this.offset + size);
}
