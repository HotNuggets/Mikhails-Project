"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.BSONRegExp = void 0;
var bson_value_1 = require("./bson_value");
var error_1 = require("./error");
var utils_1 = require("./parser/utils");
function alphabetize(str) {
    return str.split('').sort().join('');
}
/**
 * A class representation of the BSON RegExp type.
 * @public
 * @category BSONType
 */
var BSONRegExp = /** @class */ (function (_super) {
    __extends(BSONRegExp, _super);
    /**
     * @param pattern - The regular expression pattern to match
     * @param options - The regular expression options
     */
    function BSONRegExp(pattern, options) {
        var _this = _super.call(this) || this;
        _this.pattern = pattern;
        _this.options = alphabetize(options !== null && options !== void 0 ? options : '');
        if (_this.pattern.indexOf('\x00') !== -1) {
            throw new error_1.BSONError("BSON Regex patterns cannot contain null bytes, found: " + JSON.stringify(_this.pattern));
        }
        if (_this.options.indexOf('\x00') !== -1) {
            throw new error_1.BSONError("BSON Regex options cannot contain null bytes, found: " + JSON.stringify(_this.options));
        }
        // Validate options
        for (var i = 0; i < _this.options.length; i++) {
            if (!(_this.options[i] === 'i' ||
                _this.options[i] === 'm' ||
                _this.options[i] === 'x' ||
                _this.options[i] === 'l' ||
                _this.options[i] === 's' ||
                _this.options[i] === 'u')) {
                throw new error_1.BSONError("The regular expression option [" + _this.options[i] + "] is not supported");
            }
        }
        return _this;
    }
    Object.defineProperty(BSONRegExp.prototype, "_bsontype", {
        get: function () {
            return 'BSONRegExp';
        },
        enumerable: false,
        configurable: true
    });
    BSONRegExp.parseOptions = function (options) {
        return options ? options.split('').sort().join('') : '';
    };
    /** @internal */
    BSONRegExp.prototype.toExtendedJSON = function (options) {
        options = options || {};
        if (options.legacy) {
            return { $regex: this.pattern, $options: this.options };
        }
        return { $regularExpression: { pattern: this.pattern, options: this.options } };
    };
    /** @internal */
    BSONRegExp.fromExtendedJSON = function (doc) {
        if ('$regex' in doc) {
            if (typeof doc.$regex !== 'string') {
                // This is for $regex query operators that have extended json values.
                if (doc.$regex._bsontype === 'BSONRegExp') {
                    return doc;
                }
            }
            else {
                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
            }
        }
        if ('$regularExpression' in doc) {
            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
        }
        throw new error_1.BSONError("Unexpected BSONRegExp EJSON object form: " + JSON.stringify(doc));
    };
    BSONRegExp.prototype.inspect = function (depth, options, inspect) {
        var _a;
        var stylize = (_a = utils_1.getStylizeFunction(options)) !== null && _a !== void 0 ? _a : (function (v) { return v; });
        inspect !== null && inspect !== void 0 ? inspect : ;
        utils_1.defaultInspect;
        var pattern = stylize(inspect(this.pattern), 'regexp');
        var flags = stylize(inspect(this.options), 'regexp');
        return "new BSONRegExp(" + pattern + ", " + flags + ")";
    };
    return BSONRegExp;
}(bson_value_1.BSONValue));
exports.BSONRegExp = BSONRegExp;
