"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.Collection = void 0;
var bson_1 = require("./bson");
var ordered_1 = require("./bulk/ordered");
var unordered_1 = require("./bulk/unordered");
var change_stream_1 = require("./change_stream");
var aggregation_cursor_1 = require("./cursor/aggregation_cursor");
var find_cursor_1 = require("./cursor/find_cursor");
var list_indexes_cursor_1 = require("./cursor/list_indexes_cursor");
var list_search_indexes_cursor_1 = require("./cursor/list_search_indexes_cursor");
var error_1 = require("./error");
var bulk_write_1 = require("./operations/bulk_write");
var count_1 = require("./operations/count");
var delete_1 = require("./operations/delete");
var distinct_1 = require("./operations/distinct");
var drop_1 = require("./operations/drop");
var estimated_document_count_1 = require("./operations/estimated_document_count");
var execute_operation_1 = require("./operations/execute_operation");
var find_and_modify_1 = require("./operations/find_and_modify");
var indexes_1 = require("./operations/indexes");
var insert_1 = require("./operations/insert");
var is_capped_1 = require("./operations/is_capped");
var options_operation_1 = require("./operations/options_operation");
var rename_1 = require("./operations/rename");
var create_1 = require("./operations/search_indexes/create");
var drop_2 = require("./operations/search_indexes/drop");
var update_1 = require("./operations/search_indexes/update");
var update_2 = require("./operations/update");
var read_concern_1 = require("./read_concern");
var read_preference_1 = require("./read_preference");
var utils_1 = require("./utils");
var write_concern_1 = require("./write_concern");
/**
 * The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/find/update/delete and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @public
 *
 * @example
 * ```ts
 * import { MongoClient } from 'mongodb';
 *
 * interface Pet {
 *   name: string;
 *   kind: 'dog' | 'cat' | 'fish';
 * }
 *
 * const client = new MongoClient('mongodb://localhost:27017');
 * const pets = client.db().collection<Pet>('pets');
 *
 * const petCursor = pets.find();
 *
 * for await (const pet of petCursor) {
 *   console.log(`${pet.name} is a ${pet.kind}!`);
 * }
 * ```
 */
var Collection = /** @class */ (function () {
    /**
     * Create a new Collection instance
     * @internal
     */
    function Collection(db, name, options) {
        var _a, _b;
        // Internal state
        this.s = {
            db: db,
            options: options,
            namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
            pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,
            readPreference: read_preference_1.ReadPreference.fromOptions(options),
            bsonOptions: bson_1.resolveBSONOptions(options, db),
            readConcern: read_concern_1.ReadConcern.fromOptions(options),
            writeConcern: write_concern_1.WriteConcern.fromOptions(options)
        };
        this.client = db.client;
    }
    Object.defineProperty(Collection.prototype, "dbName", {
        /**
         * The name of the database this collection belongs to
         */
        get: function () {
            return this.s.namespace.db;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
        /**
         * The name of this collection
         */
        get: function () {
            return this.s.namespace.collection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "namespace", {
        /**
         * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
         */
        get: function () {
            return this.fullNamespace.toString();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "fullNamespace", {
        /**
         *  @internal
         *
         * The `MongoDBNamespace` for the collection.
         */
        get: function () {
            return this.s.namespace;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
        /**
         * The current readConcern of the collection. If not explicitly defined for
         * this collection, will be inherited from the parent DB
         */
        get: function () {
            if (this.s.readConcern == null) {
                return this.s.db.readConcern;
            }
            return this.s.readConcern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
        /**
         * The current readPreference of the collection. If not explicitly defined for
         * this collection, will be inherited from the parent DB
         */
        get: function () {
            if (this.s.readPreference == null) {
                return this.s.db.readPreference;
            }
            return this.s.readPreference;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "bsonOptions", {
        get: function () {
            return this.s.bsonOptions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
        /**
         * The current writeConcern of the collection. If not explicitly defined for
         * this collection, will be inherited from the parent DB
         */
        get: function () {
            if (this.s.writeConcern == null) {
                return this.s.db.writeConcern;
            }
            return this.s.writeConcern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Collection.prototype, "hint", {
        /** The current index hint for the collection */
        get: function () {
            return this.s.collectionHint;
        },
        set: function (v) {
            this.s.collectionHint = utils_1.normalizeHintField(v);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @param doc - The document to insert
     * @param options - Optional settings for the command
     */
    Collection.prototype.insertOne = function (doc, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new insert_1.InsertOneOperation(this, doc, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @param docs - The documents to insert
     * @param options - Optional settings for the command
     */
    Collection.prototype.insertMany = function (docs, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new insert_1.InsertManyOperation(this, docs, utils_1.resolveOptions(this, options !== null && options !== void 0 ? options : { ordered: true })))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Perform a bulkWrite operation without a fluent API
     *
     * Legal operation types are
     * - `insertOne`
     * - `replaceOne`
     * - `updateOne`
     * - `updateMany`
     * - `deleteOne`
     * - `deleteMany`
     *
     * If documents passed in do not contain the **_id** field,
     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
     * can be overridden by setting the **forceServerObjectId** flag.
     *
     * @param operations - Bulk operations to perform
     * @param options - Optional settings for the command
     * @throws MongoDriverError if operations is not an array
     */
    Collection.prototype.bulkWrite = function (operations, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!Array.isArray(operations)) {
                            throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
                        }
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new bulk_write_1.BulkWriteOperation(this, operations, utils_1.resolveOptions(this, options !== null && options !== void 0 ? options : { ordered: true })))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Update a single document in a collection
     *
     * The value of `update` can be either:
     * - UpdateFilter<TSchema> - A document that contains update operator expressions,
     * - Document[] - an aggregation pipeline.
     *
     * @param filter - The filter used to select the document to update
     * @param update - The modifications to apply
     * @param options - Optional settings for the command
     */
    Collection.prototype.updateOne = function (filter, update, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new update_2.UpdateOneOperation(this, filter, update, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Replace a document in a collection with another document
     *
     * @param filter - The filter used to select the document to replace
     * @param replacement - The Document that replaces the matching document
     * @param options - Optional settings for the command
     */
    Collection.prototype.replaceOne = function (filter, replacement, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Update multiple documents in a collection
     *
     * The value of `update` can be either:
     * - UpdateFilter<TSchema> - A document that contains update operator expressions,
     * - Document[] - an aggregation pipeline.
     *
     * @param filter - The filter used to select the document to update
     * @param update - The modifications to apply
     * @param options - Optional settings for the command
     */
    Collection.prototype.updateMany = function (filter, update, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new update_2.UpdateManyOperation(this, filter, update, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Delete a document from a collection
     *
     * @param filter - The filter used to select the document to remove
     * @param options - Optional settings for the command
     */
    Collection.prototype.deleteOne = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new delete_1.DeleteOneOperation(this, filter, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Delete multiple documents from a collection
     *
     * @param filter - The filter used to select the documents to remove
     * @param options - Optional settings for the command
     */
    Collection.prototype.deleteMany = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new delete_1.DeleteManyOperation(this, filter, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Rename the collection.
     *
     * @remarks
     * This operation does not inherit options from the Db or MongoClient.
     *
     * @param newName - New name of of the collection.
     * @param options - Optional settings for the command
     */
    Collection.prototype.rename = function (newName, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new rename_1.RenameOperation(this, newName, __assign(__assign({}, options), { readPreference: read_preference_1.ReadPreference.PRIMARY })))];
                    case 1: 
                    // Intentionally, we do not inherit options from parent for this operation.
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
     *
     * @param options - Optional settings for the command
     */
    Collection.prototype.drop = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Collection.prototype.findOne = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            var cursor, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cursor = this.find(filter, options).limit(-1).batchSize(1);
                        return [4 /*yield*/, cursor.next()];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, cursor.close()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    Collection.prototype.find = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, utils_1.resolveOptions(this, options));
    };
    /**
     * Returns the options of the collection.
     *
     * @param options - Optional settings for the command
     */
    Collection.prototype.options = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new options_operation_1.OptionsOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Returns if the collection is a capped collection
     *
     * @param options - Optional settings for the command
     */
    Collection.prototype.isCapped = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new is_capped_1.IsCappedOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Creates an index on the db and collection collection.
     *
     * @param indexSpec - The field name or index specification to create an index for
     * @param options - Optional settings for the command
     *
     * @example
     * ```ts
     * const collection = client.db('foo').collection('bar');
     *
     * await collection.createIndex({ a: 1, b: -1 });
     *
     * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes
     * await collection.createIndex([ [c, 1], [d, -1] ]);
     *
     * // Equivalent to { e: 1 }
     * await collection.createIndex('e');
     *
     * // Equivalent to { f: 1, g: 1 }
     * await collection.createIndex(['f', 'g'])
     *
     * // Equivalent to { h: 1, i: -1 }
     * await collection.createIndex([ { h: 1 }, { i: -1 } ]);
     *
     * // Equivalent to { j: 1, k: -1, l: 2d }
     * await collection.createIndex(['j', ['k', -1], { l: '2d' }])
     * ```
     */
    Collection.prototype.createIndex = function (indexSpec, options) {
        return __awaiter(this, void 0, Promise, function () {
            var indexes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, this.collectionName, indexSpec, utils_1.resolveOptions(this, options)))];
                    case 1:
                        indexes = _a.sent();
                        return [2 /*return*/, indexes[0]];
                }
            });
        });
    };
    /**
     * Creates multiple indexes in the collection, this method is only supported for
     * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
     * error.
     *
     * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.
     * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.
     *
     * @param indexSpecs - An array of index specifications to be created
     * @param options - Optional settings for the command
     *
     * @example
     * ```ts
     * const collection = client.db('foo').collection('bar');
     * await collection.createIndexes([
     *   // Simple index on field fizz
     *   {
     *     key: { fizz: 1 },
     *   }
     *   // wildcard index
     *   {
     *     key: { '$**': 1 }
     *   },
     *   // named index on darmok and jalad
     *   {
     *     key: { darmok: 1, jalad: -1 }
     *     name: 'tanagra'
     *   }
     * ]);
     * ```
     */
    Collection.prototype.createIndexes = function (indexSpecs, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, indexes_1.CreateIndexesOperation.fromIndexDescriptionArray(this, this.collectionName, indexSpecs, utils_1.resolveOptions(this, __assign(__assign({}, options), { maxTimeMS: undefined }))))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Drops an index from this collection.
     *
     * @param indexName - Name of the index to drop.
     * @param options - Optional settings for the command
     */
    Collection.prototype.dropIndex = function (indexName, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new indexes_1.DropIndexOperation(this, indexName, __assign(__assign({}, utils_1.resolveOptions(this, options)), { readPreference: read_preference_1.ReadPreference.primary })))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Drops all indexes from this collection.
     *
     * @param options - Optional settings for the command
     */
    Collection.prototype.dropIndexes = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new indexes_1.DropIndexOperation(this, '*', utils_1.resolveOptions(this, options)))];
                    case 1:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 2:
                        _a = _b.sent();
                        return [2 /*return*/, false];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the list of all indexes information for the collection.
     *
     * @param options - Optional settings for the command
     */
    Collection.prototype.listIndexes = function (options) {
        return new list_indexes_cursor_1.ListIndexesCursor(this, utils_1.resolveOptions(this, options));
    };
    /**
     * Checks if one or more indexes exist on the collection, fails on first non-existing index
     *
     * @param indexes - One or more index names to check.
     * @param options - Optional settings for the command
     */
    Collection.prototype.indexExists = function (indexes, options) {
        return __awaiter(this, void 0, Promise, function () {
            var indexNames, allIndexes, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        indexNames = Array.isArray(indexes) ? indexes : [indexes];
                        _a = Set.bind;
                        return [4 /*yield*/, this.listIndexes(options)
                                .map(function (_a) {
                                var name = _a.name;
                                return name;
                            })
                                .toArray()];
                    case 1:
                        allIndexes = new (_a.apply(Set, [void 0, _b.sent()]))();
                        return [2 /*return*/, indexNames.every(function (name) { return allIndexes.has(name); })];
                }
            });
        });
    };
    Collection.prototype.indexInformation = function (options) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.indexes(__assign(__assign({}, options), { full: (_a = options === null || options === void 0 ? void 0 : options.full) !== null && _a !== void 0 ? _a : false }))];
                    case 1: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    /**
     * Gets an estimate of the count of documents in a collection using collection metadata.
     * This will always run a count command on all server versions.
     *
     * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,
     * which estimatedDocumentCount uses in its implementation, was not included in v1 of
     * the Stable API, and so users of the Stable API with estimatedDocumentCount are
     * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid
     * encountering errors.
     *
     * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}
     * @param options - Optional settings for the command
     */
    Collection.prototype.estimatedDocumentCount = function (options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Gets the number of documents matching the filter.
     * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
     * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}
     * the following query operators must be replaced:
     *
     * | Operator | Replacement |
     * | -------- | ----------- |
     * | `$where`   | [`$expr`][1] |
     * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
     * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
     *
     * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/
     * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
     * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
     * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
     *
     * @param filter - The filter for the count
     * @param options - Optional settings for the command
     *
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
     * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
     */
    Collection.prototype.countDocuments = function (filter, options) {
        var _a;
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            var pipeline, cursor, doc;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        pipeline = [];
                        pipeline.push({ $match: filter });
                        if (typeof options.skip === 'number') {
                            pipeline.push({ $skip: options.skip });
                        }
                        if (typeof options.limit === 'number') {
                            pipeline.push({ $limit: options.limit });
                        }
                        pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
                        cursor = this.aggregate(pipeline, options);
                        return [4 /*yield*/, cursor.next()];
                    case 1:
                        doc = _b.sent();
                        return [4 /*yield*/, cursor.close()];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, (_a = doc === null || doc === void 0 ? void 0 : doc.n) !== null && _a !== void 0 ? _a : 0];
                }
            });
        });
    };
    Collection.prototype.distinct = function (key, filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new distinct_1.DistinctOperation(this, key, filter, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Collection.prototype.indexes = function (options) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var indexes, full, object;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.listIndexes(options).toArray()];
                    case 1:
                        indexes = _b.sent();
                        full = (_a = options === null || options === void 0 ? void 0 : options.full) !== null && _a !== void 0 ? _a : true;
                        if (full) {
                            return [2 /*return*/, indexes];
                        }
                        object = Object.fromEntries(indexes.map(function (_a) {
                            var name = _a.name, key = _a.key;
                            return [name, Object.entries(key)];
                        }));
                        return [2 /*return*/, object];
                }
            });
        });
    };
    Collection.prototype.findOneAndDelete = function (filter, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Collection.prototype.findOneAndReplace = function (filter, replacement, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Collection.prototype.findOneAndUpdate = function (filter, update, options) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
     *
     * @param pipeline - An array of aggregation pipelines to execute
     * @param options - Optional settings for the command
     */
    Collection.prototype.aggregate = function (pipeline, options) {
        if (pipeline === void 0) { pipeline = []; }
        if (!Array.isArray(pipeline)) {
            throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
        }
        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, utils_1.resolveOptions(this, options));
    };
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct use cases:
     * - The first is to override the schema that may be defined for this specific collection
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     * @example
     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
     * ```ts
     * collection.watch<{ _id: number }>()
     *   .on('change', change => console.log(change._id.toFixed(4)));
     * ```
     *
     * @example
     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
     * No need start from scratch on the ChangeStreamInsertDocument type!
     * By using an intersection we can save time and ensure defaults remain the same type!
     * ```ts
     * collection
     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
     *     { $addFields: { comment: 'big changes' } },
     *     { $match: { operationType: 'insert' } }
     *   ])
     *   .on('change', change => {
     *     change.comment.startsWith('big');
     *     change.operationType === 'insert';
     *     // No need to narrow in code because the generics did that for us!
     *     expectType<Schema>(change.fullDocument);
     *   });
     * ```
     *
     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TLocal - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */
    Collection.prototype.watch = function (pipeline, options) {
        if (pipeline === void 0) { pipeline = []; }
        if (options === void 0) { options = {}; }
        // Allow optionally not specifying a pipeline
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));
    };
    /**
     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
     *
     * @throws MongoNotConnectedError
     * @remarks
     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
     */
    Collection.prototype.initializeUnorderedBulkOp = function (options) {
        return new unordered_1.UnorderedBulkOperation(this, utils_1.resolveOptions(this, options));
    };
    /**
     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
     *
     * @throws MongoNotConnectedError
     * @remarks
     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
     */
    Collection.prototype.initializeOrderedBulkOp = function (options) {
        return new ordered_1.OrderedBulkOperation(this, utils_1.resolveOptions(this, options));
    };
    /**
     * An estimated count of matching documents in the db to a filter.
     *
     * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents
     * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.
     * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
     *
     * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead
     *
     * @param filter - The filter for the count.
     * @param options - Optional settings for the command
     */
    Collection.prototype.count = function (filter, options) {
        if (filter === void 0) { filter = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new count_1.CountOperation(this.fullNamespace, filter, utils_1.resolveOptions(this, options)))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Collection.prototype.listSearchIndexes = function (indexNameOrOptions, options) {
        options =
            typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;
        var indexName = indexNameOrOptions == null
            ? null
            : typeof indexNameOrOptions === 'object'
                ? null
                : indexNameOrOptions;
        return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
    };
    /**
     * Creates a single search index for the collection.
     *
     * @param description - The index description for the new search index.
     * @returns A promise that resolves to the name of the new search index.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     */
    Collection.prototype.createSearchIndex = function (description) {
        return __awaiter(this, void 0, Promise, function () {
            var index;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createSearchIndexes([description])];
                    case 1:
                        index = (_a.sent())[0];
                        return [2 /*return*/, index];
                }
            });
        });
    };
    /**
     * Creates multiple search indexes for the current collection.
     *
     * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.
     * @returns A promise that resolves to an array of the newly created search index names.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     * @returns
     */
    Collection.prototype.createSearchIndexes = function (descriptions) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Deletes a search index by index name.
     *
     * @param name - The name of the search index to be deleted.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     */
    Collection.prototype.dropSearchIndex = function (name) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new drop_2.DropSearchIndexOperation(this, name))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Updates a search index by replacing the existing index definition with the provided definition.
     *
     * @param name - The name of the search index to update.
     * @param definition - The new search index definition.
     *
     * @remarks Only available when used against a 7.0+ Atlas cluster.
     */
    Collection.prototype.updateSearchIndex = function (name, definition) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, execute_operation_1.executeOperation(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return Collection;
}());
exports.Collection = Collection;
