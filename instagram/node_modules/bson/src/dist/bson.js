"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
exports.__esModule = true;
exports.deserializeStream = exports.calculateObjectSize = exports.deserialize = exports.serializeWithBufferAndIndex = exports.serialize = exports.setInternalBufferSize = exports.Decimal128 = exports.BSONRegExp = exports.MaxKey = exports.MinKey = exports.Int32 = exports.Double = exports.Timestamp = exports.Long = exports.UUID = exports.ObjectId = exports.Binary = exports.DBRef = exports.BSONSymbol = exports.Code = void 0;
var binary_1 = require("./binary");
exports.Binary = binary_1.Binary;
exports.UUID = binary_1.UUID;
var code_1 = require("./code");
exports.Code = code_1.Code;
var db_ref_1 = require("./db_ref");
exports.DBRef = db_ref_1.DBRef;
var decimal128_1 = require("./decimal128");
exports.Decimal128 = decimal128_1.Decimal128;
var double_1 = require("./double");
exports.Double = double_1.Double;
var int_32_1 = require("./int_32");
exports.Int32 = int_32_1.Int32;
var long_1 = require("./long");
exports.Long = long_1.Long;
var max_key_1 = require("./max_key");
exports.MaxKey = max_key_1.MaxKey;
var min_key_1 = require("./min_key");
exports.MinKey = min_key_1.MinKey;
var objectid_1 = require("./objectid");
exports.ObjectId = objectid_1.ObjectId;
var calculate_size_1 = require("./parser/calculate_size");
// Parts of the parser
var deserializer_1 = require("./parser/deserializer");
var serializer_1 = require("./parser/serializer");
var regexp_1 = require("./regexp");
exports.BSONRegExp = regexp_1.BSONRegExp;
var symbol_1 = require("./symbol");
exports.BSONSymbol = symbol_1.BSONSymbol;
var timestamp_1 = require("./timestamp");
exports.Timestamp = timestamp_1.Timestamp;
var byte_utils_1 = require("./utils/byte_utils");
var number_utils_1 = require("./utils/number_utils");
var bson_value_1 = require("./bson_value");
__createBinding(exports, bson_value_1, "BSONValue");
var error_1 = require("./error");
__createBinding(exports, error_1, "BSONError");
__createBinding(exports, error_1, "BSONVersionError");
__createBinding(exports, error_1, "BSONRuntimeError");
__createBinding(exports, error_1, "BSONOffsetError");
var constants_1 = require("./constants");
__createBinding(exports, constants_1, "BSONType");
var extended_json_1 = require("./extended_json");
__createBinding(exports, extended_json_1, "EJSON");
var index_1 = require("./parser/on_demand/index");
__createBinding(exports, index_1, "onDemand");
__createBinding(exports, index_1, "type");
/** @internal */
// Default Max Size
var MAXSIZE = 1024 * 1024 * 17;
// Current Internal Temporary Serialization Buffer
var buffer = byte_utils_1.ByteUtils.allocate(MAXSIZE);
/**
 * Sets the size of the internal serialization buffer.
 *
 * @param size - The desired size for the internal serialization buffer in bytes
 * @public
 */
function setInternalBufferSize(size) {
    // Resize the internal serialization buffer if needed
    if (buffer.length < size) {
        buffer = byte_utils_1.ByteUtils.allocate(size);
    }
}
exports.setInternalBufferSize = setInternalBufferSize;
/**
 * Serialize a Javascript object.
 *
 * @param object - the Javascript object to serialize.
 * @returns Buffer object containing the serialized object.
 * @public
 */
function serialize(object, options) {
    if (options === void 0) { options = {}; }
    // Unpack the options
    var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
    var minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;
    // Resize the internal serialization buffer if needed
    if (buffer.length < minInternalBufferSize) {
        buffer = byte_utils_1.ByteUtils.allocate(minInternalBufferSize);
    }
    // Attempt to serialize
    var serializationIndex = serializer_1.serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    // Create the final buffer
    var finishedBuffer = byte_utils_1.ByteUtils.allocateUnsafe(serializationIndex);
    // Copy into the finished buffer
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    // Return the buffer
    return finishedBuffer;
}
exports.serialize = serialize;
/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer,
 * useful when pre-allocating the space for serialization.
 *
 * @param object - the Javascript object to serialize.
 * @param finalBuffer - the Buffer you pre-allocated to store the serialized BSON object.
 * @returns the index pointing to the last written byte in the buffer.
 * @public
 */
function serializeWithBufferAndIndex(object, finalBuffer, options) {
    if (options === void 0) { options = {}; }
    // Unpack the options
    var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
    var startIndex = typeof options.index === 'number' ? options.index : 0;
    // Attempt to serialize
    var serializationIndex = serializer_1.serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    // Return the index
    return startIndex + serializationIndex - 1;
}
exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
/**
 * Deserialize data as BSON.
 *
 * @param buffer - the buffer containing the serialized set of BSON documents.
 * @returns returns the deserialized Javascript Object.
 * @public
 */
function deserialize(buffer, options) {
    if (options === void 0) { options = {}; }
    return deserializer_1.internalDeserialize(byte_utils_1.ByteUtils.toLocalBufferType(buffer), options);
}
exports.deserialize = deserialize;
/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param object - the Javascript object to calculate the BSON byte size for
 * @returns size of BSON object in bytes
 * @public
 */
function calculateObjectSize(object, options) {
    if (options === void 0) { options = {}; }
    options = options || {};
    var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
    return calculate_size_1.internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
}
exports.calculateObjectSize = calculateObjectSize;
/**
 * Deserialize stream data as BSON documents.
 *
 * @param data - the buffer containing the serialized set of BSON documents.
 * @param startIndex - the start index in the data Buffer where the deserialization is to start.
 * @param numberOfDocuments - number of documents to deserialize.
 * @param documents - an array where to store the deserialized documents.
 * @param docStartIndex - the index in the documents array from where to start inserting documents.
 * @param options - additional options used for the deserialization.
 * @returns next index in the buffer after deserialization **x** numbers of documents.
 * @public
 */
function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    var internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    var bufferData = byte_utils_1.ByteUtils.toLocalBufferType(data);
    var index = startIndex;
    // Loop over all documents
    for (var i = 0; i < numberOfDocuments; i++) {
        // Find size of the document
        var size = number_utils_1.NumberUtils.getInt32LE(bufferData, index);
        // Update options with index
        internalOptions.index = index;
        // Parse the document at this point
        documents[docStartIndex + i] = deserializer_1.internalDeserialize(bufferData, internalOptions);
        // Adjust index by the document size
        index = index + size;
    }
    // Return object containing end index of parsing and list of documents
    return index;
}
exports.deserializeStream = deserializeStream;
