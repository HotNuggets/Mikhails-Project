'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hasIncludedChildren = require('./hasIncludedChildren');

var isExclusive = require('./isExclusive');

var isInclusive = require('./isInclusive');

var isPOJO = require('../../utils').isPOJO;

module.exports = function applyProjection(doc, projection, _hasIncludedChildren) {
  if (projection == null) {
    return doc;
  }

  if (doc == null) {
    return doc;
  }

  var exclude = null;

  if (isInclusive(projection)) {
    exclude = false;
  } else if (isExclusive(projection)) {
    exclude = true;
  }

  if (exclude == null) {
    return doc;
  } else if (exclude) {
    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
    return applyExclusiveProjection(doc, projection, _hasIncludedChildren);
  } else {
    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
  }
};

function applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {
  if (doc == null || _typeof(doc) !== 'object') {
    return doc;
  }

  if (Array.isArray(doc)) {
    return doc.map(function (el) {
      return applyExclusiveProjection(el, projection, hasIncludedChildren, projectionLimb, prefix);
    });
  }

  var ret = _objectSpread({}, doc);

  projectionLimb = prefix ? projectionLimb || {} : projection;

  for (var _i = 0, _Object$keys = Object.keys(ret); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var fullPath = prefix ? prefix + '.' + key : key;

    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
      } else {
        delete ret[key];
      }
    } else if (hasIncludedChildren[fullPath]) {
      ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
    }
  }

  return ret;
}

function applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {
  if (doc == null || _typeof(doc) !== 'object') {
    return doc;
  }

  if (Array.isArray(doc)) {
    return doc.map(function (el) {
      return applyInclusiveProjection(el, projection, hasIncludedChildren, projectionLimb, prefix);
    });
  }

  var ret = _objectSpread({}, doc);

  projectionLimb = prefix ? projectionLimb || {} : projection;

  for (var _i2 = 0, _Object$keys2 = Object.keys(ret); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    var fullPath = prefix ? prefix + '.' + key : key;

    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
      }

      continue;
    } else if (hasIncludedChildren[fullPath]) {
      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
    } else {
      delete ret[key];
    }
  }

  return ret;
}