"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = void 0;

var whatwg_url_1 = require("whatwg-url");

var redact_1 = require("./redact");

Object.defineProperty(exports, "redactConnectionString", {
  enumerable: true,
  get: function get() {
    return redact_1.redactConnectionString;
  }
});
var DUMMY_HOSTNAME = '__this_is_a_placeholder__';

function connectionStringHasValidScheme(connectionString) {
  return connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://');
}

var HOSTS_REGEX = _wrapRegExp(/^([\0-\.0-\uFFFF]+):\/\/(?:([\0-9;-\?A-\uFFFF]*)(?::([\0-\?A-\uFFFF]*))?@)?((?!:)[\0-\.0->A-\uFFFF]*)(.*)/, {
  protocol: 1,
  username: 2,
  password: 3,
  hosts: 4,
  rest: 5
});

var CaseInsensitiveMap =
/*#__PURE__*/
function (_Map) {
  _inherits(CaseInsensitiveMap, _Map);

  function CaseInsensitiveMap() {
    _classCallCheck(this, CaseInsensitiveMap);

    return _possibleConstructorReturn(this, _getPrototypeOf(CaseInsensitiveMap).apply(this, arguments));
  }

  _createClass(CaseInsensitiveMap, [{
    key: "delete",
    value: function _delete(name) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "delete", this).call(this, this._normalizeKey(name));
    }
  }, {
    key: "get",
    value: function get(name) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "get", this).call(this, this._normalizeKey(name));
    }
  }, {
    key: "has",
    value: function has(name) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "has", this).call(this, this._normalizeKey(name));
    }
  }, {
    key: "set",
    value: function set(name, value) {
      return _get(_getPrototypeOf(CaseInsensitiveMap.prototype), "set", this).call(this, this._normalizeKey(name), value);
    }
  }, {
    key: "_normalizeKey",
    value: function _normalizeKey(name) {
      name = "".concat(name);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (key.toLowerCase() === name.toLowerCase()) {
            name = key;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return name;
    }
  }]);

  return CaseInsensitiveMap;
}(_wrapNativeSuper(Map));

function caseInsenstiveURLSearchParams(Ctor) {
  return (
    /*#__PURE__*/
    function (_Ctor) {
      _inherits(CaseInsenstiveURLSearchParams, _Ctor);

      function CaseInsenstiveURLSearchParams() {
        _classCallCheck(this, CaseInsenstiveURLSearchParams);

        return _possibleConstructorReturn(this, _getPrototypeOf(CaseInsenstiveURLSearchParams).apply(this, arguments));
      }

      _createClass(CaseInsenstiveURLSearchParams, [{
        key: "append",
        value: function append(name, value) {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "append", this).call(this, this._normalizeKey(name), value);
        }
      }, {
        key: "delete",
        value: function _delete(name) {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "delete", this).call(this, this._normalizeKey(name));
        }
      }, {
        key: "get",
        value: function get(name) {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "get", this).call(this, this._normalizeKey(name));
        }
      }, {
        key: "getAll",
        value: function getAll(name) {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "getAll", this).call(this, this._normalizeKey(name));
        }
      }, {
        key: "has",
        value: function has(name) {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "has", this).call(this, this._normalizeKey(name));
        }
      }, {
        key: "set",
        value: function set(name, value) {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "set", this).call(this, this._normalizeKey(name), value);
        }
      }, {
        key: "keys",
        value: function keys() {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "keys", this).call(this);
        }
      }, {
        key: "values",
        value: function values() {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "values", this).call(this);
        }
      }, {
        key: "entries",
        value: function entries() {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), "entries", this).call(this);
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return _get(_getPrototypeOf(CaseInsenstiveURLSearchParams.prototype), Symbol.iterator, this).call(this);
        }
      }, {
        key: "_normalizeKey",
        value: function _normalizeKey(name) {
          return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
        }
      }]);

      return CaseInsenstiveURLSearchParams;
    }(Ctor)
  );
}

var URLWithoutHost =
/*#__PURE__*/
function (_whatwg_url_1$URL) {
  _inherits(URLWithoutHost, _whatwg_url_1$URL);

  function URLWithoutHost() {
    _classCallCheck(this, URLWithoutHost);

    return _possibleConstructorReturn(this, _getPrototypeOf(URLWithoutHost).apply(this, arguments));
  }

  return URLWithoutHost;
}(whatwg_url_1.URL);

var MongoParseError =
/*#__PURE__*/
function (_Error) {
  _inherits(MongoParseError, _Error);

  function MongoParseError() {
    _classCallCheck(this, MongoParseError);

    return _possibleConstructorReturn(this, _getPrototypeOf(MongoParseError).apply(this, arguments));
  }

  _createClass(MongoParseError, [{
    key: "name",
    get: function get() {
      return 'MongoParseError';
    }
  }]);

  return MongoParseError;
}(_wrapNativeSuper(Error));

var ConnectionString =
/*#__PURE__*/
function (_URLWithoutHost) {
  _inherits(ConnectionString, _URLWithoutHost);

  function ConnectionString(uri) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ConnectionString);

    var _a;

    var looseValidation = options.looseValidation;

    if (!looseValidation && !connectionStringHasValidScheme(uri)) {
      throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
    }

    var match = uri.match(HOSTS_REGEX);

    if (!match) {
      throw new MongoParseError("Invalid connection string \"".concat(uri, "\""));
    }

    var _ref = (_a = match.groups) !== null && _a !== void 0 ? _a : {},
        protocol = _ref.protocol,
        username = _ref.username,
        password = _ref.password,
        hosts = _ref.hosts,
        rest = _ref.rest;

    if (!looseValidation) {
      if (!protocol || !hosts) {
        throw new MongoParseError("Protocol and host list are required in \"".concat(uri, "\""));
      }

      try {
        decodeURIComponent(username !== null && username !== void 0 ? username : '');
        decodeURIComponent(password !== null && password !== void 0 ? password : '');
      } catch (err) {
        throw new MongoParseError(err.message);
      }

      var illegalCharacters = /[:/?#[\]@]/gi;

      if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
        throw new MongoParseError("Username contains unescaped characters ".concat(username));
      }

      if (!username || !password) {
        var uriWithoutProtocol = uri.replace("".concat(protocol, "://"), '');

        if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {
          throw new MongoParseError('URI contained empty userinfo section');
        }
      }

      if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
        throw new MongoParseError('Password contains unescaped characters');
      }
    }

    var authString = '';
    if (typeof username === 'string') authString += username;
    if (typeof password === 'string') authString += ":".concat(password);
    if (authString) authString += '@';

    try {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionString).call(this, "".concat(protocol.toLowerCase(), "://").concat(authString).concat(DUMMY_HOSTNAME).concat(rest)));
    } catch (err) {
      if (looseValidation) {
        new ConnectionString(uri, _objectSpread({}, options, {
          looseValidation: false
        }));
      }

      if (typeof err.message === 'string') {
        err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
      }

      throw err;
    }

    _this._hosts = hosts.split(',');

    if (!looseValidation) {
      if (_this.isSRV && _this.hosts.length !== 1) {
        throw new MongoParseError('mongodb+srv URI cannot have multiple service names');
      }

      if (_this.isSRV && _this.hosts.some(function (host) {
        return host.includes(':');
      })) {
        throw new MongoParseError('mongodb+srv URI cannot have port number');
      }
    }

    if (!_this.pathname) {
      _this.pathname = '/';
    }

    Object.setPrototypeOf(_this.searchParams, caseInsenstiveURLSearchParams(_this.searchParams.constructor).prototype);
    return _this;
  }

  _createClass(ConnectionString, [{
    key: "toString",
    value: function toString() {
      return _get(_getPrototypeOf(ConnectionString.prototype), "toString", this).call(this).replace(DUMMY_HOSTNAME, this.hosts.join(','));
    }
  }, {
    key: "clone",
    value: function clone() {
      return new ConnectionString(this.toString(), {
        looseValidation: true
      });
    }
  }, {
    key: "redact",
    value: function redact(options) {
      return (0, redact_1.redactValidConnectionString)(this, options);
    }
  }, {
    key: "typedSearchParams",
    value: function typedSearchParams() {
      var sametype = false && new (caseInsenstiveURLSearchParams(whatwg_url_1.URLSearchParams))();
      return this.searchParams;
    }
  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value() {
      var href = this.href,
          origin = this.origin,
          protocol = this.protocol,
          username = this.username,
          password = this.password,
          hosts = this.hosts,
          pathname = this.pathname,
          search = this.search,
          searchParams = this.searchParams,
          hash = this.hash;
      return {
        href: href,
        origin: origin,
        protocol: protocol,
        username: username,
        password: password,
        hosts: hosts,
        pathname: pathname,
        search: search,
        searchParams: searchParams,
        hash: hash
      };
    }
  }, {
    key: "host",
    get: function get() {
      return DUMMY_HOSTNAME;
    },
    set: function set(_ignored) {
      throw new Error('No single host for connection string');
    }
  }, {
    key: "hostname",
    get: function get() {
      return DUMMY_HOSTNAME;
    },
    set: function set(_ignored) {
      throw new Error('No single host for connection string');
    }
  }, {
    key: "port",
    get: function get() {
      return '';
    },
    set: function set(_ignored) {
      throw new Error('No single host for connection string');
    }
  }, {
    key: "href",
    get: function get() {
      return this.toString();
    },
    set: function set(_ignored) {
      throw new Error('Cannot set href for connection strings');
    }
  }, {
    key: "isSRV",
    get: function get() {
      return this.protocol.includes('srv');
    }
  }, {
    key: "hosts",
    get: function get() {
      return this._hosts;
    },
    set: function set(list) {
      this._hosts = list;
    }
  }]);

  return ConnectionString;
}(URLWithoutHost);

exports.ConnectionString = ConnectionString;

var CommaAndColonSeparatedRecord =
/*#__PURE__*/
function (_CaseInsensitiveMap) {
  _inherits(CommaAndColonSeparatedRecord, _CaseInsensitiveMap);

  function CommaAndColonSeparatedRecord(from) {
    var _this2;

    _classCallCheck(this, CommaAndColonSeparatedRecord);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CommaAndColonSeparatedRecord).call(this));
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (from !== null && from !== void 0 ? from : '').split(',')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var entry = _step2.value;
        if (!entry) continue;
        var colonIndex = entry.indexOf(':');

        if (colonIndex === -1) {
          _this2.set(entry, '');
        } else {
          _this2.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return _this2;
  }

  _createClass(CommaAndColonSeparatedRecord, [{
    key: "toString",
    value: function toString() {
      return _toConsumableArray(this).map(function (entry) {
        return entry.join(':');
      }).join(',');
    }
  }]);

  return CommaAndColonSeparatedRecord;
}(CaseInsensitiveMap);

exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
exports["default"] = ConnectionString;