"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var usm = require("./url-state-machine");

var urlencoded = require("./urlencoded");

var URLSearchParams = require("./URLSearchParams");

exports.implementation =
/*#__PURE__*/
function () {
  // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
  // messages in the constructor that distinguish between the different causes of failure.
  function URLImpl(globalObject, constructorArgs) {
    _classCallCheck(this, URLImpl);

    var url = constructorArgs[0];
    var base = constructorArgs[1];
    var parsedBase = null;

    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);

      if (parsedBase === null) {
        throw new TypeError("Invalid base URL: ".concat(base));
      }
    }

    var parsedURL = usm.basicURLParse(url, {
      baseURL: parsedBase
    });

    if (parsedURL === null) {
      throw new TypeError("Invalid URL: ".concat(url));
    }

    var query = parsedURL.query !== null ? parsedURL.query : "";
    this._url = parsedURL; // We cannot invoke the "new URLSearchParams object" algorithm without going through the constructor, which strips
    // question mark by default. Therefore the doNotStripQMark hack is used.

    this._query = URLSearchParams.createImpl(globalObject, [query], {
      doNotStripQMark: true
    });
    this._query._url = this;
  }

  _createClass(URLImpl, [{
    key: "toJSON",
    value: function toJSON() {
      return this.href;
    }
  }, {
    key: "_potentiallyStripTrailingSpacesFromAnOpaquePath",
    value: function _potentiallyStripTrailingSpacesFromAnOpaquePath() {
      if (!usm.hasAnOpaquePath(this._url)) {
        return;
      }

      if (this._url.fragment !== null) {
        return;
      }

      if (this._url.query !== null) {
        return;
      }

      this._url.path = this._url.path.replace(/ +$/, "");
    }
  }, {
    key: "href",
    get: function get() {
      return usm.serializeURL(this._url);
    },
    set: function set(v) {
      var parsedURL = usm.basicURLParse(v);

      if (parsedURL === null) {
        throw new TypeError("Invalid URL: ".concat(v));
      }

      this._url = parsedURL;

      this._query._list.splice(0);

      var query = parsedURL.query;

      if (query !== null) {
        this._query._list = urlencoded.parseUrlencodedString(query);
      }
    }
  }, {
    key: "origin",
    get: function get() {
      return usm.serializeURLOrigin(this._url);
    }
  }, {
    key: "protocol",
    get: function get() {
      return "".concat(this._url.scheme, ":");
    },
    set: function set(v) {
      usm.basicURLParse("".concat(v, ":"), {
        url: this._url,
        stateOverride: "scheme start"
      });
    }
  }, {
    key: "username",
    get: function get() {
      return this._url.username;
    },
    set: function set(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }

      usm.setTheUsername(this._url, v);
    }
  }, {
    key: "password",
    get: function get() {
      return this._url.password;
    },
    set: function set(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }

      usm.setThePassword(this._url, v);
    }
  }, {
    key: "host",
    get: function get() {
      var url = this._url;

      if (url.host === null) {
        return "";
      }

      if (url.port === null) {
        return usm.serializeHost(url.host);
      }

      return "".concat(usm.serializeHost(url.host), ":").concat(usm.serializeInteger(url.port));
    },
    set: function set(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }

      usm.basicURLParse(v, {
        url: this._url,
        stateOverride: "host"
      });
    }
  }, {
    key: "hostname",
    get: function get() {
      if (this._url.host === null) {
        return "";
      }

      return usm.serializeHost(this._url.host);
    },
    set: function set(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }

      usm.basicURLParse(v, {
        url: this._url,
        stateOverride: "hostname"
      });
    }
  }, {
    key: "port",
    get: function get() {
      if (this._url.port === null) {
        return "";
      }

      return usm.serializeInteger(this._url.port);
    },
    set: function set(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }

      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, {
          url: this._url,
          stateOverride: "port"
        });
      }
    }
  }, {
    key: "pathname",
    get: function get() {
      return usm.serializePath(this._url);
    },
    set: function set(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }

      this._url.path = [];
      usm.basicURLParse(v, {
        url: this._url,
        stateOverride: "path start"
      });
    }
  }, {
    key: "search",
    get: function get() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }

      return "?".concat(this._url.query);
    },
    set: function set(v) {
      var url = this._url;

      if (v === "") {
        url.query = null;
        this._query._list = [];

        this._potentiallyStripTrailingSpacesFromAnOpaquePath();

        return;
      }

      var input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, {
        url: url,
        stateOverride: "query"
      });
      this._query._list = urlencoded.parseUrlencodedString(input);
    }
  }, {
    key: "searchParams",
    get: function get() {
      return this._query;
    }
  }, {
    key: "hash",
    get: function get() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }

      return "#".concat(this._url.fragment);
    },
    set: function set(v) {
      if (v === "") {
        this._url.fragment = null;

        this._potentiallyStripTrailingSpacesFromAnOpaquePath();

        return;
      }

      var input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, {
        url: this._url,
        stateOverride: "fragment"
      });
    }
  }], [{
    key: "canParse",
    value: function canParse(url, base) {
      var parsedBase = null;

      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);

        if (parsedBase === null) {
          return false;
        }
      }

      var parsedURL = usm.basicURLParse(url, {
        baseURL: parsedBase
      });

      if (parsedURL === null) {
        return false;
      }

      return true;
    }
  }]);

  return URLImpl;
}();